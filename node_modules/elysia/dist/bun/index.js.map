{
  "version": 3,
  "sources": ["../../src/index.ts", "../../src/type-system.ts", "../../src/formats.ts", "../../src/error.ts", "../../src/utils.ts", "../../src/sucrose.ts", "../../src/cookies.ts", "../../src/deuri.ts", "../../src/adapter/web-standard/handler.ts", "../../src/adapter/web-standard/index.ts", "../../src/adapter/bun/handler.ts", "../../src/ws/index.ts", "../../src/adapter/bun/index.ts", "../../src/universal/utils.ts", "../../src/universal/env.ts", "../../src/compose.ts", "../../src/fast-querystring.ts", "../../src/trace.ts", "../../src/dynamic-handle.ts", "../../src/universal/file.ts"],
  "sourcesContent": [
    "import { Memoirist } from 'memoirist'\nimport type {\n\tTObject,\n\tStatic,\n\tTSchema,\n\tTModule,\n\tTRef,\n\tTProperties\n} from '@sinclair/typebox'\n\nimport type { Context } from './context'\n\nimport { t, TypeCheck } from './type-system'\nimport { sucrose, type Sucrose } from './sucrose'\n\nimport type { WSLocalHook } from './ws/types'\n\nimport { BunAdapter } from './adapter/bun/index'\nimport { WebStandardAdapter } from './adapter/web-standard/index'\nimport type { ElysiaAdapter } from './adapter/types'\n\nimport { env } from './universal/env'\nimport type { ListenCallback, Serve, Server } from './universal/server'\n\nimport {\n\tcloneInference,\n\tcoercePrimitiveRoot,\n\tdeduplicateChecksum,\n\tfnToContainer,\n\tgetLoosePath,\n\tlocalHookToLifeCycleStore,\n\tmergeDeep,\n\tmergeSchemaValidator,\n\tPromiseGroup,\n\tpromoteEvent,\n\tstringToStructureCoercions,\n\tisNotEmpty,\n\treplaceSchemaType,\n\tcompressHistoryHook,\n\tencodePath\n} from './utils'\n\nimport {\n\tcomposeHandler,\n\tcomposeGeneralHandler,\n\tcomposeErrorHandler\n} from './compose'\n\nimport { createTracer } from './trace'\n\nimport {\n\tmergeHook,\n\tgetSchemaValidator,\n\tgetResponseSchemaValidator,\n\tchecksum,\n\tmergeLifeCycle,\n\tfilterGlobalHook,\n\tasHookType,\n\ttraceBackMacro,\n\treplaceUrlPath,\n\tcreateMacroManager,\n\tgetCookieValidator\n} from './utils'\n\nimport {\n\tcreateDynamicErrorHandler,\n\tcreateDynamicHandler,\n\ttype DynamicHandler\n} from './dynamic-handle'\n\nimport {\n\tERROR_CODE,\n\tValidationError,\n\ttype ParseError,\n\ttype NotFoundError,\n\ttype InternalServerError,\n\tElysiaCustomStatusResponse\n} from './error'\n\nimport type { TraceHandler } from './trace'\n\nimport type {\n\tElysiaConfig,\n\tSingletonBase,\n\tDefinitionBase,\n\tHandler,\n\tComposedHandler,\n\tInputSchema,\n\tLocalHook,\n\tAnyLocalHook,\n\tMergeSchema,\n\tRouteSchema,\n\tUnwrapRoute,\n\tInternalRoute,\n\tHTTPMethod,\n\tSchemaValidator,\n\tPreHandler,\n\tBodyHandler,\n\tOptionalHandler,\n\tAfterHandler,\n\tErrorHandler,\n\tLifeCycleStore,\n\tMaybePromise,\n\tPrettify,\n\tPrettify2,\n\tAddPrefix,\n\tAddSuffix,\n\tAddPrefixCapitalize,\n\tAddSuffixCapitalize,\n\tMaybeArray,\n\tGracefulHandler,\n\tMapResponse,\n\tChecksum,\n\tMacroManager,\n\tMacroToProperty,\n\tTransformHandler,\n\tMetadataBase,\n\tRouteBase,\n\tCreateEden,\n\tComposeElysiaResponse,\n\tInlineHandler,\n\tHookContainer,\n\tLifeCycleType,\n\tMacroQueue,\n\tEphemeralType,\n\tExcludeElysiaResponse,\n\tModelValidator,\n\tBaseMacroFn,\n\tContextAppendType,\n\tReconcile,\n\tAfterResponseHandler,\n\tHigherOrderFunction,\n\tResolvePath,\n\tJoinPath,\n\tValidatorLayer,\n\tMergeElysiaInstances,\n\tHookMacroFn,\n\tResolveHandler,\n\tResolveResolutions,\n\tUnwrapTypeModule,\n\tMacroToContext,\n\tMergeTypeModule\n} from './types'\n\nexport type AnyElysia = Elysia<any, any, any, any, any, any, any>\n\n/**\n * ### Elysia Server\n * Main instance to create web server using Elysia\n *\n * ---\n * @example\n * ```typescript\n * import { Elysia } from 'elysia'\n *\n * new Elysia()\n *     .get(\"/\", () => \"Hello\")\n *     .listen(3000)\n * ```\n */\nexport default class Elysia<\n\tconst in out BasePath extends string = '',\n\tconst in out Singleton extends SingletonBase = {\n\t\tdecorator: {}\n\t\tstore: {}\n\t\tderive: {}\n\t\tresolve: {}\n\t},\n\tconst in out Definitions extends DefinitionBase = {\n\t\ttypebox: TModule<{}>\n\t\terror: {}\n\t},\n\tconst in out Metadata extends MetadataBase = {\n\t\tschema: {}\n\t\tmacro: {}\n\t\tmacroFn: {}\n\t\tparser: {}\n\t},\n\tconst out Routes extends RouteBase = {},\n\t// ? scoped\n\tconst in out Ephemeral extends EphemeralType = {\n\t\tderive: {}\n\t\tresolve: {}\n\t\tschema: {}\n\t},\n\t// ? local\n\tconst in out Volatile extends EphemeralType = {\n\t\tderive: {}\n\t\tresolve: {}\n\t\tschema: {}\n\t}\n> {\n\tconfig: ElysiaConfig<BasePath>\n\n\tserver: Server | null = null\n\tprivate dependencies: Record<string, Checksum[]> = {}\n\n\t_routes: Routes = {} as any\n\n\t_types = {\n\t\tPrefix: '' as BasePath,\n\t\tSingleton: {} as Singleton,\n\t\tDefinitions: {} as Definitions,\n\t\tMetadata: {} as Metadata\n\t}\n\n\t_ephemeral = {} as Ephemeral\n\t_volatile = {} as Volatile\n\n\tprotected singleton = {\n\t\tdecorator: {},\n\t\tstore: {},\n\t\tderive: {},\n\t\tresolve: {}\n\t} as Singleton\n\n\tget store(): Singleton['store'] {\n\t\treturn this.singleton.store\n\t}\n\n\tget decorator(): Singleton['decorator'] {\n\t\treturn this.singleton.decorator\n\t}\n\n\tprotected definitions = {\n\t\ttypebox: t.Module({}),\n\t\ttype: {} as Record<string, TSchema>,\n\t\terror: {} as Record<string, Error>\n\t}\n\n\tprotected extender = {\n\t\tmacros: <MacroQueue[]>[],\n\t\thigherOrderFunctions: <HookContainer<HigherOrderFunction>[]>[]\n\t}\n\n\tprotected validator: ValidatorLayer = {\n\t\tglobal: null,\n\t\tscoped: null,\n\t\tlocal: null,\n\t\tgetCandidate() {\n\t\t\treturn mergeSchemaValidator(\n\t\t\t\tmergeSchemaValidator(this.global, this.scoped),\n\t\t\t\tthis.local\n\t\t\t)\n\t\t}\n\t}\n\n\tevent: Partial<LifeCycleStore> = {}\n\n\tprotected telemetry = {\n\t\tstack: undefined as string | undefined\n\t}\n\n\trouter = {\n\t\t'~http': undefined as\n\t\t\t| Memoirist<{\n\t\t\t\t\tcompile: Function\n\t\t\t\t\thandler?: ComposedHandler\n\t\t\t  }>\n\t\t\t| undefined,\n\t\tget http() {\n\t\t\tif (!this['~http']) this['~http'] = new Memoirist({ lazy: true })\n\n\t\t\treturn this['~http']\n\t\t},\n\t\t'~dynamic': undefined as Memoirist<DynamicHandler> | undefined,\n\t\t// Use in non-AOT mode\n\t\tget dynamic() {\n\t\t\tif (!this['~dynamic']) this['~dynamic'] = new Memoirist()\n\n\t\t\treturn this['~dynamic']\n\t\t},\n\t\tstatic: {\n\t\t\thttp: {\n\t\t\t\tstatic: {} as Record<string, Response>,\n\t\t\t\t// handlers: [] as ComposedHandler[],\n\t\t\t\tmap: {} as Record<\n\t\t\t\t\tstring,\n\t\t\t\t\t{\n\t\t\t\t\t\tcode: string\n\t\t\t\t\t\tall?: string\n\t\t\t\t\t}\n\t\t\t\t>,\n\t\t\t\tall: ''\n\t\t\t},\n\t\t\t// Static WS Router is consists of pathname and websocket handler index to compose\n\t\t\tws: {} as Record<string, number>\n\t\t},\n\t\thistory: [] as InternalRoute[]\n\t}\n\n\tprotected routeTree = new Map<string, number>()\n\n\tget routes(): InternalRoute[] {\n\t\treturn this.router.history\n\t}\n\n\tprotected getGlobalRoutes(): InternalRoute[] {\n\t\treturn this.router.history\n\t}\n\n\tprotected inference: Sucrose.Inference = {\n\t\tbody: false,\n\t\tcookie: false,\n\t\theaders: false,\n\t\tquery: false,\n\t\tset: false,\n\t\tserver: false,\n\t\trequest: false,\n\t\troute: false\n\t}\n\n\tprivate getServer() {\n\t\treturn this.server\n\t}\n\n\tprivate getParent(): Elysia | null {\n\t\treturn null\n\t}\n\n\t'~parser': Record<string, BodyHandler<any, any>> = {}\n\n\tprivate _promisedModules: PromiseGroup | undefined\n\tprivate get promisedModules() {\n\t\tif (!this._promisedModules) this._promisedModules = new PromiseGroup()\n\n\t\treturn this._promisedModules\n\t}\n\n\tconstructor(config: ElysiaConfig<BasePath> = {}) {\n\t\tif (config.tags) {\n\t\t\tif (!config.detail)\n\t\t\t\tconfig.detail = {\n\t\t\t\t\ttags: config.tags\n\t\t\t\t}\n\t\t\telse config.detail.tags = config.tags\n\t\t}\n\n\t\tif (config.nativeStaticResponse === undefined)\n\t\t\tconfig.nativeStaticResponse = true\n\n\t\tthis.config = {}\n\t\tthis.applyConfig(config ?? {})\n\n\t\tthis['~adapter'] =\n\t\t\tconfig.adapter ??\n\t\t\t(typeof Bun !== 'undefined' ? BunAdapter : WebStandardAdapter)\n\n\t\tif (config?.analytic && (config?.name || config?.seed !== undefined))\n\t\t\tthis.telemetry.stack = new Error().stack\n\t}\n\n\t'~adapter': ElysiaAdapter\n\n\tenv(model: TObject<any>, _env = env) {\n\t\tconst validator = getSchemaValidator(model, {\n\t\t\tmodules: this.definitions.typebox,\n\t\t\tdynamic: true,\n\t\t\tadditionalProperties: true,\n\t\t\tcoerce: true\n\t\t})\n\n\t\tif (validator.Check(_env) === false) {\n\t\t\tconst error = new ValidationError('env', model, _env)\n\n\t\t\tthrow new Error(error.all.map((x) => x.summary).join('\\n'))\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * @private DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n\t * @version 1.1.0\n\t *\n\t * ! Do not use unless you know exactly what you are doing\n\t * ? Add Higher order function to Elysia.fetch\n\t */\n\twrap(fn: HigherOrderFunction) {\n\t\tthis.extender.higherOrderFunctions.push({\n\t\t\tchecksum: checksum(\n\t\t\t\tJSON.stringify({\n\t\t\t\t\tname: this.config.name,\n\t\t\t\t\tseed: this.config.seed,\n\t\t\t\t\tcontent: fn.toString()\n\t\t\t\t})\n\t\t\t),\n\t\t\tfn\n\t\t})\n\n\t\treturn this\n\t}\n\n\tprivate applyMacro(localHook: AnyLocalHook) {\n\t\tif (this.extender.macros.length) {\n\t\t\tconst manage = createMacroManager({\n\t\t\t\tglobalHook: this.event,\n\t\t\t\tlocalHook\n\t\t\t})\n\n\t\t\tconst manager: MacroManager = {\n\t\t\t\tevents: {\n\t\t\t\t\tglobal: this.event,\n\t\t\t\t\tlocal: localHook\n\t\t\t\t},\n\t\t\t\tget onParse() {\n\t\t\t\t\treturn manage('parse') as any\n\t\t\t\t},\n\t\t\t\tget onTransform() {\n\t\t\t\t\treturn manage('transform') as any\n\t\t\t\t},\n\t\t\t\tget onBeforeHandle() {\n\t\t\t\t\treturn manage('beforeHandle') as any\n\t\t\t\t},\n\t\t\t\tget onAfterHandle() {\n\t\t\t\t\treturn manage('afterHandle') as any\n\t\t\t\t},\n\t\t\t\tget mapResponse() {\n\t\t\t\t\treturn manage('mapResponse') as any\n\t\t\t\t},\n\t\t\t\tget onAfterResponse() {\n\t\t\t\t\treturn manage('afterResponse') as any\n\t\t\t\t},\n\t\t\t\tget onError() {\n\t\t\t\t\treturn manage('error') as any\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (const macro of this.extender.macros)\n\t\t\t\ttraceBackMacro(macro.fn(manager), localHook, manage)\n\t\t}\n\t}\n\n\tapplyConfig(config: ElysiaConfig<BasePath>) {\n\t\tthis.config = {\n\t\t\tprefix: '',\n\t\t\taot: env.ELYSIA_AOT !== 'false',\n\t\t\tnormalize: true,\n\t\t\t...config,\n\t\t\tcookie: {\n\t\t\t\tpath: '/',\n\t\t\t\t...config?.cookie\n\t\t\t},\n\t\t\texperimental: config?.experimental ?? {},\n\t\t\tseed: config?.seed === undefined ? '' : config?.seed\n\t\t} as any\n\n\t\treturn this\n\t}\n\n\tget models(): {\n\t\t[K in keyof Definitions['typebox']]: ModelValidator<\n\t\t\tUnwrapTypeModule<Definitions['typebox']>[K]\n\t\t>\n\t} & {\n\t\tmodules: Definitions['typebox']\n\t} {\n\t\tconst models: Record<string, TypeCheck<TSchema>> = {}\n\n\t\tfor (const name of Object.keys(this.definitions.type))\n\t\t\tmodels[name] = getSchemaValidator(\n\t\t\t\t// @ts-expect-error\n\t\t\t\tthis.definitions.typebox.Import(name)\n\t\t\t) as TypeCheck<TSchema>\n\n\t\t// @ts-expect-error\n\t\tmodels.modules = this.definitions.typebox\n\n\t\treturn models as any\n\t}\n\n\tprivate add(\n\t\tmethod: HTTPMethod,\n\t\tpath: string,\n\t\thandle: Handler<any, any, any> | any,\n\t\tlocalHook?: AnyLocalHook,\n\t\t{ allowMeta = false, skipPrefix = false } = {\n\t\t\tallowMeta: false as boolean | undefined,\n\t\t\tskipPrefix: false as boolean | undefined\n\t\t}\n\t) {\n\t\tlocalHook = compressHistoryHook(localHookToLifeCycleStore(localHook))\n\n\t\tif (path !== '' && path.charCodeAt(0) !== 47) path = '/' + path\n\n\t\tif (this.config.prefix && !skipPrefix) path = this.config.prefix + path\n\n\t\tif (localHook?.type)\n\t\t\tswitch (localHook.type) {\n\t\t\t\tcase 'text':\n\t\t\t\t\tlocalHook.type = 'text/plain'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'json':\n\t\t\t\t\tlocalHook.type = 'application/json'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'formdata':\n\t\t\t\t\tlocalHook.type = 'multipart/form-data'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'urlencoded':\n\t\t\t\t\tlocalHook.type = 'application/x-www-form-urlencoded'\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'arrayBuffer':\n\t\t\t\t\tlocalHook.type = 'application/octet-stream'\n\t\t\t\t\tbreak\n\n\t\t\t\tdefault:\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\tconst models = this.definitions.type\n\t\tconst dynamic = !this.config.aot\n\n\t\t// ? Clone is need because of JIT, so the context doesn't switch between instance\n\t\tconst instanceValidator = { ...this.validator.getCandidate() }\n\n\t\tconst cloned = {\n\t\t\tbody: localHook?.body ?? (instanceValidator?.body as any),\n\t\t\theaders: localHook?.headers ?? (instanceValidator?.headers as any),\n\t\t\tparams: localHook?.params ?? (instanceValidator?.params as any),\n\t\t\tquery: localHook?.query ?? (instanceValidator?.query as any),\n\t\t\tcookie: localHook?.cookie ?? (instanceValidator?.cookie as any),\n\t\t\tresponse:\n\t\t\t\tlocalHook?.response ?? (instanceValidator?.response as any)\n\t\t}\n\n\t\tconst cookieValidator = () =>\n\t\t\tcloned.cookie\n\t\t\t\t? getCookieValidator({\n\t\t\t\t\t\tmodules,\n\t\t\t\t\t\tvalidator: cloned.cookie,\n\t\t\t\t\t\tdefaultConfig: this.config.cookie,\n\t\t\t\t\t\tconfig: cloned.cookie?.config ?? {},\n\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\tmodels\n\t\t\t\t\t})\n\t\t\t\t: undefined\n\n\t\tconst normalize = this.config.normalize\n\t\tconst modules = this.definitions.typebox\n\n\t\tconst validator =\n\t\t\tthis.config.precompile === true ||\n\t\t\t(typeof this.config.precompile === 'object' &&\n\t\t\t\tthis.config.precompile.schema === true)\n\t\t\t\t? {\n\t\t\t\t\t\tbody: getSchemaValidator(cloned.body, {\n\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tnormalize,\n\t\t\t\t\t\t\tadditionalCoerce: coercePrimitiveRoot()\n\t\t\t\t\t\t}),\n\t\t\t\t\t\theaders: getSchemaValidator(cloned.headers, {\n\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tadditionalProperties: !this.config.normalize,\n\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\tadditionalCoerce: stringToStructureCoercions()\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tparams: getSchemaValidator(cloned.params, {\n\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\tadditionalCoerce: stringToStructureCoercions()\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tquery: getSchemaValidator(cloned.query, {\n\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tnormalize,\n\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\tadditionalCoerce: stringToStructureCoercions()\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tcookie: cookieValidator(),\n\t\t\t\t\t\tresponse: getResponseSchemaValidator(cloned.response, {\n\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\tnormalize\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t: ({\n\t\t\t\t\t\tcreateBody() {\n\t\t\t\t\t\t\tif (this.body) return this.body\n\n\t\t\t\t\t\t\treturn (this.body = getSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.body,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tnormalize,\n\t\t\t\t\t\t\t\t\tadditionalCoerce: coercePrimitiveRoot()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateHeaders() {\n\t\t\t\t\t\t\tif (this.headers) return this.headers\n\n\t\t\t\t\t\t\treturn (this.headers = getSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.headers,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tadditionalProperties: !normalize,\n\t\t\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\t\t\tadditionalCoerce:\n\t\t\t\t\t\t\t\t\t\tstringToStructureCoercions()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateParams() {\n\t\t\t\t\t\t\tif (this.params) return this.params\n\n\t\t\t\t\t\t\treturn (this.params = getSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.params,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\t\t\tadditionalCoerce:\n\t\t\t\t\t\t\t\t\t\tstringToStructureCoercions()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateQuery() {\n\t\t\t\t\t\t\tif (this.query) return this.query\n\n\t\t\t\t\t\t\t// console.dir(\n\t\t\t\t\t\t\t// \tgetSchemaValidator(cloned.query, {\n\t\t\t\t\t\t\t// \t\tmodules,\n\t\t\t\t\t\t\t// \t\tdynamic,\n\t\t\t\t\t\t\t// \t\tmodels,\n\t\t\t\t\t\t\t// \t\tcoerce: true,\n\t\t\t\t\t\t\t// \t\tadditionalCoerce:\n\t\t\t\t\t\t\t// \t\t\tstringToStructureCoercions()\n\t\t\t\t\t\t\t// \t}).schema,\n\t\t\t\t\t\t\t// \t{\n\t\t\t\t\t\t\t// \t\tdepth: null\n\t\t\t\t\t\t\t// \t}\n\t\t\t\t\t\t\t// )\n\n\t\t\t\t\t\t\treturn (this.query = getSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.query,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tcoerce: true,\n\t\t\t\t\t\t\t\t\tadditionalCoerce:\n\t\t\t\t\t\t\t\t\t\tstringToStructureCoercions()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateCookie() {\n\t\t\t\t\t\t\tif (this.cookie) return this.cookie\n\n\t\t\t\t\t\t\treturn (this.cookie = cookieValidator())\n\t\t\t\t\t\t},\n\t\t\t\t\t\tcreateResponse() {\n\t\t\t\t\t\t\tif (this.response) return this.response\n\n\t\t\t\t\t\t\treturn (this.response = getResponseSchemaValidator(\n\t\t\t\t\t\t\t\tcloned.response,\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tmodules,\n\t\t\t\t\t\t\t\t\tdynamic,\n\t\t\t\t\t\t\t\t\tmodels,\n\t\t\t\t\t\t\t\t\tnormalize\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t))\n\t\t\t\t\t\t}\n\t\t\t\t\t} as any)\n\n\t\tlocalHook = mergeHook(\n\t\t\tlocalHook,\n\t\t\tcompressHistoryHook(instanceValidator as any)\n\t\t)\n\n\t\tif (localHook.tags) {\n\t\t\tif (!localHook.detail)\n\t\t\t\tlocalHook.detail = {\n\t\t\t\t\ttags: localHook.tags\n\t\t\t\t}\n\t\t\telse localHook.detail.tags = localHook.tags\n\t\t}\n\n\t\tif (isNotEmpty(this.config.detail))\n\t\t\tlocalHook.detail = mergeDeep(\n\t\t\t\tObject.assign({}, this.config.detail!),\n\t\t\t\tlocalHook.detail\n\t\t\t)\n\n\t\tthis.applyMacro(localHook)\n\t\tconst hooks = compressHistoryHook(mergeHook(this.event, localHook))\n\n\t\tif (this.config.aot === false) {\n\t\t\tthis.router.dynamic.add(method, path, {\n\t\t\t\tvalidator,\n\t\t\t\thooks,\n\t\t\t\tcontent: localHook?.type as string,\n\t\t\t\thandle,\n\t\t\t\troute: path\n\t\t\t})\n\n\t\t\tconst encoded = encodePath(path, { dynamic: true })\n\t\t\tif (path !== encoded) {\n\t\t\t\tthis.router.dynamic.add(method, encoded, {\n\t\t\t\t\tvalidator,\n\t\t\t\t\thooks,\n\t\t\t\t\tcontent: localHook?.type as string,\n\t\t\t\t\thandle,\n\t\t\t\t\troute: path\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif (this.config.strictPath === false) {\n\t\t\t\tconst loosePath = getLoosePath(path)\n\t\t\t\tthis.router.dynamic.add(method, loosePath, {\n\t\t\t\t\tvalidator,\n\t\t\t\t\thooks,\n\t\t\t\t\tcontent: localHook?.type as string,\n\t\t\t\t\thandle,\n\t\t\t\t\troute: path\n\t\t\t\t})\n\n\t\t\t\tconst encoded = encodePath(loosePath)\n\t\t\t\tif (loosePath !== encoded)\n\t\t\t\t\tthis.router.dynamic.add(method, loosePath, {\n\t\t\t\t\t\tvalidator,\n\t\t\t\t\t\thooks,\n\t\t\t\t\t\tcontent: localHook?.type as string,\n\t\t\t\t\t\thandle,\n\t\t\t\t\t\troute: path\n\t\t\t\t\t})\n\t\t\t}\n\n\t\t\tthis.router.history.push({\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t\tcomposed: null,\n\t\t\t\thandler: handle,\n\t\t\t\thooks\n\t\t\t})\n\n\t\t\treturn\n\t\t}\n\n\t\tconst shouldPrecompile =\n\t\t\tthis.config.precompile === true ||\n\t\t\t(typeof this.config.precompile === 'object' &&\n\t\t\t\tthis.config.precompile.compose === true)\n\n\t\tconst inference = cloneInference(this.inference)\n\n\t\tconst adapter = this['~adapter'].handler\n\n\t\tconst staticHandler =\n\t\t\ttypeof handle !== 'function' &&\n\t\t\ttypeof adapter.createStaticHandler === 'function'\n\t\t\t\t? adapter.createStaticHandler(handle, hooks, this.setHeaders)\n\t\t\t\t: undefined\n\n\t\tconst nativeStaticHandler =\n\t\t\ttypeof handle !== 'function'\n\t\t\t\t? adapter.createNativeStaticHandler?.(\n\t\t\t\t\t\thandle,\n\t\t\t\t\t\thooks,\n\t\t\t\t\t\tthis.setHeaders\n\t\t\t\t\t)\n\t\t\t\t: undefined\n\n\t\tif (\n\t\t\tthis.config.nativeStaticResponse === true &&\n\t\t\tnativeStaticHandler &&\n\t\t\t(method === 'GET' || method === 'ALL')\n\t\t)\n\t\t\tthis.router.static.http.static[path] = nativeStaticHandler()\n\n\t\tlet compile: ((asManifest?: boolean) => ComposedHandler) | undefined = (\n\t\t\tasManifest = false\n\t\t) =>\n\t\t\tcomposeHandler({\n\t\t\t\tapp: this,\n\t\t\t\tpath,\n\t\t\t\tmethod,\n\t\t\t\thooks,\n\t\t\t\tvalidator,\n\t\t\t\thandler:\n\t\t\t\t\ttypeof handle !== 'function' &&\n\t\t\t\t\ttypeof adapter.createStaticHandler !== 'function'\n\t\t\t\t\t\t? () => handle\n\t\t\t\t\t\t: handle,\n\t\t\t\tallowMeta,\n\t\t\t\tinference,\n\t\t\t\tasManifest\n\t\t\t})\n\n\t\tif (this.routeTree.has(method + path))\n\t\t\tfor (let i = 0; i < this.router.history.length; i++) {\n\t\t\t\tconst route = this.router.history[i]\n\t\t\t\tif (route.path === path && route.method === method) {\n\t\t\t\t\tconst removed = this.router.history.splice(i, 1)[0]\n\n\t\t\t\t\tif (\n\t\t\t\t\t\tremoved &&\n\t\t\t\t\t\tthis.routeTree.has(removed?.method + removed?.path)\n\t\t\t\t\t)\n\t\t\t\t\t\tthis.routeTree.delete(removed.method + removed.path)\n\t\t\t\t}\n\t\t\t}\n\t\telse this.routeTree.set(method + path, this.router.history.length)\n\n\t\tconst history = this.router.history\n\t\tconst index = this.router.history.length\n\n\t\tconst mainHandler = shouldPrecompile\n\t\t\t? compile()\n\t\t\t: (ctx: Context) => {\n\t\t\t\t\tconst temp = (\n\t\t\t\t\t\t(history[index].composed =\n\t\t\t\t\t\t\tcompile!()) as ComposedHandler\n\t\t\t\t\t)(ctx)\n\n\t\t\t\t\tcompile = undefined\n\n\t\t\t\t\treturn temp\n\t\t\t\t}\n\n\t\tif (shouldPrecompile) compile = undefined\n\n\t\tconst isWebSocket = method === '$INTERNALWS'\n\n\t\tthis.router.history.push(\n\t\t\t// @ts-ignore\n\t\t\tObject.assign(\n\t\t\t\t{\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath,\n\t\t\t\t\tcomposed: mainHandler,\n\t\t\t\t\thandler: handle,\n\t\t\t\t\thooks\n\t\t\t\t},\n\t\t\t\tlocalHook.webSocket\n\t\t\t\t\t? { websocket: localHook.websocket as any }\n\t\t\t\t\t: {}\n\t\t\t)\n\t\t)\n\n\t\tconst staticRouter = this.router.static.http\n\n\t\tconst handler = {\n\t\t\thandler: shouldPrecompile ? mainHandler : undefined,\n\t\t\tcompile() {\n\t\t\t\treturn (this.handler = compile!())\n\t\t\t}\n\t\t}\n\n\t\tif (isWebSocket) {\n\t\t\tthis.router.http.add('ws', path, handler)\n\n\t\t\tif (!this.config.strictPath)\n\t\t\t\tthis.router.http.add('ws', getLoosePath(path), handler)\n\n\t\t\tconst encoded = encodePath(path, { dynamic: true })\n\t\t\tif (encoded !== path) this.router.http.add('ws', encoded, handler)\n\n\t\t\treturn\n\t\t}\n\n\t\tif (path.indexOf(':') === -1 && path.indexOf('*') === -1) {\n\t\t\tif (!staticRouter.map[path])\n\t\t\t\tstaticRouter.map[path] = {\n\t\t\t\t\tcode: ''\n\t\t\t\t}\n\n\t\t\tconst ctx = staticHandler ? '' : 'c'\n\n\t\t\tif (method === 'ALL')\n\t\t\t\tstaticRouter.map[path].all =\n\t\t\t\t\t`default:return ht[${index}].composed(${ctx})\\n`\n\t\t\telse\n\t\t\t\tstaticRouter.map[path].code =\n\t\t\t\t\t`case '${method}':return ht[${index}].composed(${ctx})\\n${staticRouter.map[path].code}`\n\n\t\t\tif (\n\t\t\t\t!this.config.strictPath &&\n\t\t\t\tthis.config.nativeStaticResponse === true &&\n\t\t\t\tnativeStaticHandler &&\n\t\t\t\t(method === 'GET' || method === 'ALL')\n\t\t\t)\n\t\t\t\tthis.router.static.http.static[getLoosePath(path)] =\n\t\t\t\t\tnativeStaticHandler()\n\t\t} else {\n\t\t\t// Dynamic path, best not to JIT\n\t\t\tthis.router.http.add(method, path, handler)\n\n\t\t\tif (!this.config.strictPath) {\n\t\t\t\tconst loosePath = getLoosePath(path)\n\t\t\t\tif (\n\t\t\t\t\tthis.config.nativeStaticResponse === true &&\n\t\t\t\t\tstaticHandler &&\n\t\t\t\t\t(method === 'GET' || method === 'ALL')\n\t\t\t\t)\n\t\t\t\t\tthis.router.static.http.static[loosePath] =\n\t\t\t\t\t\tstaticHandler() as Response\n\n\t\t\t\tthis.router.http.add(method, loosePath, handler)\n\t\t\t}\n\n\t\t\tconst encoded = encodePath(path, { dynamic: true })\n\t\t\tif (path !== encoded) {\n\t\t\t\tthis.router.http.add(method, encoded, handler)\n\n\t\t\t\tif (\n\t\t\t\t\tthis.config.nativeStaticResponse === true &&\n\t\t\t\t\tstaticHandler &&\n\t\t\t\t\t(method === 'GET' || method === 'ALL')\n\t\t\t\t)\n\t\t\t\t\tthis.router.static.http.static[encoded] =\n\t\t\t\t\t\tstaticHandler() as Response\n\n\t\t\t\tthis.router.http.add(method, encoded, handler)\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate setHeaders?: Context['set']['headers']\n\theaders(header: Context['set']['headers'] | undefined) {\n\t\tif (!header) return this\n\n\t\tif (!this.setHeaders) this.setHeaders = {}\n\n\t\tthis.setHeaders = mergeDeep(this.setHeaders, header)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### start | Life cycle event\n\t * Called after server is ready for serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onStart(({ server }) => {\n\t *         console.log(\"Running at ${server?.url}:${server?.port}\")\n\t *     })\n\t *     .listen(3000)\n\t * ```\n\t */\n\tonStart(handler: MaybeArray<GracefulHandler<this>>) {\n\t\tthis.on('start', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### request | Life cycle event\n\t * Called on every new request is accepted\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onRequest(({ method, url }) => {\n\t *         saveToAnalytic({ method, url })\n\t *     })\n\t * ```\n\t */\n\tonRequest<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tPreHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: {}\n\t\t\t\t\tresolve: {}\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t) {\n\t\tthis.on('request', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### parse | Life cycle event\n\t * Callback function to handle body parsing\n\t *\n\t * If truthy value is returned, will be assigned to `context.body`\n\t * Otherwise will skip the callback and look for the next one.\n\t *\n\t * Equivalent to Express's body parser\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onParse((request, contentType) => {\n\t *         if(contentType === \"application/json\")\n\t *             return request.json()\n\t *     })\n\t * ```\n\t */\n\tonParse<const Schema extends RouteSchema>(\n\t\tparser: MaybeArray<\n\t\t\tBodyHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t>,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\tresolve: {}\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### parse | Life cycle event\n\t * Callback function to handle body parsing\n\t *\n\t * If truthy value is returned, will be assigned to `context.body`\n\t * Otherwise will skip the callback and look for the next one.\n\t *\n\t * Equivalent to Express's body parser\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onParse((request, contentType) => {\n\t *         if(contentType === \"application/json\")\n\t *             return request.json()\n\t *     })\n\t * ```\n\t */\n\tonParse<const Schema extends RouteSchema, const Type extends LifeCycleType>(\n\t\toptions: { as?: Type },\n\t\tparser: MaybeArray<\n\t\t\tBodyHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\t'global' extends Type\n\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: {},\n\t\t\t\t'global' extends Type\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\tPartial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t}\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\tonParse<const Parsers extends keyof Metadata['parser']>(\n\t\tparser: Parsers\n\t): this\n\n\tonParse(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function> | string,\n\t\thandler?: MaybeArray<Function>\n\t): unknown {\n\t\tif (!handler) {\n\t\t\tif (typeof options === 'string')\n\t\t\t\treturn this.on('parse', this['~parser'][options] as any)\n\n\t\t\treturn this.on('parse', options as any)\n\t\t}\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'parse',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### parse | Life cycle event\n\t * Callback function to handle body parsing\n\t *\n\t * If truthy value is returned, will be assigned to `context.body`\n\t * Otherwise will skip the callback and look for the next one.\n\t *\n\t * Equivalent to Express's body parser\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onParse((request, contentType) => {\n\t *         if(contentType === \"application/json\")\n\t *             return request.json()\n\t *     })\n\t * ```\n\t */\n\tparser<\n\t\tconst Parser extends string,\n\t\tconst Schema extends RouteSchema,\n\t\tconst Handler extends BodyHandler<\n\t\t\tMergeSchema<\n\t\t\t\tSchema,\n\t\t\t\tMergeSchema<\n\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t>,\n\t\t\t\tBasePath\n\t\t\t>,\n\t\t\t{\n\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\tstore: Singleton['store']\n\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\tVolatile['derive']\n\t\t\t\tresolve: {}\n\t\t\t}\n\t\t>\n\t>(\n\t\tname: Parser,\n\t\tparser: Handler\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\t{\n\t\t\tschema: Metadata['schema']\n\t\t\tmacro: Metadata['macro']\n\t\t\tmacroFn: Metadata['macroFn']\n\t\t\tparser: Metadata['parser'] & { [K in Parser]: Handler }\n\t\t},\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis['~parser'][name] = parser as any\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### transform | Life cycle event\n\t * Assign or transform anything related to context before validation.\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onTransform(({ params }) => {\n\t *         if(params.id)\n\t *             params.id = +params.id\n\t *     })\n\t * ```\n\t */\n\tonTransform<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tTransformHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t>,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\tresolve: {}\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### transform | Life cycle event\n\t * Assign or transform anything related to context before validation.\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onTransform(({ params }) => {\n\t *         if(params.id)\n\t *             params.id = +params.id\n\t *     })\n\t * ```\n\t */\n\tonTransform<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\thandler: MaybeArray<\n\t\t\tTransformHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\t'global' extends Type\n\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: {},\n\t\t\t\t'global' extends Type\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t}\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\t\tPartial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: {}\n\t\t\t\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\tonTransform(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('transform', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'transform',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tresolve<\n\t\tconst Resolver extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\tresolver: (\n\t\t\tcontext: Prettify<\n\t\t\t\tContext<\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>,\n\t\t\t\t\t\tBasePath\n\t\t\t\t\t> &\n\t\t\t\t\t\t'global' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t\t: {},\n\t\t\t\t\tSingleton &\n\t\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t>\n\t\t\t>\n\t\t) => MaybePromise<Resolver | void>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\tSingleton['resolve'] & ExcludeElysiaResponse<Resolver>\n\t\t\t\t\t>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Ephemeral['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<Resolver>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t},\n\t\t\t\t\tVolatile\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<Resolver>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t}\n\t\t\t\t>\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tresolve<\n\t\tconst Resolver extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>\n\t\t\t| void\n\t>(\n\t\tresolver: (\n\t\t\tcontext: Prettify<\n\t\t\t\tContext<\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>,\n\t\t\t\t\t\tBasePath\n\t\t\t\t\t>,\n\t\t\t\t\tSingleton & {\n\t\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t},\n\t\t\t\t\tBasePath\n\t\t\t\t>\n\t\t\t>\n\t\t) => MaybePromise<Resolver | void>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Volatile['derive']\n\t\t\tresolve: Prettify<\n\t\t\t\tVolatile['resolve'] & ExcludeElysiaResponse<Resolver>\n\t\t\t>\n\t\t\tschema: Volatile['schema']\n\t\t}\n\t>\n\n\tresolve(\n\t\toptionsOrResolve: { as?: LifeCycleType } | Function,\n\t\tresolve?: Function\n\t) {\n\t\tif (!resolve) {\n\t\t\tresolve = optionsOrResolve as any\n\t\t\toptionsOrResolve = { as: 'local' }\n\t\t}\n\n\t\tconst hook: HookContainer = {\n\t\t\tsubType: 'resolve',\n\t\t\tfn: resolve!\n\t\t}\n\n\t\treturn this.onBeforeHandle(optionsOrResolve as any, hook as any) as any\n\t}\n\n\tmapResolve<\n\t\tconst NewResolver extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>\n\t>(\n\t\tmapper: (\n\t\t\tcontext: Context<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tMetadata['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Volatile['schema']>\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t) => MaybePromise<NewResolver | void>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Volatile['derive']\n\t\t\tresolve: ExcludeElysiaResponse<NewResolver>\n\t\t\tschema: Volatile['schema']\n\t\t}\n\t>\n\n\tmapResolve<\n\t\tconst NewResolver extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\tmapper: (\n\t\t\tcontext: Context<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tMetadata['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Volatile['schema']>\n\t\t\t\t>,\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t) => MaybePromise<NewResolver | void>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\tresolve: ExcludeElysiaResponse<NewResolver>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Ephemeral['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<NewResolver>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t},\n\t\t\t\t\tVolatile\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<NewResolver>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t}\n\t\t\t\t>\n\n\tmapResolve(\n\t\toptionsOrResolve: Function | { as?: LifeCycleType },\n\t\tmapper?: Function\n\t) {\n\t\tif (!mapper) {\n\t\t\tmapper = optionsOrResolve as any\n\t\t\toptionsOrResolve = { as: 'local' }\n\t\t}\n\n\t\tconst hook: HookContainer = {\n\t\t\tsubType: 'mapResolve',\n\t\t\tfn: mapper!\n\t\t}\n\n\t\treturn this.onBeforeHandle(optionsOrResolve as any, hook as any) as any\n\t}\n\n\t/**\n\t * ### Before Handle | Life cycle event\n\t * Execute after validation and before the main route handler.\n\t *\n\t * If truthy value is returned, will be assigned as `Response` and skip the main handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onBeforeHandle(({ params: { id }, status }) => {\n\t *         if(id && !isExisted(id)) {\n\t * \t           status(401)\n\t *\n\t *             return \"Unauthorized\"\n\t * \t       }\n\t *     })\n\t * ```\n\t */\n\tonBeforeHandle<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tOptionalHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### Before Handle | Life cycle event\n\t * Execute after validation and before the main route handler.\n\t *\n\t * If truthy value is returned, will be assigned as `Response` and skip the main handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onBeforeHandle(({ params: { id }, status }) => {\n\t *         if(id && !isExisted(id)) {\n\t * \t           status(401)\n\t *\n\t *             return \"Unauthorized\"\n\t * \t       }\n\t *     })\n\t * ```\n\t */\n\tonBeforeHandle<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\thandler: MaybeArray<\n\t\t\tOptionalHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\t'global' extends Type\n\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: {},\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t}),\n\t\t\t\tBasePath\n\t\t\t>\n\t\t>\n\t): this\n\n\tonBeforeHandle(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('beforeHandle', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'beforeHandle',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tonAfterHandle<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tAfterHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tonAfterHandle<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: LifeCycleType },\n\t\thandler: MaybeArray<\n\t\t\tAfterHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\t'global' extends Type\n\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: {},\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t>\n\t): this\n\n\tonAfterHandle(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('afterHandle', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'afterHandle',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .mapResponse((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tmapResponse<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tMapResponse<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .mapResponse((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\tmapResponse<const Schema extends RouteSchema, Type extends LifeCycleType>(\n\t\toptions: { as?: Type },\n\t\thandler: MaybeArray<\n\t\t\tMapResponse<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\t'global' extends Type\n\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: {},\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t>\n\t): this\n\n\tmapResponse(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('mapResponse', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'mapResponse',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### response | Life cycle event\n\t * Call AFTER main handler is executed\n\t * Good for analytic metrics\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterResponse(() => {\n\t *         cleanup()\n\t *     })\n\t * ```\n\t */\n\tonAfterResponse<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tAfterResponseHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### response | Life cycle event\n\t * Call AFTER main handler is executed\n\t * Good for analytic metrics\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterResponse(() => {\n\t *         cleanup()\n\t * \t   })\n\t * ```\n\t */\n\n\tonAfterResponse<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\thandler: MaybeArray<\n\t\t\tAfterResponseHandler<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>,\n\t\t\t\t\tBasePath\n\t\t\t\t> &\n\t\t\t\t\t'global' extends Type\n\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: {},\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t})\n\t\t\t>\n\t\t>\n\t): this\n\n\tonAfterResponse(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('afterResponse', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'afterResponse',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\ttrace<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<TraceHandler<Schema, Singleton>>\n\t): this\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\ttrace<const Schema extends RouteSchema>(\n\t\toptions: { as?: LifeCycleType },\n\t\thandler: MaybeArray<TraceHandler<Schema, Singleton>>\n\t): this\n\n\t/**\n\t * ### After Handle | Life cycle event\n\t * Intercept request **after** main handler is called.\n\t *\n\t * If truthy value is returned, will be assigned as `Response`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onAfterHandle((context, response) => {\n\t *         if(typeof response === \"object\")\n\t *             return JSON.stringify(response)\n\t *     })\n\t * ```\n\t */\n\ttrace(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) {\n\t\t\thandler = options as MaybeArray<Function>\n\t\t\toptions = { as: 'local' }\n\t\t}\n\n\t\tif (!Array.isArray(handler)) handler = [handler] as Function[]\n\n\t\tfor (const fn of handler)\n\t\t\tthis.on(\n\t\t\t\toptions as { as?: LifeCycleType },\n\t\t\t\t'trace',\n\t\t\t\tcreateTracer(fn as any) as any\n\t\t\t)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error('CUSTOM_ERROR', CustomError)\n\t * ```\n\t */\n\terror<\n\t\tconst Errors extends Record<\n\t\t\tstring,\n\t\t\t{\n\t\t\t\tprototype: Error\n\t\t\t}\n\t\t>\n\t>(\n\t\terrors: Errors\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\t{\n\t\t\ttypebox: Definitions['typebox']\n\t\t\terror: Definitions['error'] & {\n\t\t\t\t[K in keyof Errors]: Errors[K] extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: Errors[K]\n\t\t\t}\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error({\n\t *         CUSTOM_ERROR: CustomError\n\t *     })\n\t * ```\n\t */\n\terror<\n\t\tName extends string,\n\t\tconst CustomError extends {\n\t\t\tprototype: Error\n\t\t}\n\t>(\n\t\tname: Name,\n\t\terrors: CustomError\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\t{\n\t\t\ttypebox: Definitions['typebox']\n\t\t\terror: Definitions['error'] & {\n\t\t\t\t[name in Name]: CustomError extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: CustomError\n\t\t\t}\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * Register errors\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * class CustomError extends Error {\n\t *     constructor() {\n\t *         super()\n\t *     }\n\t * }\n\t *\n\t * new Elysia()\n\t *     .error('CUSTOM_ERROR', CustomError)\n\t * ```\n\t */\n\terror<const NewErrors extends Record<string, Error>>(\n\t\tmapper: (decorators: Definitions['error']) => NewErrors\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\t{\n\t\t\ttypebox: Definitions['typebox']\n\t\t\terror: {\n\t\t\t\t[K in keyof NewErrors]: NewErrors[K] extends {\n\t\t\t\t\tprototype: infer LiteralError extends Error\n\t\t\t\t}\n\t\t\t\t\t? LiteralError\n\t\t\t\t\t: never\n\t\t\t}\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\terror(\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\tname:\n\t\t\t| string\n\t\t\t| Record<\n\t\t\t\t\tstring,\n\t\t\t\t\t{\n\t\t\t\t\t\tprototype: Error\n\t\t\t\t\t}\n\t\t\t  >\n\t\t\t| Function,\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\terror?: {\n\t\t\tprototype: Error\n\t\t}\n\t): AnyElysia {\n\t\tswitch (typeof name) {\n\t\t\tcase 'string':\n\t\t\t\t// @ts-ignore\n\t\t\t\terror.prototype[ERROR_CODE] = name\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tthis.definitions.error[name] = error\n\n\t\t\t\treturn this\n\n\t\t\tcase 'function':\n\t\t\t\tthis.definitions.error = name(this.definitions.error)\n\n\t\t\t\treturn this as any\n\t\t}\n\n\t\tfor (const [code, error] of Object.entries(name)) {\n\t\t\t// @ts-ignore\n\t\t\terror.prototype[ERROR_CODE] = code as any\n\n\t\t\tthis.definitions.error[code] = error as any\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### Error | Life cycle event\n\t * Called when error is thrown during processing request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\tonError<const Schema extends RouteSchema>(\n\t\thandler: MaybeArray<\n\t\t\tErrorHandler<\n\t\t\t\tDefinitions['error'],\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\tSingleton,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### Error | Life cycle event\n\t * Called when error is thrown during processing request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\tonError<\n\t\tconst Schema extends RouteSchema,\n\t\tconst Scope extends LifeCycleType\n\t>(\n\t\toptions: { as?: Scope },\n\t\thandler: MaybeArray<\n\t\t\tErrorHandler<\n\t\t\t\tDefinitions['error'],\n\t\t\t\tMergeSchema<\n\t\t\t\t\tSchema,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>,\n\t\t\t\tScope extends 'global'\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\tresolve: Singleton['resolve'] &\n\t\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t}\n\t\t\t\t\t: Scope extends 'scoped'\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\t\t\t\tderive: Singleton['derive'] &\n\t\t\t\t\t\t\t\t\tEphemeral['derive']\n\t\t\t\t\t\t\t\tresolve: Singleton['resolve'] &\n\t\t\t\t\t\t\t\t\tEphemeral['resolve']\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: Singleton,\n\t\t\t\tScope extends 'global'\n\t\t\t\t\t? Ephemeral\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tderive: Partial<Ephemeral['derive']>\n\t\t\t\t\t\t\tresolve: Partial<Ephemeral['resolve']>\n\t\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t\t},\n\t\t\t\tScope extends 'global'\n\t\t\t\t\t? Ephemeral\n\t\t\t\t\t: Scope extends 'scoped'\n\t\t\t\t\t\t? Ephemeral\n\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\tderive: Partial<Ephemeral['derive']>\n\t\t\t\t\t\t\t\tresolve: Partial<Ephemeral['resolve']>\n\t\t\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t\t\t}\n\t\t\t>\n\t\t>\n\t): this\n\n\t/**\n\t * ### Error | Life cycle event\n\t * Called when error is thrown during processing request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onError(({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\tonError(\n\t\toptions: { as?: LifeCycleType } | MaybeArray<Function>,\n\t\thandler?: MaybeArray<Function>\n\t) {\n\t\tif (!handler) return this.on('error', options as any)\n\n\t\treturn this.on(\n\t\t\toptions as { as?: LifeCycleType },\n\t\t\t'error',\n\t\t\thandler as any\n\t\t)\n\t}\n\n\t/**\n\t * ### stop | Life cycle event\n\t * Called after server stop serving request\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .onStop((app) => {\n\t *         cleanup()\n\t *     })\n\t * ```\n\t */\n\tonStop(handler: MaybeArray<GracefulHandler<this>>) {\n\t\tthis.on('stop', handler as any)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### on\n\t * Syntax sugar for attaching life cycle event by name\n\t *\n\t * Does the exact same thing as `.on[Event]()`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .on('error', ({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\ton<Event extends keyof LifeCycleStore>(\n\t\ttype: Event,\n\t\thandlers: MaybeArray<\n\t\t\tExtract<LifeCycleStore[Event], HookContainer[]>[0]['fn']\n\t\t>\n\t): this\n\n\t/**\n\t * ### on\n\t * Syntax sugar for attaching life cycle event by name\n\t *\n\t * Does the exact same thing as `.on[Event]()`\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .on('error', ({ code }) => {\n\t *         if(code === \"NOT_FOUND\")\n\t *             return \"Path not found :(\"\n\t *     })\n\t * ```\n\t */\n\ton<const Event extends keyof LifeCycleStore>(\n\t\toptions: { as?: LifeCycleType },\n\t\ttype: Event,\n\t\thandlers: MaybeArray<Extract<LifeCycleStore[Event], Function[]>[0]>\n\t): this\n\n\ton(\n\t\toptionsOrType: { as?: LifeCycleType } | string,\n\t\ttypeOrHandlers: MaybeArray<Function | HookContainer> | string,\n\t\thandlers?: MaybeArray<Function | HookContainer>\n\t) {\n\t\tlet type: keyof LifeCycleStore\n\n\t\tswitch (typeof optionsOrType) {\n\t\t\tcase 'string':\n\t\t\t\ttype = optionsOrType as any\n\t\t\t\thandlers = typeOrHandlers as any\n\n\t\t\t\tbreak\n\n\t\t\tcase 'object':\n\t\t\t\ttype = typeOrHandlers as any\n\n\t\t\t\tif (\n\t\t\t\t\t!Array.isArray(typeOrHandlers) &&\n\t\t\t\t\ttypeof typeOrHandlers === 'object'\n\t\t\t\t)\n\t\t\t\t\thandlers = typeOrHandlers\n\n\t\t\t\tbreak\n\t\t}\n\n\t\tif (Array.isArray(handlers)) handlers = fnToContainer(handlers)\n\t\telse {\n\t\t\tif (typeof handlers === 'function')\n\t\t\t\thandlers = [\n\t\t\t\t\t{\n\t\t\t\t\t\tfn: handlers\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\telse handlers = [handlers!]\n\t\t}\n\n\t\tconst handles = handlers as HookContainer[]\n\n\t\tfor (const handle of handles) {\n\t\t\thandle.scope =\n\t\t\t\ttypeof optionsOrType === 'string'\n\t\t\t\t\t? 'local'\n\t\t\t\t\t: (optionsOrType?.as ?? 'local')\n\n\t\t\t// @ts-expect-error\n\t\t\tif (type === 'resolve' || type === 'derive') handle.subType = type\n\t\t}\n\n\t\tif (type !== 'trace')\n\t\t\tsucrose(\n\t\t\t\t{\n\t\t\t\t\t[type]: handles.map((x) => x.fn)\n\t\t\t\t},\n\t\t\t\tthis.inference\n\t\t\t)\n\n\t\tfor (const handle of handles) {\n\t\t\tconst fn = asHookType(handle, 'global', { skipIfHasType: true })\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'start':\n\t\t\t\t\tthis.event.start ??= []\n\t\t\t\t\tthis.event.start.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'request':\n\t\t\t\t\tthis.event.request ??= []\n\t\t\t\t\tthis.event.request.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'parse':\n\t\t\t\t\tthis.event.parse ??= []\n\t\t\t\t\tthis.event.parse.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'transform':\n\t\t\t\t\tthis.event.transform ??= []\n\t\t\t\t\tthis.event.transform.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tcase 'derive':\n\t\t\t\t\tthis.event.transform ??= []\n\t\t\t\t\tthis.event.transform.push(\n\t\t\t\t\t\tfnToContainer(fn as any, 'derive') as any\n\t\t\t\t\t)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'beforeHandle':\n\t\t\t\t\tthis.event.beforeHandle ??= []\n\t\t\t\t\tthis.event.beforeHandle.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\t// eslint-disable-next-line sonarjs/no-duplicated-branches\n\t\t\t\tcase 'resolve':\n\t\t\t\t\tthis.event.beforeHandle ??= []\n\t\t\t\t\tthis.event.beforeHandle.push(\n\t\t\t\t\t\tfnToContainer(fn as any, 'resolve') as any\n\t\t\t\t\t)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'afterHandle':\n\t\t\t\t\tthis.event.afterHandle ??= []\n\t\t\t\t\tthis.event.afterHandle.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'mapResponse':\n\t\t\t\t\tthis.event.mapResponse ??= []\n\t\t\t\t\tthis.event.mapResponse.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'afterResponse':\n\t\t\t\t\tthis.event.afterResponse ??= []\n\t\t\t\t\tthis.event.afterResponse.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'trace':\n\t\t\t\t\tthis.event.trace ??= []\n\t\t\t\t\tthis.event.trace.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'error':\n\t\t\t\t\tthis.event.error ??= []\n\t\t\t\t\tthis.event.error.push(fn as any)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'stop':\n\t\t\t\t\tthis.event.stop ??= []\n\t\t\t\t\tthis.event.stop.push(fn as any)\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\treturn this\n\t}\n\n\t/**\n\t * @deprecated use `Elysia.as` instead\n\t *\n\t * Will be removed in Elysia 1.2\n\t */\n\tpropagate(): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tPrettify2<Ephemeral & Volatile>,\n\t\t{\n\t\t\tderive: {}\n\t\t\tresolve: {}\n\t\t\tschema: {}\n\t\t}\n\t> {\n\t\tpromoteEvent(this.event.parse)\n\t\tpromoteEvent(this.event.transform)\n\t\tpromoteEvent(this.event.beforeHandle)\n\t\tpromoteEvent(this.event.afterHandle)\n\t\tpromoteEvent(this.event.mapResponse)\n\t\tpromoteEvent(this.event.afterResponse)\n\t\tpromoteEvent(this.event.trace)\n\t\tpromoteEvent(this.event.error)\n\n\t\treturn this as any\n\t}\n\n\tas(type: 'global'): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Prettify<\n\t\t\t\tSingleton['derive'] & Ephemeral['derive'] & Volatile['derive']\n\t\t\t>\n\t\t\tresolve: Prettify<\n\t\t\t\tSingleton['resolve'] &\n\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve']\n\t\t\t>\n\t\t},\n\t\tDefinitions,\n\t\t{\n\t\t\tschema: MergeSchema<\n\t\t\t\tMergeSchema<Volatile['schema'], Ephemeral['schema']>,\n\t\t\t\tMetadata['schema']\n\t\t\t>\n\t\t\tmacro: Metadata['macro']\n\t\t\tmacroFn: Metadata['macroFn']\n\t\t\tparser: Metadata['parser']\n\t\t},\n\t\tRoutes,\n\t\t{\n\t\t\tderive: {}\n\t\t\tresolve: {}\n\t\t\tschema: {}\n\t\t},\n\t\t{\n\t\t\tderive: {}\n\t\t\tresolve: {}\n\t\t\tschema: {}\n\t\t}\n\t>\n\n\tas(type: 'plugin' | 'scoped'): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\t{\n\t\t\tderive: Prettify<Ephemeral['derive'] & Volatile['derive']>\n\t\t\tresolve: Prettify<Ephemeral['resolve'] & Volatile['resolve']>\n\t\t\tschema: MergeSchema<Volatile['schema'], Ephemeral['schema']>\n\t\t},\n\t\t{\n\t\t\tderive: {}\n\t\t\tresolve: {}\n\t\t\tschema: {}\n\t\t}\n\t>\n\n\tas(type: 'plugin' | 'global' | 'scoped') {\n\t\tconst castType = (\n\t\t\t{ plugin: 'scoped', scoped: 'scoped', global: 'global' } as const\n\t\t)[type]\n\n\t\tpromoteEvent(this.event.parse, castType)\n\t\tpromoteEvent(this.event.transform, castType)\n\t\tpromoteEvent(this.event.beforeHandle, castType)\n\t\tpromoteEvent(this.event.afterHandle, castType)\n\t\tpromoteEvent(this.event.mapResponse, castType)\n\t\tpromoteEvent(this.event.afterResponse, castType)\n\t\tpromoteEvent(this.event.trace, castType)\n\t\tpromoteEvent(this.event.error, castType)\n\n\t\tif (type === 'plugin') {\n\t\t\tthis.validator.scoped = mergeSchemaValidator(\n\t\t\t\tthis.validator.scoped,\n\t\t\t\tthis.validator.local\n\t\t\t)\n\t\t\tthis.validator.local = null\n\t\t} else if (type === 'global') {\n\t\t\tthis.validator.global = mergeSchemaValidator(\n\t\t\t\tthis.validator.global,\n\t\t\t\tmergeSchemaValidator(\n\t\t\t\t\tthis.validator.scoped,\n\t\t\t\t\tthis.validator.local\n\t\t\t\t) as SchemaValidator\n\t\t\t) as SchemaValidator\n\n\t\t\tthis.validator.scoped = null\n\t\t\tthis.validator.local = null\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\tgroup<const Prefix extends string, const NewElysia extends AnyElysia>(\n\t\tprefix: Prefix,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\tJoinPath<BasePath, Prefix>,\n\t\t\t\tSingleton,\n\t\t\t\tDefinitions,\n\t\t\t\t{\n\t\t\t\t\tschema: MergeSchema<\n\t\t\t\t\t\tUnwrapRoute<\n\t\t\t\t\t\t\t{},\n\t\t\t\t\t\t\tDefinitions['typebox'],\n\t\t\t\t\t\t\tJoinPath<BasePath, Prefix>\n\t\t\t\t\t\t>,\n\t\t\t\t\t\tMetadata['schema']\n\t\t\t\t\t>\n\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t\tparser: Metadata['parser']\n\t\t\t\t},\n\t\t\t\t{},\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tPrettify<Routes & NewElysia['_routes']>,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tgroup<\n\t\tconst Prefix extends string,\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Input extends InputSchema<\n\t\t\tkeyof UnwrapTypeModule<Definitions['typebox']> & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tInput,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Prefix>\n\t\t\t>,\n\t\t\tMetadata['schema']\n\t\t>,\n\t\tconst Resolutions extends MaybeArray<\n\t\t\tResolveHandler<\n\t\t\t\tSchema,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t}\n\t\t\t>\n\t\t>\n\t>(\n\t\tprefix: Prefix,\n\t\tschema: LocalHook<\n\t\t\tInput,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMetadata['macro'],\n\t\t\tkeyof Metadata['macro'],\n\t\t\tkeyof Metadata['parser'] & string\n\t\t>,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\tJoinPath<BasePath, Prefix>,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Prettify<\n\t\t\t\t\t\tSingleton['derive'] &\n\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t>\n\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\tSingleton['resolve'] &\n\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\t\t\tResolveResolutions<Resolutions>\n\t\t\t\t\t>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\t{\n\t\t\t\t\tschema: Prettify<Schema>\n\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t\tparser: Metadata['parser']\n\t\t\t\t},\n\t\t\t\t{},\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes & NewElysia['_routes'],\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### group\n\t * Encapsulate and group path with prefix\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .group('/v1', app => app\n\t *         .get('/', () => 'Hi')\n\t *         .get('/name', () => 'Elysia')\n\t *     })\n\t * ```\n\t */\n\tgroup(\n\t\tprefix: string,\n\t\tschemaOrRun: AnyLocalHook | ((group: AnyElysia) => AnyElysia),\n\t\trun?: (group: AnyElysia) => AnyElysia\n\t): AnyElysia {\n\t\tconst instance = new Elysia({\n\t\t\t...this.config,\n\t\t\tprefix: ''\n\t\t})\n\n\t\tinstance.singleton = { ...this.singleton }\n\t\tinstance.definitions = { ...this.definitions }\n\t\tinstance.getServer = () => this.getServer()\n\t\tinstance.inference = cloneInference(this.inference)\n\t\tinstance.extender = { ...this.extender }\n\n\t\tconst isSchema = typeof schemaOrRun === 'object'\n\t\tconst sandbox = (isSchema ? run! : schemaOrRun)(instance)\n\t\tthis.singleton = mergeDeep(this.singleton, instance.singleton) as any\n\t\tthis.definitions = mergeDeep(this.definitions, instance.definitions)\n\n\t\tif (sandbox.event.request?.length)\n\t\t\tthis.event.request = [\n\t\t\t\t...(this.event.request || []),\n\t\t\t\t...((sandbox.event.request || []) as any)\n\t\t\t]\n\n\t\tif (sandbox.event.mapResponse?.length)\n\t\t\tthis.event.mapResponse = [\n\t\t\t\t...(this.event.mapResponse || []),\n\t\t\t\t...((sandbox.event.mapResponse || []) as any)\n\t\t\t]\n\n\t\tthis.model(sandbox.definitions.type)\n\n\t\tObject.values(instance.router.history).forEach(\n\t\t\t({ method, path, handler, hooks }) => {\n\t\t\t\tpath = (isSchema ? '' : this.config.prefix) + prefix + path\n\n\t\t\t\tif (isSchema) {\n\t\t\t\t\tconst hook = schemaOrRun\n\t\t\t\t\tconst localHook = hooks as AnyLocalHook\n\n\t\t\t\t\tthis.add(\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\thandler,\n\t\t\t\t\t\tmergeHook(hook, {\n\t\t\t\t\t\t\t...(localHook || {}),\n\t\t\t\t\t\t\terror: !localHook.error\n\t\t\t\t\t\t\t\t? sandbox.event.error\n\t\t\t\t\t\t\t\t: Array.isArray(localHook.error)\n\t\t\t\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t\t\t\t...(localHook.error || {}),\n\t\t\t\t\t\t\t\t\t\t\t...(sandbox.event.error || {})\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t\t: [\n\t\t\t\t\t\t\t\t\t\t\tlocalHook.error,\n\t\t\t\t\t\t\t\t\t\t\t...(sandbox.event.error || {})\n\t\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t})\n\t\t\t\t\t)\n\t\t\t\t} else {\n\t\t\t\t\tthis.add(\n\t\t\t\t\t\tmethod,\n\t\t\t\t\t\tpath,\n\t\t\t\t\t\thandler,\n\t\t\t\t\t\tmergeHook(hooks as AnyLocalHook, {\n\t\t\t\t\t\t\terror: sandbox.event.error\n\t\t\t\t\t\t}),\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tskipPrefix: true\n\t\t\t\t\t\t}\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\n\t\treturn this as any\n\t}\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof UnwrapTypeModule<Definitions['typebox']> & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['typebox'], BasePath>,\n\t\t\tMetadata['schema']\n\t\t>,\n\t\tconst Type extends LifeCycleType,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst MacroContext extends MacroToContext<\n\t\t\tMetadata['macroFn'],\n\t\t\tNoInfer<Macro>\n\t\t>\n\t>(\n\t\thook: { as: Type } & LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['macro'] | 'as',\n\t\t\tkeyof Metadata['parser'] & string\n\t\t>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\tresolve: Prettify<Singleton['resolve'] & MacroContext>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\t{\n\t\t\t\t\tschema: Prettify<\n\t\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\t\tUnwrapRoute<\n\t\t\t\t\t\t\t\tLocalSchema,\n\t\t\t\t\t\t\t\tDefinitions['typebox'],\n\t\t\t\t\t\t\t\tBasePath\n\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\tMetadata['schema']\n\t\t\t\t\t\t>\n\t\t\t\t\t>\n\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t\tparser: Metadata['parser']\n\t\t\t\t},\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['derive']\n\t\t\t\t\t\tresolve: Prettify<Volatile['resolve'] & MacroContext>\n\t\t\t\t\t\tschema: Prettify<\n\t\t\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\t\t\tUnwrapRoute<\n\t\t\t\t\t\t\t\t\tLocalSchema,\n\t\t\t\t\t\t\t\t\tDefinitions['typebox']\n\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\tMetadata['schema'] & Ephemeral['schema']\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t>\n\t\t\t\t\t},\n\t\t\t\t\tEphemeral\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['derive']\n\t\t\t\t\t\tresolve: Prettify<Volatile['resolve'] & MacroContext>\n\t\t\t\t\t\tschema: Prettify<\n\t\t\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\t\t\tUnwrapRoute<\n\t\t\t\t\t\t\t\t\tLocalSchema,\n\t\t\t\t\t\t\t\t\tDefinitions['typebox']\n\t\t\t\t\t\t\t\t>,\n\t\t\t\t\t\t\t\tMetadata['schema'] &\n\t\t\t\t\t\t\t\t\tEphemeral['schema'] &\n\t\t\t\t\t\t\t\t\tVolatile['schema']\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t>\n\t\t\t\t\t}\n\t\t\t\t>\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof UnwrapTypeModule<Definitions['typebox']> & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['typebox'], BasePath>,\n\t\t\tMetadata['schema']\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst MacroContext extends MacroToContext<\n\t\t\tMetadata['macroFn'],\n\t\t\tNoInfer<Macro>\n\t\t>\n\t>(\n\t\thook: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroContext\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['macro'],\n\t\t\tkeyof Metadata['parser'] & string\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Volatile['derive']\n\t\t\tresolve: Prettify<Volatile['resolve'] & MacroContext>\n\t\t\tschema: Prettify<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tUnwrapRoute<LocalSchema, Definitions['typebox'], BasePath>,\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t\t\t>\n\t\t\t\t>\n\t\t\t>\n\t\t}\n\t>\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof UnwrapTypeModule<Definitions['typebox']> & string\n\t\t>,\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['typebox'], BasePath>,\n\t\t\tMetadata['schema']\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst MacroContext extends MacroToContext<\n\t\t\tMetadata['macroFn'],\n\t\t\tNoInfer<Macro>\n\t\t>\n\t>(\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\tresolve: Singleton['resolve'] & MacroContext\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\t{\n\t\t\t\t\tschema: Prettify<Schema>\n\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t\tparser: Metadata['parser']\n\t\t\t\t},\n\t\t\t\t{},\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tPrettify<Routes & NewElysia['_routes']>,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tguard<\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof UnwrapTypeModule<Definitions['typebox']> & string\n\t\t>,\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<LocalSchema, Definitions['typebox'], BasePath>,\n\t\t\tMetadata['schema']\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst MacroContext extends MacroToContext<\n\t\t\tMetadata['macroFn'],\n\t\t\tNoInfer<Macro>\n\t\t>\n\t>(\n\t\tschema: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['macro'],\n\t\t\tkeyof Metadata['parser'] & string\n\t\t>,\n\t\trun: (\n\t\t\tgroup: Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\tresolve: Prettify<Singleton['resolve'] & MacroContext>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\t{\n\t\t\t\t\tschema: Prettify<Schema>\n\t\t\t\t\tmacro: Metadata['macro']\n\t\t\t\t\tmacroFn: Metadata['macroFn']\n\t\t\t\t\tparser: Metadata['parser']\n\t\t\t\t},\n\t\t\t\t{},\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t) => NewElysia\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tPrettify<Routes & NewElysia['_routes']>,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Volatile['derive']\n\t\t\tresolve: Prettify<Volatile['resolve'] & MacroContext>\n\t\t\tschema: Volatile['schema']\n\t\t}\n\t>\n\n\t/**\n\t * ### guard\n\t * Encapsulate and pass hook into all child handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .guard({\n\t *          schema: {\n\t *              body: t.Object({\n\t *                  username: t.String(),\n\t *                  password: t.String()\n\t *              })\n\t *          }\n\t *     }, app => app\n\t *         .get(\"/\", () => 'Hi')\n\t *         .get(\"/name\", () => 'Elysia')\n\t *     })\n\t * ```\n\t */\n\tguard(\n\t\thook:\n\t\t\t| (AnyLocalHook & {\n\t\t\t\t\tas: LifeCycleType\n\t\t\t  })\n\t\t\t| ((group: AnyElysia) => AnyElysia),\n\t\trun?: (group: AnyElysia) => AnyElysia\n\t): AnyElysia {\n\t\tif (!run) {\n\t\t\tif (typeof hook === 'object') {\n\t\t\t\tthis.applyMacro(hook)\n\t\t\t\t// this.event = mergeLifeCycle(this.event, hook)\n\n\t\t\t\tconst type: LifeCycleType = hook.as ?? 'local'\n\n\t\t\t\tthis.validator[type] = {\n\t\t\t\t\tbody: hook.body ?? this.validator[type]?.body,\n\t\t\t\t\theaders: hook.headers ?? this.validator[type]?.headers,\n\t\t\t\t\tparams: hook.params ?? this.validator[type]?.params,\n\t\t\t\t\tquery: hook.query ?? this.validator[type]?.query,\n\t\t\t\t\tresponse: hook.response ?? this.validator[type]?.response,\n\t\t\t\t\tcookie: hook.cookie ?? this.validator[type]?.cookie\n\t\t\t\t}\n\n\t\t\t\tif (hook.parse) this.on({ as: type }, 'parse', hook.parse)\n\t\t\t\tif (hook.transform)\n\t\t\t\t\tthis.on({ as: type }, 'transform', hook.transform)\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (hook.derive) this.on({ as: type }, 'derive', hook.derive)\n\t\t\t\tif (hook.beforeHandle)\n\t\t\t\t\tthis.on({ as: type }, 'beforeHandle', hook.beforeHandle)\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (hook.resolve) this.on({ as: type }, 'resolve', hook.resolve)\n\t\t\t\tif (hook.afterHandle)\n\t\t\t\t\tthis.on({ as: type }, 'afterHandle', hook.afterHandle)\n\t\t\t\tif (hook.mapResponse)\n\t\t\t\t\tthis.on({ as: type }, 'mapResponse', hook.mapResponse)\n\t\t\t\tif (hook.afterResponse)\n\t\t\t\t\tthis.on({ as: type }, 'afterResponse', hook.afterResponse)\n\t\t\t\tif (hook.error) this.on({ as: type }, 'error', hook.error)\n\n\t\t\t\tif (hook.detail) {\n\t\t\t\t\tif (this.config.detail)\n\t\t\t\t\t\tthis.config.detail = mergeDeep(\n\t\t\t\t\t\t\tObject.assign({}, this.config.detail),\n\t\t\t\t\t\t\thook.detail\n\t\t\t\t\t\t)\n\t\t\t\t\telse this.config.detail = hook.detail\n\t\t\t\t}\n\n\t\t\t\tif (hook?.tags) {\n\t\t\t\t\tif (!this.config.detail)\n\t\t\t\t\t\tthis.config.detail = {\n\t\t\t\t\t\t\ttags: hook.tags\n\t\t\t\t\t\t}\n\t\t\t\t\telse this.config.detail.tags = hook.tags\n\t\t\t\t}\n\n\t\t\t\treturn this\n\t\t\t}\n\n\t\t\treturn this.guard({} as any, hook)\n\t\t}\n\n\t\tconst instance = new Elysia({\n\t\t\t...this.config,\n\t\t\tprefix: ''\n\t\t})\n\t\tinstance.singleton = { ...this.singleton }\n\t\tinstance.definitions = { ...this.definitions }\n\t\tinstance.inference = cloneInference(this.inference)\n\t\tinstance.extender = { ...this.extender }\n\n\t\tconst sandbox = run(instance)\n\t\tthis.singleton = mergeDeep(this.singleton, instance.singleton) as any\n\t\tthis.definitions = mergeDeep(this.definitions, instance.definitions)\n\n\t\t// ? Inject getServer for websocket and trace (important, do not remove)\n\t\tsandbox.getServer = () => this.server\n\n\t\tif (sandbox.event.request?.length)\n\t\t\tthis.event.request = [\n\t\t\t\t...(this.event.request || []),\n\t\t\t\t...(sandbox.event.request || [])\n\t\t\t]\n\n\t\tif (sandbox.event.mapResponse?.length)\n\t\t\tthis.event.mapResponse = [\n\t\t\t\t...(this.event.mapResponse || []),\n\t\t\t\t...(sandbox.event.mapResponse || [])\n\t\t\t]\n\n\t\tthis.model(sandbox.definitions.type)\n\n\t\tObject.values(instance.router.history).forEach(\n\t\t\t({ method, path, handler, hooks: localHook }) => {\n\t\t\t\tthis.add(\n\t\t\t\t\tmethod,\n\t\t\t\t\tpath,\n\t\t\t\t\thandler,\n\t\t\t\t\tmergeHook(hook as AnyLocalHook, {\n\t\t\t\t\t\t...((localHook || {}) as AnyLocalHook),\n\t\t\t\t\t\terror: !localHook.error\n\t\t\t\t\t\t\t? sandbox.event.error\n\t\t\t\t\t\t\t: Array.isArray(localHook.error)\n\t\t\t\t\t\t\t\t? [\n\t\t\t\t\t\t\t\t\t\t...(localHook.error || {}),\n\t\t\t\t\t\t\t\t\t\t...(sandbox.event.error || [])\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t: [\n\t\t\t\t\t\t\t\t\t\tlocalHook.error,\n\t\t\t\t\t\t\t\t\t\t...(sandbox.event.error || [])\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t}\n\t\t)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * Inline fn\n\t */\n\tuse<\n\t\tconst NewElysia extends AnyElysia,\n\t\tconst Param extends AnyElysia = this\n\t>(\n\t\tplugin: MaybePromise<(app: Param) => MaybePromise<NewElysia>>\n\t): Elysia<\n\t\tBasePath,\n\t\t// @ts-expect-error - This is truly ideal\n\t\tPrettify2<Singleton & NewElysia['_types']['Singleton']>,\n\t\t{\n\t\t\terror: Prettify<\n\t\t\t\tDefinitions['error'] &\n\t\t\t\t\tNewElysia['_types']['Definitions']['error']\n\t\t\t>\n\t\t\ttypebox: MergeTypeModule<\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tNewElysia['_types']['Definitions']['typebox']\n\t\t\t>\n\t\t},\n\t\tPrettify2<Metadata & NewElysia['_types']['Metadata']>,\n\t\tBasePath extends ``\n\t\t\t? Routes & NewElysia['_routes']\n\t\t\t: Routes & CreateEden<BasePath, NewElysia['_routes']>,\n\t\tPrettify2<Ephemeral & NewElysia['_ephemeral']>,\n\t\tPrettify2<Volatile & NewElysia['_volatile']>\n\t>\n\n\t/**\n\t * Entire Instance\n\t **/\n\tuse<const NewElysia extends AnyElysia>(\n\t\tinstance: MaybePromise<NewElysia>\n\t): Elysia<\n\t\tBasePath,\n\t\t// @ts-expect-error - This is truly ideal\n\t\tPrettify2<Singleton & NewElysia['_types']['Singleton']>,\n\t\t{\n\t\t\terror: Prettify<\n\t\t\t\tDefinitions['error'] &\n\t\t\t\t\tNewElysia['_types']['Definitions']['error']\n\t\t\t>\n\t\t\ttypebox: MergeTypeModule<\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tNewElysia['_types']['Definitions']['typebox']\n\t\t\t>\n\t\t},\n\t\tPrettify2<Metadata & NewElysia['_types']['Metadata']>,\n\t\tBasePath extends ``\n\t\t\t? Routes & NewElysia['_routes']\n\t\t\t: Routes & CreateEden<BasePath, NewElysia['_routes']>,\n\t\tEphemeral,\n\t\tPrettify2<Volatile & NewElysia['_ephemeral']>\n\t>\n\n\t/**\n\t * Entire multiple Instance\n\t **/\n\tuse<const Instances extends AnyElysia[]>(\n\t\tinstance: MaybePromise<Instances>\n\t): MergeElysiaInstances<Instances>\n\n\t/**\n\t * Import fn\n\t */\n\tuse<const NewElysia extends AnyElysia>(\n\t\tplugin: Promise<{\n\t\t\tdefault: (elysia: AnyElysia) => MaybePromise<NewElysia>\n\t\t}>\n\t): Elysia<\n\t\tBasePath,\n\t\t// @ts-expect-error - This is truly ideal\n\t\tPrettify2<Singleton & NewElysia['_types']['Singleton']>,\n\t\t{\n\t\t\terror: Prettify<\n\t\t\t\tDefinitions['error'] &\n\t\t\t\t\tNewElysia['_types']['Definitions']['error']\n\t\t\t>\n\t\t\ttypebox: MergeTypeModule<\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tNewElysia['_types']['Definitions']['typebox']\n\t\t\t>\n\t\t},\n\t\tPrettify2<Metadata & NewElysia['_types']['Metadata']>,\n\t\tBasePath extends ``\n\t\t\t? Routes & NewElysia['_routes']\n\t\t\t: Routes & CreateEden<BasePath, NewElysia['_routes']>,\n\t\tPrettify2<Ephemeral & NewElysia['_ephemeral']>,\n\t\tPrettify2<Volatile & NewElysia['_volatile']>\n\t>\n\n\t/**\n\t * Import entire instance\n\t */\n\tuse<const LazyLoadElysia extends AnyElysia>(\n\t\tplugin: Promise<{\n\t\t\tdefault: LazyLoadElysia\n\t\t}>\n\t): Elysia<\n\t\tBasePath,\n\t\t// @ts-expect-error - This is truly ideal\n\t\tPrettify2<Singleton & LazyLoadElysia['_types']['Singleton']>,\n\t\t{\n\t\t\terror: Prettify<\n\t\t\t\tDefinitions['error'] &\n\t\t\t\t\tLazyLoadElysia['_types']['Definitions']['error']\n\t\t\t>\n\t\t\ttypebox: MergeTypeModule<\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tLazyLoadElysia['_types']['Definitions']['typebox']\n\t\t\t>\n\t\t},\n\t\tPrettify2<Metadata & LazyLoadElysia['_types']['Metadata']>,\n\t\tBasePath extends ``\n\t\t\t? Routes & LazyLoadElysia['_routes']\n\t\t\t: Routes & CreateEden<BasePath, LazyLoadElysia['_routes']>,\n\t\tEphemeral,\n\t\tPrettify2<Volatile & LazyLoadElysia['_ephemeral']>\n\t>\n\n\t/**\n\t * ### use\n\t * Merge separate logic of Elysia with current\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * const plugin = (app: Elysia) => app\n\t *     .get('/plugin', () => 'hi')\n\t *\n\t * new Elysia()\n\t *     .use(plugin)\n\t * ```\n\t */\n\tuse(\n\t\tplugin:\n\t\t\t| MaybeArray<MaybePromise<AnyElysia>>\n\t\t\t| MaybePromise<\n\t\t\t\t\tAnyElysia | ((app: AnyElysia) => MaybePromise<AnyElysia>)\n\t\t\t  >\n\t\t\t| Promise<{\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t| AnyElysia\n\t\t\t\t\t\t| ((app: AnyElysia) => MaybePromise<AnyElysia>)\n\t\t\t  }>,\n\t\toptions?: { scoped?: boolean }\n\t): AnyElysia {\n\t\tif (Array.isArray(plugin)) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\n\t\t\tlet app = this\n\t\t\tfor (const p of plugin) app = app.use(p) as any\n\t\t\treturn app\n\t\t}\n\n\t\tif (options?.scoped)\n\t\t\treturn this.guard({}, (app) => app.use(plugin as any))\n\n\t\tif (Array.isArray(plugin)) {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\n\t\t\tlet current = this\n\n\t\t\tfor (const p of plugin) current = this.use(p) as any\n\n\t\t\treturn current\n\t\t}\n\n\t\tif (plugin instanceof Promise) {\n\t\t\tthis.promisedModules.add(\n\t\t\t\tplugin.then((plugin) => {\n\t\t\t\t\tif (typeof plugin === 'function') return plugin(this)\n\n\t\t\t\t\tif (plugin instanceof Elysia)\n\t\t\t\t\t\treturn this._use(plugin).compile()\n\n\t\t\t\t\tif (plugin.constructor.name === 'Elysia')\n\t\t\t\t\t\treturn this._use(plugin as unknown as Elysia).compile()\n\n\t\t\t\t\tif (typeof plugin.default === 'function')\n\t\t\t\t\t\treturn plugin.default(this)\n\n\t\t\t\t\tif (plugin.default instanceof Elysia)\n\t\t\t\t\t\treturn this._use(plugin.default)\n\n\t\t\t\t\tif (plugin.constructor.name === 'Elysia')\n\t\t\t\t\t\treturn this._use(plugin.default)\n\n\t\t\t\t\tif (plugin.constructor.name === '_Elysia')\n\t\t\t\t\t\treturn this._use(plugin.default)\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn this._use(plugin.default)\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t\t'Invalid plugin type. Expected Elysia instance, function, or module with \"default\" as Elysia instance or function that returns Elysia instance.'\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tthrow error\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t)\n\n\t\t\treturn this\n\t\t}\n\n\t\treturn this._use(plugin)\n\t}\n\n\tprivate propagatePromiseModules(plugin: Elysia) {\n\t\tif (plugin.promisedModules.size <= 0) return this\n\n\t\tfor (const promise of plugin.promisedModules.promises)\n\t\t\tthis.promisedModules.add(\n\t\t\t\tpromise.then((value) => {\n\t\t\t\t\tif (value) return this._use(value)\n\t\t\t\t})\n\t\t\t)\n\n\t\treturn this\n\t}\n\n\tprivate _use(\n\t\tplugin: AnyElysia | ((app: AnyElysia) => MaybePromise<AnyElysia>)\n\t) {\n\t\tif (typeof plugin === 'function') {\n\t\t\tconst instance = plugin(this as unknown as any) as unknown as any\n\n\t\t\tif (instance instanceof Promise) {\n\t\t\t\tthis.promisedModules.add(\n\t\t\t\t\tinstance\n\t\t\t\t\t\t.then((plugin) => {\n\t\t\t\t\t\t\tif (plugin instanceof Elysia) {\n\t\t\t\t\t\t\t\tplugin.getServer = () => this.getServer()\n\t\t\t\t\t\t\t\tplugin.getGlobalRoutes = () =>\n\t\t\t\t\t\t\t\t\tthis.getGlobalRoutes()\n\n\t\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t\t * Model and error is required for Swagger generation\n\t\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\t\tplugin.model(this.definitions.type as any)\n\t\t\t\t\t\t\t\tplugin.error(this.definitions.error as any)\n\n\t\t\t\t\t\t\t\t// Recompile async plugin routes\n\t\t\t\t\t\t\t\tfor (const {\n\t\t\t\t\t\t\t\t\tmethod,\n\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\thandler,\n\t\t\t\t\t\t\t\t\thooks\n\t\t\t\t\t\t\t\t} of Object.values(plugin.router.history))\n\t\t\t\t\t\t\t\t\tthis.add(\n\t\t\t\t\t\t\t\t\t\tmethod,\n\t\t\t\t\t\t\t\t\t\tpath,\n\t\t\t\t\t\t\t\t\t\thandler,\n\t\t\t\t\t\t\t\t\t\tmergeHook(hooks as AnyLocalHook, {\n\t\t\t\t\t\t\t\t\t\t\terror: plugin.event.error\n\t\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\tplugin.compile()\n\n\t\t\t\t\t\t\t\tif (plugin === this) return\n\n\t\t\t\t\t\t\t\tthis.propagatePromiseModules(plugin)\n\n\t\t\t\t\t\t\t\treturn plugin\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (typeof plugin === 'function')\n\t\t\t\t\t\t\t\treturn plugin(\n\t\t\t\t\t\t\t\t\tthis as unknown as any\n\t\t\t\t\t\t\t\t) as unknown as Elysia\n\n\t\t\t\t\t\t\tif (typeof plugin.default === 'function')\n\t\t\t\t\t\t\t\treturn plugin.default(\n\t\t\t\t\t\t\t\t\tthis as unknown as any\n\t\t\t\t\t\t\t\t) as unknown as Elysia\n\n\t\t\t\t\t\t\treturn this._use(plugin)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.then((v) => v?.compile())\n\t\t\t\t)\n\t\t\t\treturn this as unknown as any\n\t\t\t}\n\n\t\t\treturn instance\n\t\t}\n\n\t\tthis.propagatePromiseModules(plugin)\n\n\t\tconst { name, seed } = plugin.config\n\n\t\tplugin.getParent = () => this as any\n\t\tplugin.getServer = () => this.getServer()\n\t\tplugin.getGlobalRoutes = () => this.getGlobalRoutes()\n\n\t\t/**\n\t\t * Model and error is required for Swagger generation\n\t\t */\n\t\tplugin.model(this.definitions.type as any)\n\t\tplugin.error(this.definitions.error as any)\n\n\t\tthis['~parser'] = {\n\t\t\t...plugin['~parser'],\n\t\t\t...this['~parser']\n\t\t}\n\n\t\tthis.headers(plugin.setHeaders)\n\n\t\tif (name) {\n\t\t\tif (!(name in this.dependencies)) this.dependencies[name] = []\n\n\t\t\tconst current =\n\t\t\t\tseed !== undefined ? checksum(name + JSON.stringify(seed)) : 0\n\n\t\t\tif (\n\t\t\t\t!this.dependencies[name].some(\n\t\t\t\t\t({ checksum }) => current === checksum\n\t\t\t\t)\n\t\t\t) {\n\t\t\t\tthis.extender.macros = this.extender.macros.concat(\n\t\t\t\t\tplugin.extender.macros\n\t\t\t\t)\n\n\t\t\t\tthis.extender.higherOrderFunctions =\n\t\t\t\t\tthis.extender.higherOrderFunctions.concat(\n\t\t\t\t\t\tplugin.extender.higherOrderFunctions\n\t\t\t\t\t)\n\t\t\t}\n\t\t} else {\n\t\t\tthis.extender.macros = this.extender.macros.concat(\n\t\t\t\tplugin.extender.macros\n\t\t\t)\n\t\t\tthis.extender.higherOrderFunctions =\n\t\t\t\tthis.extender.higherOrderFunctions.concat(\n\t\t\t\t\tplugin.extender.higherOrderFunctions\n\t\t\t\t)\n\t\t}\n\n\t\t// ! Deduplicate current instance\n\t\tdeduplicateChecksum(this.extender.macros)\n\t\tdeduplicateChecksum(this.extender.higherOrderFunctions)\n\n\t\t// ! Deduplicate current instance\n\t\tconst hofHashes: number[] = []\n\t\tfor (let i = 0; i < this.extender.higherOrderFunctions.length; i++) {\n\t\t\tconst hof = this.extender.higherOrderFunctions[i]\n\n\t\t\tif (hof.checksum) {\n\t\t\t\tif (hofHashes.includes(hof.checksum)) {\n\t\t\t\t\tthis.extender.higherOrderFunctions.splice(i, 1)\n\t\t\t\t\ti--\n\t\t\t\t}\n\n\t\t\t\thofHashes.push(hof.checksum)\n\t\t\t}\n\t\t}\n\n\t\tthis.inference = {\n\t\t\tbody: this.inference.body || plugin.inference.body,\n\t\t\tcookie: this.inference.cookie || plugin.inference.cookie,\n\t\t\theaders: this.inference.headers || plugin.inference.headers,\n\t\t\tquery: this.inference.query || plugin.inference.query,\n\t\t\tset: this.inference.set || plugin.inference.set,\n\t\t\tserver: this.inference.server || plugin.inference.server,\n\t\t\trequest: this.inference.request || plugin.inference.request,\n\t\t\troute: this.inference.route || plugin.inference.route\n\t\t}\n\n\t\tthis.decorate(plugin.singleton.decorator)\n\t\tthis.state(plugin.singleton.store)\n\t\tthis.model(plugin.definitions.type)\n\t\tthis.error(plugin.definitions.error as any)\n\t\tplugin.extender.macros = this.extender.macros.concat(\n\t\t\tplugin.extender.macros\n\t\t)\n\n\t\tfor (const { method, path, handler, hooks } of Object.values(\n\t\t\tplugin.router.history\n\t\t)) {\n\t\t\tthis.add(\n\t\t\t\tmethod,\n\t\t\t\tpath,\n\t\t\t\thandler,\n\t\t\t\tmergeHook(hooks as AnyLocalHook, {\n\t\t\t\t\terror: plugin.event.error\n\t\t\t\t})\n\t\t\t)\n\t\t}\n\n\t\tif (name) {\n\t\t\tif (!(name in this.dependencies)) this.dependencies[name] = []\n\n\t\t\tconst current =\n\t\t\t\tseed !== undefined ? checksum(name + JSON.stringify(seed)) : 0\n\n\t\t\tif (\n\t\t\t\tthis.dependencies[name].some(\n\t\t\t\t\t({ checksum }) => current === checksum\n\t\t\t\t)\n\t\t\t)\n\t\t\t\treturn this\n\n\t\t\tthis.dependencies[name].push(\n\t\t\t\tthis.config?.analytic\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tname: plugin.config.name,\n\t\t\t\t\t\t\tseed: plugin.config.seed,\n\t\t\t\t\t\t\tchecksum: current,\n\t\t\t\t\t\t\tdependencies: plugin.dependencies,\n\t\t\t\t\t\t\tstack: plugin.telemetry.stack,\n\t\t\t\t\t\t\troutes: plugin.router.history,\n\t\t\t\t\t\t\tdecorators: plugin.singleton,\n\t\t\t\t\t\t\tstore: plugin.singleton.store,\n\t\t\t\t\t\t\terror: plugin.definitions.error,\n\t\t\t\t\t\t\tderive: plugin.event.transform\n\t\t\t\t\t\t\t\t?.filter((x) => x?.subType === 'derive')\n\t\t\t\t\t\t\t\t.map((x) => ({\n\t\t\t\t\t\t\t\t\tfn: x.toString(),\n\t\t\t\t\t\t\t\t\tstack: new Error().stack ?? ''\n\t\t\t\t\t\t\t\t})),\n\t\t\t\t\t\t\tresolve: plugin.event.transform\n\t\t\t\t\t\t\t\t?.filter((x) => x?.subType === 'resolve')\n\t\t\t\t\t\t\t\t.map((x) => ({\n\t\t\t\t\t\t\t\t\tfn: x.toString(),\n\t\t\t\t\t\t\t\t\tstack: new Error().stack ?? ''\n\t\t\t\t\t\t\t\t}))\n\t\t\t\t\t\t}\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tname: plugin.config.name,\n\t\t\t\t\t\t\tseed: plugin.config.seed,\n\t\t\t\t\t\t\tchecksum: current,\n\t\t\t\t\t\t\tdependencies: plugin.dependencies\n\t\t\t\t\t\t}\n\t\t\t)\n\n\t\t\tthis.event = mergeLifeCycle(\n\t\t\t\tthis.event,\n\t\t\t\tfilterGlobalHook(plugin.event),\n\t\t\t\tcurrent\n\t\t\t)\n\t\t} else {\n\t\t\tthis.event = mergeLifeCycle(\n\t\t\t\tthis.event,\n\t\t\t\tfilterGlobalHook(plugin.event)\n\t\t\t)\n\t\t}\n\n\t\t// @ts-ignore\n\t\tthis.validator.global = mergeHook(this.validator.global, {\n\t\t\t...plugin.validator.global\n\t\t}) as any\n\t\t// @ts-ignore\n\t\tthis.validator.local = mergeHook(this.validator.local, {\n\t\t\t...plugin.validator.scoped\n\t\t})\n\n\t\treturn this\n\t}\n\n\tmacro<const NewMacro extends BaseMacroFn>(\n\t\tmacro: (\n\t\t\troute: MacroManager<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tMetadata['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Volatile['schema']>\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Partial<Ephemeral['derive'] & Volatile['derive']>\n\t\t\t\t\tresolve: Partial<Ephemeral['resolve'] & Volatile['resolve']>\n\t\t\t\t},\n\t\t\t\tDefinitions['error']\n\t\t\t>\n\t\t) => NewMacro\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\t{\n\t\t\tschema: Metadata['schema']\n\t\t\tmacro: Metadata['macro'] & Partial<MacroToProperty<NewMacro>>\n\t\t\tmacroFn: Metadata['macroFn'] & NewMacro\n\t\t\tparser: Metadata['parser']\n\t\t},\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmacro<\n\t\tconst NewMacro extends HookMacroFn<\n\t\t\tMetadata['schema'],\n\t\t\tSingleton & {\n\t\t\t\tderive: Partial<Ephemeral['derive'] & Volatile['derive']>\n\t\t\t\tresolve: Partial<Ephemeral['resolve'] & Volatile['resolve']>\n\t\t\t},\n\t\t\tDefinitions['error']\n\t\t>\n\t>(\n\t\tmacro: NewMacro\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\t{\n\t\t\tschema: Metadata['schema']\n\t\t\tmacro: Metadata['macro'] & Partial<MacroToProperty<NewMacro>>\n\t\t\tmacroFn: Metadata['macroFn'] & NewMacro\n\t\t\tparser: Metadata['parser']\n\t\t},\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmacro(macro: Function | Record<keyof any, Function>) {\n\t\tif (typeof macro === 'function') {\n\t\t\tconst hook: MacroQueue = {\n\t\t\t\tchecksum: checksum(\n\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\tname: this.config.name,\n\t\t\t\t\t\tseed: this.config.seed,\n\t\t\t\t\t\tcontent: macro.toString()\n\t\t\t\t\t})\n\t\t\t\t),\n\t\t\t\tfn: macro as any\n\t\t\t}\n\n\t\t\tthis.extender.macros.push(hook)\n\t\t} else if (typeof macro === 'object') {\n\t\t\tfor (const name of Object.keys(macro))\n\t\t\t\tif (typeof macro[name] === 'object') {\n\t\t\t\t\tconst actualValue = { ...(macro[name] as Object) }\n\n\t\t\t\t\tmacro[name] = (v: boolean) => {\n\t\t\t\t\t\tif (v === true) return actualValue\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tconst hook: MacroQueue = {\n\t\t\t\tchecksum: checksum(\n\t\t\t\t\tJSON.stringify({\n\t\t\t\t\t\tname: this.config.name,\n\t\t\t\t\t\tseed: this.config.seed,\n\t\t\t\t\t\tcontent: Object.entries(macro)\n\t\t\t\t\t\t\t.map(([k, v]) => `${k}+${v}`)\n\t\t\t\t\t\t\t.join(',')\n\t\t\t\t\t})\n\t\t\t\t),\n\t\t\t\tfn: () => macro\n\t\t\t}\n\n\t\t\tthis.extender.macros.push(hook)\n\t\t}\n\n\t\treturn this as any\n\t}\n\n\tmount(\n\t\thandle: ((request: Request) => MaybePromise<Response>) | AnyElysia\n\t): this\n\tmount(\n\t\tpath: string,\n\t\thandle: ((request: Request) => MaybePromise<Response>) | AnyElysia\n\t): this\n\n\tmount(\n\t\tpath:\n\t\t\t| string\n\t\t\t| ((request: Request) => MaybePromise<Response>)\n\t\t\t| AnyElysia,\n\t\thandle?: ((request: Request) => MaybePromise<Response>) | AnyElysia\n\t) {\n\t\tif (\n\t\t\tpath instanceof Elysia ||\n\t\t\ttypeof path === 'function' ||\n\t\t\tpath.length === 0 ||\n\t\t\tpath === '/'\n\t\t) {\n\t\t\tconst run =\n\t\t\t\ttypeof path === 'function'\n\t\t\t\t\t? path\n\t\t\t\t\t: path instanceof Elysia\n\t\t\t\t\t\t? path.compile().fetch\n\t\t\t\t\t\t: handle instanceof Elysia\n\t\t\t\t\t\t\t? handle.compile().fetch\n\t\t\t\t\t\t\t: handle!\n\n\t\t\tconst handler: Handler<any, any> = async ({ request, path }) => {\n\t\t\t\tif (\n\t\t\t\t\trequest.method === 'GET' ||\n\t\t\t\t\trequest.method === 'HEAD' ||\n\t\t\t\t\t!request.headers.get('content-type')\n\t\t\t\t)\n\t\t\t\t\treturn run(\n\t\t\t\t\t\tnew Request(\n\t\t\t\t\t\t\treplaceUrlPath(request.url, path || '/'),\n\t\t\t\t\t\t\trequest\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\n\t\t\t\treturn run(\n\t\t\t\t\tnew Request(replaceUrlPath(request.url, path || '/'), {\n\t\t\t\t\t\t...request,\n\t\t\t\t\t\tbody: await request.arrayBuffer()\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t}\n\n\t\t\tthis.all(\n\t\t\t\t'/*',\n\t\t\t\thandler as any,\n\t\t\t\t{\n\t\t\t\t\ttype: 'none'\n\t\t\t\t} as any\n\t\t\t)\n\n\t\t\treturn this\n\t\t}\n\n\t\tconst length = path.length\n\n\t\tif (handle instanceof Elysia) handle = handle.compile().fetch\n\n\t\tconst handler: Handler<any, any> = async ({ request, path }) => {\n\t\t\tif (\n\t\t\t\trequest.method === 'GET' ||\n\t\t\t\trequest.method === 'HEAD' ||\n\t\t\t\t!request.headers.get('content-type')\n\t\t\t)\n\t\t\t\treturn (handle as Function)(\n\t\t\t\t\tnew Request(\n\t\t\t\t\t\treplaceUrlPath(request.url, path.slice(length) || '/'),\n\t\t\t\t\t\trequest\n\t\t\t\t\t)\n\t\t\t\t)\n\n\t\t\treturn (handle as Function)(\n\t\t\t\tnew Request(\n\t\t\t\t\treplaceUrlPath(request.url, path.slice(length) || '/'),\n\t\t\t\t\t{\n\t\t\t\t\t\t...request,\n\t\t\t\t\t\tbody: await request.arrayBuffer()\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t)\n\t\t}\n\n\t\tthis.all(\n\t\t\tpath,\n\t\t\thandler as any,\n\t\t\t{\n\t\t\t\ttype: 'none'\n\t\t\t} as any\n\t\t)\n\n\t\tthis.all(\n\t\t\tpath + (path.endsWith('/') ? '*' : '/*'),\n\t\t\thandler as any,\n\t\t\t{\n\t\t\t\ttype: 'none'\n\t\t\t} as any\n\t\t)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### get\n\t * Register handler for path with method [GET]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .get('/', () => 'hi')\n\t *     .get('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tget<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof UnwrapTypeModule<Definitions['typebox']> & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroToContext<Metadata['macroFn'], NoInfer<Macro>>\n\t\t\t},\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroToContext<Metadata['macroFn'], NoInfer<Macro>>\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['macro'],\n\t\t\tkeyof Metadata['parser'] & string\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tget: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('GET', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### post\n\t * Register handler for path with method [POST]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .post('/', () => 'hi')\n\t *     .post('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tpost<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof UnwrapTypeModule<Definitions['typebox']> & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroToContext<Metadata['macroFn'], NoInfer<Macro>>\n\t\t\t},\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroToContext<Metadata['macroFn'], NoInfer<Macro>>\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['macro'],\n\t\t\tkeyof Metadata['parser'] & string\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tpost: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('POST', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### put\n\t * Register handler for path with method [PUT]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .put('/', () => 'hi')\n\t *     .put('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tput<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof UnwrapTypeModule<Definitions['typebox']> & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroToContext<Metadata['macroFn'], NoInfer<Macro>>\n\t\t\t},\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroToContext<Metadata['macroFn'], NoInfer<Macro>>\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['macro'],\n\t\t\tkeyof Metadata['parser'] & string\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tput: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('PUT', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### patch\n\t * Register handler for path with method [PATCH]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .patch('/', () => 'hi')\n\t *     .patch('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tpatch<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof UnwrapTypeModule<Definitions['typebox']> & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroToContext<Metadata['macroFn'], NoInfer<Macro>>\n\t\t\t},\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroToContext<Metadata['macroFn'], NoInfer<Macro>>\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['macro'],\n\t\t\tkeyof Metadata['parser'] & string\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tpatch: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('PATCH', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### delete\n\t * Register handler for path with method [DELETE]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .delete('/', () => 'hi')\n\t *     .delete('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tdelete<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof UnwrapTypeModule<Definitions['typebox']> & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroToContext<Metadata['macroFn'], NoInfer<Macro>>\n\t\t\t},\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroToContext<Metadata['macroFn'], NoInfer<Macro>>\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['macro'],\n\t\t\tkeyof Metadata['parser'] & string\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tdelete: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('DELETE', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### options\n\t * Register handler for path with method [POST]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .options('/', () => 'hi')\n\t *     .options('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\toptions<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof UnwrapTypeModule<Definitions['typebox']> & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroToContext<Metadata['macroFn'], NoInfer<Macro>>\n\t\t\t},\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroToContext<Metadata['macroFn'], NoInfer<Macro>>\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['macro'],\n\t\t\tkeyof Metadata['parser'] & string\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('OPTIONS', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### all\n\t * Register handler for path with method [ALL]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .all('/', () => 'hi')\n\t *     .all('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tall<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof UnwrapTypeModule<Definitions['typebox']> & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroToContext<Metadata['macroFn'], NoInfer<Macro>>\n\t\t\t},\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroToContext<Metadata['macroFn'], NoInfer<Macro>>\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['macro'],\n\t\t\tkeyof Metadata['parser'] & string\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\t[method in string]: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('ALL', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### head\n\t * Register handler for path with method [HEAD]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .head('/', () => 'hi')\n\t *     .head('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\thead<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof UnwrapTypeModule<Definitions['typebox']> & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroToContext<Metadata['macroFn'], NoInfer<Macro>>\n\t\t\t},\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroToContext<Metadata['macroFn'], NoInfer<Macro>>\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['macro'],\n\t\t\tkeyof Metadata['parser'] & string\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\thead: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('HEAD', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### connect\n\t * Register handler for path with method [CONNECT]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .connect('/', () => 'hi')\n\t *     .connect('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\tconnect<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof UnwrapTypeModule<Definitions['typebox']> & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroToContext<Metadata['macroFn'], NoInfer<Macro>>\n\t\t\t},\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroToContext<Metadata['macroFn'], NoInfer<Macro>>\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['macro'],\n\t\t\tkeyof Metadata['parser'] & string\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tconnect: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add('CONNECT', path, handler as any, hook)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### route\n\t * Register handler for path with method [ROUTE]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .route('/', () => 'hi')\n\t *     .route('/with-hook', () => 'hi', {\n\t *         response: t.String()\n\t *     })\n\t * ```\n\t */\n\troute<\n\t\tconst Method extends HTTPMethod,\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof UnwrapTypeModule<Definitions['typebox']> & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst MacroContext extends MacroToContext<\n\t\t\tMetadata['macroFn'],\n\t\t\tNoInfer<Macro>\n\t\t>,\n\t\tconst Handle extends InlineHandler<\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroContext\n\t\t\t},\n\t\t\tJoinPath<BasePath, Path>\n\t\t>\n\t>(\n\t\tmethod: Method,\n\t\tpath: Path,\n\t\thandler: Handle,\n\t\thook?: LocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroContext\n\t\t\t},\n\t\t\tDefinitions['error'],\n\t\t\tMacro,\n\t\t\tkeyof Metadata['macro'],\n\t\t\tkeyof Metadata['parser'] & string\n\t\t> & {\n\t\t\tconfig: {\n\t\t\t\tallowMeta?: boolean\n\t\t\t}\n\t\t}\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\t[method in Method]: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: ComposeElysiaResponse<Schema, Handle>\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tthis.add(method.toUpperCase(), path, handler as any, hook, hook?.config)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### ws\n\t * Register handler for path with method [ws]\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * import { Elysia, t } from 'elysia'\n\t *\n\t * new Elysia()\n\t *     .ws('/', {\n\t *         message(ws, message) {\n\t *             ws.send(message)\n\t *         }\n\t *     })\n\t * ```\n\t */\n\tws<\n\t\tconst Path extends string,\n\t\tconst LocalSchema extends InputSchema<\n\t\t\tkeyof UnwrapTypeModule<Definitions['typebox']> & string\n\t\t>,\n\t\tconst Schema extends MergeSchema<\n\t\t\tUnwrapRoute<\n\t\t\t\tLocalSchema,\n\t\t\t\tDefinitions['typebox'],\n\t\t\t\tJoinPath<BasePath, Path>\n\t\t\t>,\n\t\t\tMergeSchema<\n\t\t\t\tVolatile['schema'],\n\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>\n\t\t\t>\n\t\t>,\n\t\tconst Macro extends Metadata['macro'],\n\t\tconst MacroContext extends MacroToContext<\n\t\t\tMetadata['macroFn'],\n\t\t\tNoInfer<Macro>\n\t\t>\n\t>(\n\t\tpath: Path,\n\t\toptions: WSLocalHook<\n\t\t\tLocalSchema,\n\t\t\tSchema,\n\t\t\tSingleton & {\n\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\tMacroContext\n\t\t\t},\n\t\t\tMacro,\n\t\t\tkeyof Macro\n\t\t>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes &\n\t\t\tCreateEden<\n\t\t\t\tJoinPath<BasePath, Path>,\n\t\t\t\t{\n\t\t\t\t\tsubscribe: {\n\t\t\t\t\t\tbody: Schema['body']\n\t\t\t\t\t\tparams: undefined extends Schema['params']\n\t\t\t\t\t\t\t? ResolvePath<Path>\n\t\t\t\t\t\t\t: Schema['params']\n\t\t\t\t\t\tquery: Schema['query']\n\t\t\t\t\t\theaders: Schema['headers']\n\t\t\t\t\t\tresponse: {} extends Schema['response']\n\t\t\t\t\t\t\t? unknown\n\t\t\t\t\t\t\t: Schema['response'] extends Record<200, unknown>\n\t\t\t\t\t\t\t\t? Schema['response'][200]\n\t\t\t\t\t\t\t\t: unknown\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t>,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tif (this['~adapter'].ws) this['~adapter'].ws(this, path, options as any)\n\t\telse console.warn(`Current adapter doesn't support WebSocket`)\n\n\t\treturn this as any\n\t}\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state('counter', 0)\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<const Name extends string | number | symbol, Value>(\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Reconcile<\n\t\t\t\tSingleton['store'],\n\t\t\t\t{\n\t\t\t\t\t[name in Name]: Value\n\t\t\t\t}\n\t\t\t>\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state({ counter: 0 })\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<Store extends Record<string, unknown>>(\n\t\tstore: Store\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Reconcile<Singleton['store'], Store>\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state('counter', 0)\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<\n\t\tconst Type extends ContextAppendType,\n\t\tconst Name extends string | number | symbol,\n\t\tValue\n\t>(\n\t\toptions: { as: Type },\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Reconcile<\n\t\t\t\tSingleton['store'],\n\t\t\t\t{\n\t\t\t\t\t[name in Name]: Value\n\t\t\t\t},\n\t\t\t\tType extends 'override' ? true : false\n\t\t\t>\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state({ counter: 0 })\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate<\n\t\tconst Type extends ContextAppendType,\n\t\tStore extends Record<string, unknown>\n\t>(\n\t\toptions: { as: Type },\n\t\tstore: Store\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: Reconcile<\n\t\t\t\tSingleton['store'],\n\t\t\t\tStore,\n\t\t\t\tType extends 'override' ? true : false\n\t\t\t>\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tstate<NewStore extends Record<string, unknown>>(\n\t\tmapper: (decorators: Singleton['store']) => NewStore\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Singleton['decorator']\n\t\t\tstore: NewStore\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### state\n\t * Assign global mutatable state accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .state('counter', 0)\n\t *     .get('/', (({ counter }) => ++counter)\n\t * ```\n\t */\n\tstate(\n\t\toptions:\n\t\t\t| { as: ContextAppendType }\n\t\t\t| string\n\t\t\t| Record<string, unknown>\n\t\t\t| Function,\n\t\tname?:\n\t\t\t| string\n\t\t\t| Record<string, unknown>\n\t\t\t| Function\n\t\t\t| { as: ContextAppendType },\n\t\tvalue?: unknown\n\t) {\n\t\tif (name === undefined) {\n\t\t\t/**\n\t\t\t * Using either\n\t\t\t * - decorate({ name: value })\n\t\t\t */\n\t\t\tvalue = options\n\t\t\toptions = { as: 'append' }\n\t\t\tname = ''\n\t\t} else if (value === undefined) {\n\t\t\t/**\n\t\t\t * Using either\n\t\t\t * - decorate({ as: 'override' }, { name: value })\n\t\t\t * - decorate('name', value)\n\t\t\t */\n\n\t\t\t// decorate('name', value)\n\t\t\tif (typeof options === 'string') {\n\t\t\t\tvalue = name\n\t\t\t\tname = options\n\t\t\t\toptions = { as: 'append' }\n\t\t\t} else if (typeof options === 'object') {\n\t\t\t\t// decorate({ as: 'override' }, { name: value })\n\t\t\t\tvalue = name\n\t\t\t\tname = ''\n\t\t\t}\n\t\t}\n\n\t\tconst { as } = options as { as: ContextAppendType }\n\n\t\tif (typeof name !== 'string') return this\n\n\t\tswitch (typeof value) {\n\t\t\tcase 'object':\n\t\t\t\tif (name) {\n\t\t\t\t\tif (name in this.singleton.store)\n\t\t\t\t\t\tthis.singleton.store[name] = mergeDeep(\n\t\t\t\t\t\t\tthis.singleton.store[name] as any,\n\t\t\t\t\t\t\tvalue!,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\toverride: as === 'override'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\telse this.singleton.store[name] = value\n\n\t\t\t\t\treturn this\n\t\t\t\t}\n\n\t\t\t\tif (value === null) return this\n\n\t\t\t\tthis.singleton.store = mergeDeep(this.singleton.store, value, {\n\t\t\t\t\toverride: as === 'override'\n\t\t\t\t})\n\n\t\t\t\treturn this as any\n\n\t\t\tcase 'function':\n\t\t\t\tif (name) {\n\t\t\t\t\tif (as === 'override' || !(name in this.singleton.store))\n\t\t\t\t\t\tthis.singleton.store[name] = value\n\t\t\t\t} else this.singleton.store = value(this.singleton.store)\n\n\t\t\t\treturn this as any\n\n\t\t\tdefault:\n\t\t\t\tif (as === 'override' || !(name in this.singleton.store))\n\t\t\t\t\tthis.singleton.store[name] = value\n\n\t\t\t\treturn this\n\t\t}\n\t}\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<const Name extends string, const Value>(\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Reconcile<\n\t\t\t\tSingleton['decorator'],\n\t\t\t\t{\n\t\t\t\t\t[name in Name]: Value\n\t\t\t\t}\n\t\t\t>\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<const NewDecorators extends Record<string, unknown>>(\n\t\tdecorators: NewDecorators\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Reconcile<Singleton['decorator'], NewDecorators>\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tdecorate<const NewDecorators extends Record<string, unknown>>(\n\t\tmapper: (decorators: Singleton['decorator']) => NewDecorators\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: NewDecorators\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate({ as: 'override' }, 'getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<\n\t\tconst Type extends ContextAppendType,\n\t\tconst Name extends string,\n\t\tconst Value\n\t>(\n\t\toptions: { as: Type },\n\t\tname: Name,\n\t\tvalue: Value\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Reconcile<\n\t\t\t\tSingleton['decorator'],\n\t\t\t\t{\n\t\t\t\t\t[name in Name]: Value\n\t\t\t\t},\n\t\t\t\tType extends 'override' ? true : false\n\t\t\t>\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate<\n\t\tconst Type extends ContextAppendType,\n\t\tconst NewDecorators extends Record<string, unknown>\n\t>(\n\t\toptions: { as: Type },\n\t\tdecorators: NewDecorators\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Reconcile<\n\t\t\t\tSingleton['decorator'],\n\t\t\t\tNewDecorators,\n\t\t\t\tType extends 'override' ? true : false\n\t\t\t>\n\t\t\tstore: Singleton['store']\n\t\t\tderive: Singleton['derive']\n\t\t\tresolve: Singleton['resolve']\n\t\t},\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\t/**\n\t * ### decorate\n\t * Define custom method to `Context` accessible for all handler\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .decorate('getDate', () => Date.now())\n\t *     .get('/', (({ getDate }) => getDate())\n\t * ```\n\t */\n\tdecorate(\n\t\toptions:\n\t\t\t| { as: ContextAppendType }\n\t\t\t| string\n\t\t\t| Record<string, unknown>\n\t\t\t| Function,\n\t\tname?:\n\t\t\t| string\n\t\t\t| Record<string, unknown>\n\t\t\t| Function\n\t\t\t| { as: ContextAppendType },\n\t\tvalue?: unknown\n\t) {\n\t\tif (name === undefined) {\n\t\t\t/**\n\t\t\t * Using either\n\t\t\t * - decorate({ name: value })\n\t\t\t */\n\t\t\tvalue = options\n\t\t\toptions = { as: 'append' }\n\t\t\tname = ''\n\t\t} else if (value === undefined) {\n\t\t\t/**\n\t\t\t * Using either\n\t\t\t * - decorate({ as: 'override' }, { name: value })\n\t\t\t * - decorate('name', value)\n\t\t\t */\n\n\t\t\t// decorate('name', value)\n\t\t\tif (typeof options === 'string') {\n\t\t\t\tvalue = name\n\t\t\t\tname = options\n\t\t\t\toptions = { as: 'append' }\n\t\t\t} else if (typeof options === 'object') {\n\t\t\t\t// decorate({ as: 'override' }, { name: value })\n\t\t\t\tvalue = name\n\t\t\t\tname = ''\n\t\t\t}\n\t\t}\n\n\t\tconst { as } = options as { as: ContextAppendType }\n\n\t\tif (typeof name !== 'string') return this\n\n\t\tswitch (typeof value) {\n\t\t\tcase 'object':\n\t\t\t\tif (name) {\n\t\t\t\t\tif (name in this.singleton.decorator)\n\t\t\t\t\t\tthis.singleton.decorator[name] = mergeDeep(\n\t\t\t\t\t\t\tthis.singleton.decorator[name] as any,\n\t\t\t\t\t\t\tvalue!,\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\toverride: as === 'override'\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\telse this.singleton.decorator[name] = value\n\n\t\t\t\t\treturn this\n\t\t\t\t}\n\n\t\t\t\tif (value === null) return this\n\n\t\t\t\tthis.singleton.decorator = mergeDeep(\n\t\t\t\t\tthis.singleton.decorator,\n\t\t\t\t\tvalue,\n\t\t\t\t\t{\n\t\t\t\t\t\toverride: as === 'override'\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn this as any\n\n\t\t\tcase 'function':\n\t\t\t\tif (name) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tas === 'override' ||\n\t\t\t\t\t\t!(name in this.singleton.decorator)\n\t\t\t\t\t)\n\t\t\t\t\t\tthis.singleton.decorator[name] = value\n\t\t\t\t} else\n\t\t\t\t\tthis.singleton.decorator = value(this.singleton.decorator)\n\n\t\t\t\treturn this as any\n\n\t\t\tdefault:\n\t\t\t\tif (as === 'override' || !(name in this.singleton.decorator))\n\t\t\t\t\tthis.singleton.decorator[name] = value\n\n\t\t\t\treturn this\n\t\t}\n\t}\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tderive<\n\t\tconst Derivative extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>\n\t\t\t| void\n\t>(\n\t\ttransform: (\n\t\t\tcontext: Prettify<\n\t\t\t\tContext<\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>,\n\t\t\t\t\t\tBasePath\n\t\t\t\t\t>,\n\t\t\t\t\tSingleton & {\n\t\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t>\n\t\t) => MaybePromise<Derivative>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: Prettify<\n\t\t\t\tVolatile['derive'] & ExcludeElysiaResponse<Derivative>\n\t\t\t>\n\t\t\tresolve: Volatile['resolve']\n\t\t\tschema: Volatile['schema']\n\t\t}\n\t>\n\n\t/**\n\t * Derive new property for each request with access to `Context`.\n\t *\n\t * If error is thrown, the scope will skip to handling error instead.\n\t *\n\t * ---\n\t * @example\n\t * new Elysia()\n\t *     .state('counter', 1)\n\t *     .derive(({ store }) => ({\n\t *         increase() {\n\t *             store.counter++\n\t *         }\n\t *     }))\n\t */\n\tderive<\n\t\tconst Derivative extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>\n\t\t\t| void,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\ttransform: (\n\t\t\tcontext: Prettify<\n\t\t\t\tContext<\n\t\t\t\t\tMergeSchema<\n\t\t\t\t\t\tVolatile['schema'],\n\t\t\t\t\t\tMergeSchema<Ephemeral['schema'], Metadata['schema']>,\n\t\t\t\t\t\tBasePath\n\t\t\t\t\t> &\n\t\t\t\t\t\t'global' extends Type\n\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? { params: Record<string, string> }\n\t\t\t\t\t\t\t: {},\n\t\t\t\t\tSingleton &\n\t\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t\t}),\n\t\t\t\t\tBasePath\n\t\t\t\t>\n\t\t\t>\n\t\t) => MaybePromise<Derivative>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Prettify<\n\t\t\t\t\t\tSingleton['derive'] & ExcludeElysiaResponse<Derivative>\n\t\t\t\t\t>\n\t\t\t\t\tresolve: Singleton['resolve']\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Prettify<\n\t\t\t\t\t\t\tEphemeral['derive'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<Derivative>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tresolve: Ephemeral['resolve']\n\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t},\n\t\t\t\t\tVolatile\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Prettify<\n\t\t\t\t\t\t\tVolatile['derive'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<Derivative>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tresolve: Ephemeral['resolve']\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t}\n\t\t\t\t>\n\n\tderive(\n\t\toptionsOrTransform: { as?: LifeCycleType } | Function,\n\t\ttransform?: Function\n\t) {\n\t\tif (!transform) {\n\t\t\ttransform = optionsOrTransform as any\n\t\t\toptionsOrTransform = { as: 'local' }\n\t\t}\n\n\t\tconst hook: HookContainer = {\n\t\t\tsubType: 'derive',\n\t\t\tfn: transform!\n\t\t}\n\n\t\treturn this.onTransform(optionsOrTransform as any, hook as any) as any\n\t}\n\n\tmodel<const Name extends string, const Model extends TSchema>(\n\t\tname: Name,\n\t\tmodel: Model\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\t{\n\t\t\ttypebox: TModule<\n\t\t\t\tPrettify<\n\t\t\t\t\tUnwrapTypeModule<Definitions['typebox']> & {\n\t\t\t\t\t\t[name in Name]: Model\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t>\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmodel<const Recorder extends TProperties>(\n\t\trecord: Recorder\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\t{\n\t\t\ttypebox: TModule<\n\t\t\t\tPrettify<UnwrapTypeModule<Definitions['typebox']> & Recorder>\n\t\t\t>\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmodel<const NewType extends Record<string, TSchema>>(\n\t\tmapper: (\n\t\t\tdecorators: UnwrapTypeModule<\n\t\t\t\tDefinitions['typebox']\n\t\t\t> extends infer Models extends Record<string, TSchema>\n\t\t\t\t? {\n\t\t\t\t\t\t[type in keyof Models]: TRef<// @ts-expect-error type is always string\n\t\t\t\t\t\ttype>\n\t\t\t\t\t}\n\t\t\t\t: {}\n\t\t) => NewType\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\t{\n\t\t\ttypebox: TModule<{\n\t\t\t\t[key in keyof NewType]: NewType[key] extends TRef<key & string>\n\t\t\t\t\t? UnwrapTypeModule<Definitions['typebox']>[key]\n\t\t\t\t\t: NewType[key]\n\t\t\t}>\n\t\t\ttype: { [x in keyof NewType]: Static<NewType[x]> }\n\t\t\terror: Definitions['error']\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t>\n\n\tmodel(name: string | Record<string, TSchema> | Function, model?: TSchema) {\n\t\tconst coerce = (schema: TSchema) =>\n\t\t\treplaceSchemaType(schema, [\n\t\t\t\t{\n\t\t\t\t\tfrom: t.Number(),\n\t\t\t\t\tto: (options) => t.Numeric(options),\n\t\t\t\t\tuntilObjectFound: true\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tfrom: t.Boolean(),\n\t\t\t\t\tto: (options) => t.BooleanString(options),\n\t\t\t\t\tuntilObjectFound: true\n\t\t\t\t}\n\t\t\t])\n\n\t\tswitch (typeof name) {\n\t\t\tcase 'object':\n\t\t\t\tconst parsedSchemas = {} as Record<string, TSchema>\n\n\t\t\t\tconst kvs = Object.entries(name)\n\n\t\t\t\tfor (const [key, value] of kvs) {\n\t\t\t\t\tif (key in this.definitions.type) continue\n\n\t\t\t\t\tparsedSchemas[key] = this.definitions.type[key] = coerce(\n\t\t\t\t\t\tvalue\n\t\t\t\t\t) as TSchema\n\n\t\t\t\t\tparsedSchemas[key].$id ??= `#/components/schemas/${key}`\n\t\t\t\t}\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tthis.definitions.typebox = t.Module({\n\t\t\t\t\t...(this.definitions.typebox['$defs'] as TModule<{}>),\n\t\t\t\t\t...parsedSchemas\n\t\t\t\t} as any)\n\n\t\t\t\treturn this\n\n\t\t\tcase 'function':\n\t\t\t\tconst result = coerce(name(this.definitions.type))\n\t\t\t\tthis.definitions.type = result\n\t\t\t\tthis.definitions.typebox = t.Module(result as any)\n\n\t\t\t\treturn this as any\n\n\t\t\tcase 'string':\n\t\t\t\tif (!model) break\n\n\t\t\t\tconst newModel = {\n\t\t\t\t\t...model,\n\t\t\t\t\tid: model.$id ?? `#/components/schemas/${name}`\n\t\t\t\t}\n\n\t\t\t\tthis.definitions.type[name] = model\n\t\t\t\tthis.definitions.typebox = t.Module({\n\t\t\t\t\t...(this.definitions.typebox['$defs'] as TModule<{}>),\n\t\t\t\t\t...newModel\n\t\t\t\t} as any)\n\t\t\t\treturn this as any\n\t\t}\n\n\t\t;(this.definitions.type as Record<string, TSchema>)[name] = model!\n\t\tthis.definitions.typebox = t.Module({\n\t\t\t...this.definitions.typebox['$defs'],\n\t\t\t[name]: model!\n\t\t} as any)\n\n\t\treturn this as any\n\t}\n\n\tmapDerive<\n\t\tconst NewDerivative extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>\n\t>(\n\t\tmapper: (\n\t\t\tcontext: Context<\n\t\t\t\t{},\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t) => MaybePromise<NewDerivative>\n\t): Elysia<\n\t\tBasePath,\n\t\tSingleton,\n\t\tDefinitions,\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\t{\n\t\t\tderive: ExcludeElysiaResponse<NewDerivative>\n\t\t\tresolve: Volatile['resolve']\n\t\t\tschema: Volatile['schema']\n\t\t}\n\t>\n\n\tmapDerive<\n\t\tconst NewDerivative extends\n\t\t\t| Record<string, unknown>\n\t\t\t| ElysiaCustomStatusResponse<any, any, any>,\n\t\tconst Type extends LifeCycleType\n\t>(\n\t\toptions: { as?: Type },\n\t\tmapper: (\n\t\t\tcontext: Context<\n\t\t\t\t{},\n\t\t\t\tSingleton &\n\t\t\t\t\t('global' extends Type\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tderive: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['derive'] & Volatile['derive']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\tresolve: Partial<\n\t\t\t\t\t\t\t\t\tEphemeral['resolve'] & Volatile['resolve']\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: 'scoped' extends Type\n\t\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['derive']>\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tPartial<Volatile['resolve']>\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\tderive: Ephemeral['derive'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['derive']\n\t\t\t\t\t\t\t\t\tresolve: Ephemeral['resolve'] &\n\t\t\t\t\t\t\t\t\t\tVolatile['resolve']\n\t\t\t\t\t\t\t\t}),\n\t\t\t\tBasePath\n\t\t\t>\n\t\t) => MaybePromise<NewDerivative>\n\t): Type extends 'global'\n\t\t? Elysia<\n\t\t\t\tBasePath,\n\t\t\t\t{\n\t\t\t\t\tdecorator: Singleton['decorator']\n\t\t\t\t\tstore: Singleton['store']\n\t\t\t\t\tderive: Singleton['derive']\n\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\tSingleton['resolve'] &\n\t\t\t\t\t\t\tExcludeElysiaResponse<NewDerivative>\n\t\t\t\t\t>\n\t\t\t\t},\n\t\t\t\tDefinitions,\n\t\t\t\tMetadata,\n\t\t\t\tRoutes,\n\t\t\t\tEphemeral,\n\t\t\t\tVolatile\n\t\t\t>\n\t\t: Type extends 'scoped'\n\t\t\t? Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Ephemeral['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tEphemeral['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<NewDerivative>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Ephemeral['schema']\n\t\t\t\t\t},\n\t\t\t\t\tVolatile\n\t\t\t\t>\n\t\t\t: Elysia<\n\t\t\t\t\tBasePath,\n\t\t\t\t\tSingleton,\n\t\t\t\t\tDefinitions,\n\t\t\t\t\tMetadata,\n\t\t\t\t\tRoutes,\n\t\t\t\t\tEphemeral,\n\t\t\t\t\t{\n\t\t\t\t\t\tderive: Volatile['derive']\n\t\t\t\t\t\tresolve: Prettify<\n\t\t\t\t\t\t\tVolatile['resolve'] &\n\t\t\t\t\t\t\t\tExcludeElysiaResponse<NewDerivative>\n\t\t\t\t\t\t>\n\t\t\t\t\t\tschema: Volatile['schema']\n\t\t\t\t\t}\n\t\t\t\t>\n\n\tmapDerive(\n\t\toptionsOrDerive: { as?: LifeCycleType } | Function,\n\t\tmapper?: Function\n\t) {\n\t\tif (!mapper) {\n\t\t\tmapper = optionsOrDerive as any\n\t\t\toptionsOrDerive = { as: 'local' }\n\t\t}\n\n\t\tconst hook: HookContainer = {\n\t\t\tsubType: 'mapDerive',\n\t\t\tfn: mapper!\n\t\t}\n\n\t\treturn this.onTransform(optionsOrDerive as any, hook as any) as any\n\t}\n\n\taffix<\n\t\tconst Base extends 'prefix' | 'suffix',\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(\n\t\tbase: Base,\n\t\ttype: Type,\n\t\tword: Word\n\t): Elysia<\n\t\tBasePath,\n\t\t{\n\t\t\tdecorator: Type extends 'decorator' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Singleton['decorator']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Singleton['decorator']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Singleton['decorator']>\n\t\t\t\t: Singleton['decorator']\n\t\t\tstore: Type extends 'state' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Singleton['store']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Singleton['store']>\n\t\t\t\t\t: AddSuffix<Word, Singleton['store']>\n\t\t\t\t: Singleton['store']\n\t\t\tderive: Type extends 'decorator' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Singleton['derive']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Singleton['derive']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Singleton['derive']>\n\t\t\t\t: Singleton['derive']\n\t\t\tresolve: Type extends 'decorator' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Singleton['resolve']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Singleton['resolve']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Singleton['resolve']>\n\t\t\t\t: Singleton['resolve']\n\t\t},\n\t\t{\n\t\t\ttypebox: Type extends 'model' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? TModule<\n\t\t\t\t\t\t\t\tAddPrefix<\n\t\t\t\t\t\t\t\t\tWord,\n\t\t\t\t\t\t\t\t\tUnwrapTypeModule<Definitions['typebox']>\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t: TModule<\n\t\t\t\t\t\t\t\tAddPrefixCapitalize<\n\t\t\t\t\t\t\t\t\tWord,\n\t\t\t\t\t\t\t\t\tUnwrapTypeModule<Definitions['typebox']>\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t>\n\t\t\t\t\t: TModule<\n\t\t\t\t\t\t\tAddSuffixCapitalize<\n\t\t\t\t\t\t\t\tWord,\n\t\t\t\t\t\t\t\tUnwrapTypeModule<Definitions['typebox']>\n\t\t\t\t\t\t\t>\n\t\t\t\t\t\t>\n\t\t\t\t: Definitions['typebox']\n\t\t\terror: Type extends 'error' | 'all'\n\t\t\t\t? 'prefix' extends Base\n\t\t\t\t\t? Word extends `${string}${'_' | '-' | ' '}`\n\t\t\t\t\t\t? AddPrefix<Word, Definitions['error']>\n\t\t\t\t\t\t: AddPrefixCapitalize<Word, Definitions['error']>\n\t\t\t\t\t: AddSuffixCapitalize<Word, Definitions['error']>\n\t\t\t\t: Definitions['error']\n\t\t},\n\t\tMetadata,\n\t\tRoutes,\n\t\tEphemeral,\n\t\tVolatile\n\t> {\n\t\tif (word === '') return this as any\n\n\t\tconst delimieter = ['_', '-', ' ']\n\t\tconst capitalize = (word: string) =>\n\t\t\tword[0].toUpperCase() + word.slice(1)\n\n\t\tconst joinKey =\n\t\t\tbase === 'prefix'\n\t\t\t\t? (prefix: string, word: string) =>\n\t\t\t\t\t\tdelimieter.includes(prefix.at(-1) ?? '')\n\t\t\t\t\t\t\t? prefix + word\n\t\t\t\t\t\t\t: prefix + capitalize(word)\n\t\t\t\t: delimieter.includes(word.at(-1) ?? '')\n\t\t\t\t\t? (suffix: string, word: string) => word + suffix\n\t\t\t\t\t: (suffix: string, word: string) =>\n\t\t\t\t\t\t\tword + capitalize(suffix)\n\n\t\tconst remap = (type: 'decorator' | 'state' | 'model' | 'error') => {\n\t\t\tconst store: Record<string, any> = {}\n\n\t\t\tswitch (type) {\n\t\t\t\tcase 'decorator':\n\t\t\t\t\tfor (const key in this.singleton.decorator) {\n\t\t\t\t\t\tstore[joinKey(word, key)] =\n\t\t\t\t\t\t\tthis.singleton.decorator[key]\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.singleton.decorator = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'state':\n\t\t\t\t\tfor (const key in this.singleton.store)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.singleton.store[key]\n\n\t\t\t\t\tthis.singleton.store = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'model':\n\t\t\t\t\tfor (const key in this.definitions.type)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.definitions.type[key]\n\n\t\t\t\t\tthis.definitions.type = store\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'error':\n\t\t\t\t\tfor (const key in this.definitions.error)\n\t\t\t\t\t\tstore[joinKey(word, key)] = this.definitions.error[key]\n\n\t\t\t\t\tthis.definitions.error = store\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\tconst types = Array.isArray(type) ? type : [type]\n\n\t\tfor (const type of types.some((x) => x === 'all')\n\t\t\t? ['decorator', 'state', 'model', 'error']\n\t\t\t: types)\n\t\t\tremap(type as 'decorator')\n\n\t\treturn this as any\n\t}\n\n\tprefix<\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(type: Type, word: Word) {\n\t\treturn this.affix('prefix', type, word)\n\t}\n\n\tsuffix<\n\t\tconst Type extends 'all' | 'decorator' | 'state' | 'model' | 'error',\n\t\tconst Word extends string\n\t>(type: Type, word: Word) {\n\t\treturn this.affix('suffix', type, word)\n\t}\n\n\tcompile() {\n\t\tif (this['~adapter'].isWebStandard) {\n\t\t\tthis.fetch = this.config.aot\n\t\t\t\t? composeGeneralHandler(this)\n\t\t\t\t: createDynamicHandler(this)\n\n\t\t\tif (typeof this.server?.reload === 'function')\n\t\t\t\tthis.server.reload({\n\t\t\t\t\t...(this.server || {}),\n\t\t\t\t\tfetch: this.fetch\n\t\t\t\t})\n\n\t\t\treturn this\n\t\t}\n\n\t\tif (typeof this.server?.reload === 'function')\n\t\t\tthis.server.reload(this.server || {})\n\n\t\tthis._handle = composeGeneralHandler(this)\n\n\t\treturn this\n\t}\n\n\thandle = async (request: Request) => this.fetch(request)\n\n\t/**\n\t * Use handle can be either sync or async to save performance.\n\t *\n\t * Beside benchmark purpose, please use 'handle' instead.\n\t */\n\tfetch = (request: Request): MaybePromise<Response> => {\n\t\treturn (this.fetch = this.config.aot\n\t\t\t? composeGeneralHandler(this)\n\t\t\t: createDynamicHandler(this))(request)\n\t}\n\n\t/**\n\t * Custom handle written by adapter\n\t */\n\tprotected _handle?(...a: unknown[]): unknown\n\n\tprotected handleError = async (\n\t\tcontext: Partial<\n\t\t\tContext<\n\t\t\t\tMergeSchema<\n\t\t\t\t\tMetadata['schema'],\n\t\t\t\t\tMergeSchema<Ephemeral['schema'], Volatile['schema']>\n\t\t\t\t>,\n\t\t\t\tSingleton & {\n\t\t\t\t\tderive: Ephemeral['derive'] & Volatile['derive']\n\t\t\t\t\tresolve: Ephemeral['resolve'] & Volatile['resolve']\n\t\t\t\t},\n\t\t\t\tBasePath\n\t\t\t>\n\t\t> & {\n\t\t\trequest: Request\n\t\t},\n\t\terror:\n\t\t\t| Error\n\t\t\t| ValidationError\n\t\t\t| ParseError\n\t\t\t| NotFoundError\n\t\t\t| InternalServerError\n\t) => {\n\t\treturn (this.handleError = this.config.aot\n\t\t\t? composeErrorHandler(this)\n\t\t\t: createDynamicErrorHandler(this))(context, error)\n\t}\n\n\tprivate outerErrorHandler = (error: Error) =>\n\t\tnew Response(error.message || error.name || 'Error', {\n\t\t\t// @ts-ignore\n\t\t\tstatus: error?.status ?? 500\n\t\t})\n\n\t/**\n\t * ### listen\n\t * Assign current instance to port and start serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * new Elysia()\n\t *     .get(\"/\", () => 'hi')\n\t *     .listen(3000)\n\t * ```\n\t */\n\tlisten = (\n\t\toptions: string | number | Partial<Serve>,\n\t\tcallback?: ListenCallback\n\t) => {\n\t\tthis['~adapter'].listen(this)(options, callback)\n\n\t\treturn this\n\t}\n\n\t/**\n\t * ### stop\n\t * Stop server from serving\n\t *\n\t * ---\n\t * @example\n\t * ```typescript\n\t * const app = new Elysia()\n\t *     .get(\"/\", () => 'hi')\n\t *     .listen(3000)\n\t *\n\t * // Sometime later\n\t * app.stop()\n\t * ```\n\t *\n\t * @example\n\t * ```typescript\n\t * const app = new Elysia()\n\t *     .get(\"/\", () => 'hi')\n\t *     .listen(3000)\n\t *\n\t * app.stop(true) // Abruptly any requests inflight\n\t * ```\n\t */\n\tstop = async (closeActiveConnections?: boolean) => {\n\t\tif (!this.server)\n\t\t\tthrow new Error(\n\t\t\t\t\"Elysia isn't running. Call `app.listen` to start the server.\"\n\t\t\t)\n\n\t\tif (this.server) {\n\t\t\tthis.server.stop(closeActiveConnections)\n\t\t\tthis.server = null\n\n\t\t\tif (this.event.stop?.length)\n\t\t\t\tfor (let i = 0; i < this.event.stop.length; i++)\n\t\t\t\t\tthis.event.stop[i].fn(this)\n\t\t}\n\t}\n\n\t/**\n\t * Wait until all lazy loaded modules all load is fully\n\t */\n\tget modules() {\n\t\treturn this.promisedModules\n\t}\n}\n\nexport { Elysia }\n\nexport { t } from './type-system'\nexport { serializeCookie, Cookie, type CookieOptions } from './cookies'\nexport type { Context, PreContext, ErrorContext } from './context'\nexport {\n\tELYSIA_TRACE,\n\ttype TraceEvent,\n\ttype TraceListener,\n\ttype TraceHandler,\n\ttype TraceProcess,\n\ttype TraceStream\n} from './trace'\n\nexport {\n\tgetSchemaValidator,\n\tmergeHook,\n\tmergeObjectArray,\n\tgetResponseSchemaValidator,\n\tredirect,\n\tStatusMap,\n\tInvertedStatusMap,\n\tform,\n\treplaceSchemaType,\n\treplaceUrlPath,\n\tchecksum,\n\tcloneInference,\n\tdeduplicateChecksum,\n\tELYSIA_FORM_DATA,\n\tELYSIA_REQUEST_ID\n} from './utils'\n\nexport {\n\terror,\n\tmapValueError,\n\tParseError,\n\tNotFoundError,\n\tValidationError,\n\tInternalServerError,\n\tInvalidCookieSignature,\n\tERROR_CODE\n} from './error'\n\nexport type {\n\tEphemeralType,\n\tCreateEden,\n\tComposeElysiaResponse,\n\tElysiaConfig,\n\tSingletonBase,\n\tDefinitionBase,\n\tRouteBase,\n\tHandler,\n\tComposedHandler,\n\tInputSchema,\n\tLocalHook,\n\tMergeSchema,\n\tRouteSchema,\n\tUnwrapRoute,\n\tInternalRoute,\n\tHTTPMethod,\n\tSchemaValidator,\n\tVoidHandler,\n\tPreHandler,\n\tBodyHandler,\n\tOptionalHandler,\n\tAfterResponseHandler,\n\tErrorHandler,\n\tAfterHandler,\n\tLifeCycleEvent,\n\tLifeCycleStore,\n\tLifeCycleType,\n\tMaybePromise,\n\tUnwrapSchema,\n\tChecksum,\n\tDocumentDecoration,\n\tInferContext,\n\tInferHandler,\n\tResolvePath,\n\tMapResponse,\n\tMacroQueue,\n\tBaseMacro,\n\tMacroManager,\n\tBaseMacroFn,\n\tMacroToProperty,\n\tResolveMacroContext,\n\tMergeElysiaInstances,\n\tMaybeArray,\n\tModelValidator,\n\tMetadataBase,\n\tUnwrapBodySchema,\n\tUnwrapGroupGuardRoute,\n\tModelValidatorError,\n\tExcludeElysiaResponse,\n\tCoExist\n} from './types'\n\nexport { env } from './universal/env'\nexport { file, ElysiaFile } from './universal/file'\nexport type { ElysiaAdapter } from './adapter'\n\nexport { TypeSystemPolicy } from '@sinclair/typebox/system'\nexport type { Static, TSchema } from '@sinclair/typebox'\n",
    "import { TypeRegistry, Type, FormatRegistry, TString } from '@sinclair/typebox'\nimport {\n\tArrayOptions,\n\tDateOptions,\n\tKind,\n\tNumberOptions,\n\tTArray,\n\tTDate,\n\tTUnsafe,\n\tTInteger,\n\tIntegerOptions,\n\tUnsafe,\n\tSchemaOptions,\n\tTSchema,\n\tTProperties,\n\tObjectOptions,\n\tTObject,\n\tTNumber,\n\tTBoolean\n} from '@sinclair/typebox'\n\nimport {\n\ttype ValueError,\n\ttype TypeCheck,\n\tTypeCompiler\n} from '@sinclair/typebox/compiler'\nimport { Value } from '@sinclair/typebox/value'\nimport { fullFormats } from './formats'\n\nimport type { CookieOptions } from './cookies'\nimport { ValidationError } from './error'\nimport type { MaybeArray } from './types'\n\nconst isISO8601 =\n\t/(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d\\.\\d+([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))|(\\d{4}-[01]\\d-[0-3]\\dT[0-2]\\d:[0-5]\\d([+-][0-2]\\d:[0-5]\\d|Z))/\nconst isFormalDate =\n\t/(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)\\s(?:Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s\\d{2}\\s\\d{4}\\s\\d{2}:\\d{2}:\\d{2}\\sGMT(?:\\+|-)\\d{4}\\s\\([^)]+\\)/\nconst isShortenDate =\n\t/^(?:(?:(?:(?:0?[1-9]|[12][0-9]|3[01])[/\\s-](?:0?[1-9]|1[0-2])[/\\s-](?:19|20)\\d{2})|(?:(?:19|20)\\d{2}[/\\s-](?:0?[1-9]|1[0-2])[/\\s-](?:0?[1-9]|[12][0-9]|3[01]))))(?:\\s(?:1[012]|0?[1-9]):[0-5][0-9](?::[0-5][0-9])?(?:\\s[AP]M)?)?$/\n\nconst _validateDate = fullFormats.date\nconst _validateDateTime = fullFormats['date-time']\n\nif (!FormatRegistry.Has('date'))\n\tFormatRegistry.Set('date', (value: string) => {\n\t\t// Remove quote from stringified date\n\t\tconst temp = value.replace(/\"/g, '')\n\n\t\tif (\n\t\t\tisISO8601.test(temp) ||\n\t\t\tisFormalDate.test(temp) ||\n\t\t\tisShortenDate.test(temp) ||\n\t\t\t_validateDate(temp)\n\t\t) {\n\t\t\tconst date = new Date(temp)\n\t\t\tif (!Number.isNaN(date.getTime())) return true\n\t\t}\n\n\t\treturn false\n\t})\n\nif (!FormatRegistry.Has('date-time'))\n\tFormatRegistry.Set('date-time', (value: string) => {\n\t\t// Remove quote from stringified date\n\t\tconst temp = value.replace(/\"/g, '')\n\n\t\tif (\n\t\t\tisISO8601.test(temp) ||\n\t\t\tisFormalDate.test(temp) ||\n\t\t\tisShortenDate.test(temp) ||\n\t\t\t_validateDateTime(temp)\n\t\t) {\n\t\t\tconst date = new Date(temp)\n\t\t\tif (!Number.isNaN(date.getTime())) return true\n\t\t}\n\n\t\treturn false\n\t})\n\nObject.entries(fullFormats).forEach((formatEntry) => {\n\tconst [formatName, formatValue] = formatEntry\n\n\tif (!FormatRegistry.Has(formatName)) {\n\t\tif (formatValue instanceof RegExp)\n\t\t\tFormatRegistry.Set(formatName, (value) => formatValue.test(value))\n\t\telse if (typeof formatValue === 'function')\n\t\t\tFormatRegistry.Set(formatName, formatValue)\n\t}\n})\n\nconst t = Object.assign({}, Type)\n\nexport namespace ElysiaTypeOptions {\n\texport type Numeric = NumberOptions\n\n\texport type FileUnit = number | `${number}${'k' | 'm'}`\n\n\texport type StrictFileType =\n\t\t| 'image'\n\t\t| 'image/*'\n\t\t| 'image/jpeg'\n\t\t| 'image/png'\n\t\t| 'image/gif'\n\t\t| 'image/tiff'\n\t\t| 'image/x-icon'\n\t\t| 'image/svg'\n\t\t| 'image/webp'\n\t\t| 'image/avif'\n\t\t| 'audio'\n\t\t| 'audio/*'\n\t\t| 'audio/aac'\n\t\t| 'audio/mpeg'\n\t\t| 'audio/x-ms-wma'\n\t\t| 'audio/vnd.rn-realaudio'\n\t\t| 'audio/x-wav'\n\t\t| 'video'\n\t\t| 'video/*'\n\t\t| 'video/mpeg'\n\t\t| 'video/mp4'\n\t\t| 'video/quicktime'\n\t\t| 'video/x-ms-wmv'\n\t\t| 'video/x-msvideo'\n\t\t| 'video/x-flv'\n\t\t| 'video/webm'\n\t\t| 'text'\n\t\t| 'text/*'\n\t\t| 'text/css'\n\t\t| 'text/csv'\n\t\t| 'text/html'\n\t\t| 'text/javascript'\n\t\t| 'text/plain'\n\t\t| 'text/xml'\n\t\t| 'application'\n\t\t| 'application/*'\n\t\t| 'application/graphql'\n\t\t| 'application/graphql-response+json'\n\t\t| 'application/ogg'\n\t\t| 'application/pdf'\n\t\t| 'application/xhtml'\n\t\t| 'application/xhtml+html'\n\t\t| 'application/xml-dtd'\n\t\t| 'application/html'\n\t\t| 'application/json'\n\t\t| 'application/ld+json'\n\t\t| 'application/xml'\n\t\t| 'application/zip'\n\t\t| 'font'\n\t\t| 'font/*'\n\t\t| 'font/woff2'\n\t\t| 'font/woff'\n\t\t| 'font/ttf'\n\t\t| 'font/otf'\n\n\texport type FileType = (string & {}) | StrictFileType\n\n\texport interface File extends SchemaOptions {\n\t\ttype?: MaybeArray<FileType>\n\t\tminSize?: FileUnit\n\t\tmaxSize?: FileUnit\n\t}\n\n\texport interface Files extends File {\n\t\tminItems?: number\n\t\tmaxItems?: number\n\t}\n\n\texport interface CookieValidatorOption<T extends Object = {}>\n\t\textends ObjectOptions,\n\t\t\tCookieOptions {\n\t\t/**\n\t\t * Secret key for signing cookie\n\t\t *\n\t\t * If array is passed, will use Key Rotation.\n\t\t *\n\t\t * Key rotation is when an encryption key is retired\n\t\t * and replaced by generating a new cryptographic key.\n\t\t */\n\t\tsecrets?: string | string[]\n\t\t/**\n\t\t * Specified cookie name to be signed globally\n\t\t */\n\t\tsign?: Readonly<(keyof T | (string & {}))[]>\n\t}\n}\n\nconst parseFileUnit = (size: ElysiaTypeOptions.FileUnit) => {\n\tif (typeof size === 'string')\n\t\tswitch (size.slice(-1)) {\n\t\t\tcase 'k':\n\t\t\t\treturn +size.slice(0, size.length - 1) * 1024\n\n\t\t\tcase 'm':\n\t\t\t\treturn +size.slice(0, size.length - 1) * 1048576\n\n\t\t\tdefault:\n\t\t\t\treturn +size\n\t\t}\n\n\treturn size\n}\n\nconst checkFileExtension = (type: string, extension: string) => {\n\tif (type.startsWith(extension)) return true\n\n\treturn (\n\t\textension.charCodeAt(extension.length - 1) === 42 &&\n\t\textension.charCodeAt(extension.length - 2) === 47 &&\n\t\ttype.startsWith(extension.slice(0, -1))\n\t)\n}\n\nconst validateFile = (options: ElysiaTypeOptions.File, value: any) => {\n\tif (!(value instanceof Blob)) return false\n\n\tif (options.minSize && value.size < parseFileUnit(options.minSize))\n\t\treturn false\n\n\tif (options.maxSize && value.size > parseFileUnit(options.maxSize))\n\t\treturn false\n\n\tif (options.extension) {\n\t\tif (typeof options.extension === 'string')\n\t\t\treturn checkFileExtension(value.type, options.extension)\n\n\t\tfor (let i = 0; i < options.extension.length; i++)\n\t\t\tif (checkFileExtension(value.type, options.extension[i]))\n\t\t\t\treturn true\n\t}\n\n\treturn true\n}\n\ntype ElysiaFile = (\n\toptions?: Partial<ElysiaTypeOptions.Files> | undefined\n) => TUnsafe<File>\n\nconst File: ElysiaFile = getOrSetType<ElysiaTypeOptions.File, ElysiaFile>(\n\t'File',\n\tvalidateFile\n)\n\ntype ElysiaFiles = (\n\toptions?: Partial<ElysiaTypeOptions.Files> | undefined\n) => TUnsafe<File[]>\n\nconst Files: ElysiaFiles = getOrSetType<ElysiaTypeOptions.Files, ElysiaFiles>(\n\t'Files',\n\t(options, value) => {\n\t\tif (!Array.isArray(value)) return validateFile(options, value)\n\n\t\tif (options.minItems && value.length < options.minItems) return false\n\n\t\tif (options.maxItems && value.length > options.maxItems) return false\n\n\t\tfor (let i = 0; i < value.length; i++)\n\t\t\tif (!validateFile(options, value[i])) return false\n\n\t\treturn true\n\t}\n)\n\nif (!FormatRegistry.Has('numeric'))\n\tFormatRegistry.Set('numeric', (value) => !!value && !isNaN(+value))\n\nif (!FormatRegistry.Has('integer'))\n\tFormatRegistry.Set(\n\t\t'integer',\n\t\t(value) => !!value && Number.isInteger(+value)\n\t)\n\nif (!FormatRegistry.Has('boolean'))\n\tFormatRegistry.Set(\n\t\t'boolean',\n\t\t(value) => value === 'true' || value === 'false'\n\t)\n\nif (!FormatRegistry.Has('ObjectString'))\n\tFormatRegistry.Set('ObjectString', (value) => {\n\t\tlet start = value.charCodeAt(0)\n\n\t\t// If starts with ' ', '\\t', '\\n', then trim first\n\t\tif (start === 9 || start === 10 || start === 32)\n\t\t\tstart = value.trimStart().charCodeAt(0)\n\n\t\tif (start !== 123 && start !== 91) return false\n\n\t\ttry {\n\t\t\tJSON.parse(value)\n\n\t\t\treturn true\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t})\n\nif (!FormatRegistry.Has('ArrayString'))\n\tFormatRegistry.Set('ArrayString', (value) => {\n\t\tlet start = value.charCodeAt(0)\n\n\t\t// If starts with ' ', '\\t', '\\n', then trim first\n\t\tif (start === 9 || start === 10 || start === 32)\n\t\t\tstart = value.trimStart().charCodeAt(0)\n\n\t\tif (start !== 123 && start !== 91) return false\n\n\t\ttry {\n\t\t\tJSON.parse(value)\n\n\t\t\treturn true\n\t\t} catch {\n\t\t\treturn false\n\t\t}\n\t})\n\nif (!TypeRegistry.Has('UnionEnum'))\n\tTypeRegistry.Set<TUnionEnum>('UnionEnum', (schema, value) => {\n\t\treturn (\n\t\t\t(typeof value === 'number' ||\n\t\t\t\ttypeof value === 'string' ||\n\t\t\t\tvalue === null) &&\n\t\t\tschema.enum.includes(value as never)\n\t\t)\n\t})\n\ntype NonEmptyArray<T> = [T, ...T[]]\n\nexport type TEnumValue = number | string | null\n\nexport interface TUnionEnum<\n\tT extends\n\t\t| NonEmptyArray<TEnumValue>\n\t\t| Readonly<NonEmptyArray<TEnumValue>> = [TEnumValue]\n> extends TSchema {\n\ttype?: 'number' | 'string' | 'null'\n\t[Kind]: 'UnionEnum'\n\tstatic: T[number]\n\tenum: T\n}\n\nexport const ElysiaType = {\n\tNumeric: (property?: NumberOptions) => {\n\t\tconst schema = Type.Number(property)\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'numeric',\n\t\t\t\t\t\t\tdefault: 0\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tt.Number(property)\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tconst number = +value\n\t\t\t\tif (isNaN(number)) return value\n\n\t\t\t\tif (property && !Value.Check(schema, number))\n\t\t\t\t\tthrow new ValidationError('property', schema, number)\n\n\t\t\t\treturn number\n\t\t\t})\n\t\t\t.Encode((value) => value) as any as TNumber\n\t},\n\tInteger: (property?: IntegerOptions): TInteger => {\n\t\tconst schema = Type.Integer(property)\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'integer',\n\t\t\t\t\t\t\tdefault: 0\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tType.Integer(property)\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tconst number = +value\n\n\t\t\t\tif (!Value.Check(schema, number))\n\t\t\t\t\tthrow new ValidationError('property', schema, number)\n\n\t\t\t\treturn number\n\t\t\t})\n\t\t\t.Encode((value) => value) as any as TInteger\n\t},\n\tDate: (property?: DateOptions) => {\n\t\tconst schema = Type.Date(property)\n\t\tconst _default = property?.default\n\t\t\t? new Date(property.default) // in case the default is an ISO string or milliseconds from epoch\n\t\t\t: undefined\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tType.Date(property),\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'date',\n\t\t\t\t\t\t\tdefault: _default?.toISOString()\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'date-time',\n\t\t\t\t\t\t\tdefault: _default?.toISOString()\n\t\t\t\t\t\t}),\n\t\t\t\t\t\tt.Number({ default: _default?.getTime() })\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (typeof value === 'number') {\n\t\t\t\t\tconst date = new Date(value)\n\n\t\t\t\t\tif (!Value.Check(schema, date))\n\t\t\t\t\t\tthrow new ValidationError('property', schema, date)\n\n\t\t\t\t\treturn date\n\t\t\t\t}\n\n\t\t\t\tif (value instanceof Date) return value\n\n\t\t\t\tconst date = new Date(value)\n\n\t\t\t\tif (!Value.Check(schema, date))\n\t\t\t\t\tthrow new ValidationError('property', schema, date)\n\n\t\t\t\treturn date\n\t\t\t})\n\t\t\t.Encode((value) => {\n\t\t\t\tif (typeof value === 'string') return new Date(value)\n\n\t\t\t\treturn value\n\t\t\t}) as any as TDate\n\t},\n\tBooleanString: (property?: SchemaOptions) => {\n\t\tconst schema = Type.Boolean(property)\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union(\n\t\t\t\t\t[\n\t\t\t\t\t\tt.Boolean(property),\n\t\t\t\t\t\tt.String({\n\t\t\t\t\t\t\tformat: 'boolean',\n\t\t\t\t\t\t\tdefault: false\n\t\t\t\t\t\t})\n\t\t\t\t\t],\n\t\t\t\t\tproperty\n\t\t\t\t)\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (typeof value === 'string') return value === 'true'\n\n\t\t\t\tif (value !== undefined && !Value.Check(schema, value))\n\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\treturn value\n\t\t\t})\n\t\t\t.Encode((value) => value) as any as TBoolean\n\t},\n\tObjectString: <T extends TProperties>(\n\t\tproperties: T,\n\t\toptions?: ObjectOptions\n\t) => {\n\t\tconst schema = t.Object(properties, options)\n\t\tconst defaultValue = JSON.stringify(Value.Create(schema))\n\n\t\tlet compiler: TypeCheck<TObject<T>>\n\t\ttry {\n\t\t\tcompiler = TypeCompiler.Compile(schema)\n\t\t} catch {\n\t\t\t// Nothing\n\t\t}\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union([\n\t\t\t\t\tt.String({\n\t\t\t\t\t\tformat: 'ObjectString',\n\t\t\t\t\t\tdefault: defaultValue\n\t\t\t\t\t}),\n\t\t\t\t\tschema\n\t\t\t\t])\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (typeof value === 'string') {\n\t\t\t\t\tif (value.charCodeAt(0) !== 123)\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvalue = JSON.parse(value as string)\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\t\t\t\t\t}\n\n\t\t\t\t\tif (compiler) {\n\t\t\t\t\t\tif (!compiler.Check(value))\n\t\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\t\t\treturn compiler.Decode(value)\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!Value.Check(schema, value))\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\t\treturn Value.Decode(schema, value)\n\t\t\t\t}\n\n\t\t\t\treturn value\n\t\t\t})\n\t\t\t.Encode((value) => {\n\t\t\t\tif (typeof value === 'string')\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvalue = JSON.parse(value as string)\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\t\t\t\t\t}\n\n\t\t\t\tif (!Value.Check(schema, value))\n\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\treturn JSON.stringify(value)\n\t\t\t}) as any as TObject<T>\n\t},\n\tArrayString: <T extends TSchema = TString>(\n\t\tchildren: T = t.String() as any,\n\t\toptions?: ArrayOptions\n\t) => {\n\t\tconst schema = t.Array(children, options)\n\t\tconst defaultValue = JSON.stringify(Value.Create(schema))\n\n\t\tlet compiler: TypeCheck<TArray<T>>\n\t\ttry {\n\t\t\tcompiler = TypeCompiler.Compile(schema)\n\t\t} catch {\n\t\t\t// Nothing\n\t\t}\n\n\t\tconst decode = (value: string, isProperty = false) => {\n\t\t\tif (value.charCodeAt(0) === 91) {\n\t\t\t\ttry {\n\t\t\t\t\tvalue = JSON.parse(value as string)\n\t\t\t\t} catch {\n\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\t\t\t\t}\n\n\t\t\t\tif (compiler) {\n\t\t\t\t\tif (!compiler.Check(value))\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\t\treturn compiler.Decode(value)\n\t\t\t\t}\n\n\t\t\t\tif (!Value.Check(schema, value))\n\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\treturn Value.Decode(schema, value)\n\t\t\t}\n\n\t\t\t// has , (as used in nuqs)\n\t\t\tif (value.indexOf(',') !== -1) {\n\t\t\t\tconst newValue = value.split(',').map((v) => v.trim())\n\n\t\t\t\tif (compiler) {\n\t\t\t\t\tif (!compiler.Check(newValue))\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\t\treturn compiler.Decode(newValue)\n\t\t\t\t}\n\n\t\t\t\tif (!Value.Check(schema, newValue))\n\t\t\t\t\tthrow new ValidationError('property', schema, newValue)\n\n\t\t\t\treturn Value.Decode(schema, newValue)\n\t\t\t}\n\n\t\t\tif (isProperty) return value\n\n\t\t\tthrow new ValidationError('property', schema, value)\n\t\t}\n\n\t\treturn t\n\t\t\t.Transform(\n\t\t\t\tt.Union([\n\t\t\t\t\tt.String({\n\t\t\t\t\t\tformat: 'ArrayString',\n\t\t\t\t\t\tdefault: defaultValue\n\t\t\t\t\t}),\n\t\t\t\t\tschema\n\t\t\t\t])\n\t\t\t)\n\t\t\t.Decode((value) => {\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tlet values = <unknown[]>[]\n\n\t\t\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\t\t\tconst v = value[i]\n\t\t\t\t\t\tif (typeof v === 'string') {\n\t\t\t\t\t\t\tconst t = decode(v, true)\n\t\t\t\t\t\t\tif (Array.isArray(t)) values = values.concat(t)\n\t\t\t\t\t\t\telse values.push(t)\n\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvalues.push(v)\n\t\t\t\t\t}\n\n\t\t\t\t\treturn values\n\t\t\t\t}\n\n\t\t\t\tif (typeof value === 'string') return decode(value)\n\n\t\t\t\tthrow new ValidationError('property', schema, value)\n\t\t\t})\n\t\t\t.Encode((value) => {\n\t\t\t\tif (typeof value === 'string')\n\t\t\t\t\ttry {\n\t\t\t\t\t\tvalue = JSON.parse(value as string)\n\t\t\t\t\t} catch {\n\t\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\t\t\t\t\t}\n\n\t\t\t\tif (!Value.Check(schema, value))\n\t\t\t\t\tthrow new ValidationError('property', schema, value)\n\n\t\t\t\treturn JSON.stringify(value)\n\t\t\t}) as any as TArray<T>\n\t},\n\tFile,\n\tFiles: (options: ElysiaTypeOptions.Files = {}) =>\n\t\tt\n\t\t\t.Transform(Files(options))\n\t\t\t.Decode((value) => {\n\t\t\t\tif (Array.isArray(value)) return value\n\t\t\t\treturn [value]\n\t\t\t})\n\t\t\t.Encode((value) => value),\n\tNullable: <T extends TSchema>(schema: T, options?: SchemaOptions) =>\n\t\tt.Union([schema, t.Null()], options),\n\t/**\n\t * Allow Optional, Nullable and Undefined\n\t */\n\tMaybeEmpty: <T extends TSchema>(schema: T, options?: SchemaOptions) =>\n\t\tt.Union([schema, t.Null(), t.Undefined()], options),\n\tCookie: <T extends TProperties>(\n\t\tproperties: T,\n\t\t{\n\t\t\tdomain,\n\t\t\texpires,\n\t\t\thttpOnly,\n\t\t\tmaxAge,\n\t\t\tpath,\n\t\t\tpriority,\n\t\t\tsameSite,\n\t\t\tsecure,\n\t\t\tsecrets,\n\t\t\tsign,\n\t\t\t...options\n\t\t}: ElysiaTypeOptions.CookieValidatorOption<T> = {}\n\t) => {\n\t\tconst v = t.Object(properties, options)\n\n\t\tv.config = {\n\t\t\tdomain,\n\t\t\texpires,\n\t\t\thttpOnly,\n\t\t\tmaxAge,\n\t\t\tpath,\n\t\t\tpriority,\n\t\t\tsameSite,\n\t\t\tsecure,\n\t\t\tsecrets,\n\t\t\tsign\n\t\t}\n\n\t\treturn v\n\t},\n\t// based on https://github.com/elysiajs/elysia/issues/512#issuecomment-1980134955\n\tUnionEnum: <\n\t\tconst T extends\n\t\t\t| NonEmptyArray<TEnumValue>\n\t\t\t| Readonly<NonEmptyArray<TEnumValue>>\n\t>(\n\t\tvalues: T,\n\t\toptions: SchemaOptions = {}\n\t) => {\n\t\tconst type = values.every((value) => typeof value === 'string')\n\t\t\t? { type: 'string' }\n\t\t\t: values.every((value) => typeof value === 'number')\n\t\t\t\t? { type: 'number' }\n\t\t\t\t: values.every((value) => value === null)\n\t\t\t\t\t? { type: 'null' }\n\t\t\t\t\t: {}\n\n\t\tif (values.some((x) => typeof x === 'object' && x !== null))\n\t\t\tthrow new Error('This type does not support objects or arrays')\n\n\t\treturn {\n\t\t\t// why it need default??\n\t\t\tdefault: values[0],\n\t\t\t...options,\n\t\t\t[Kind]: 'UnionEnum',\n\t\t\t...type,\n\t\t\tenum: values\n\t\t} as any as TUnionEnum<T>\n\t}\n} as const\n\nexport type TCookie = (typeof ElysiaType)['Cookie']\n\ndeclare module '@sinclair/typebox' {\n\tinterface JavaScriptTypeBuilder {\n\t\tBooleanString: typeof ElysiaType.BooleanString\n\t\tObjectString: typeof ElysiaType.ObjectString\n\t\tArrayString: typeof ElysiaType.ArrayString\n\t\tNumeric: typeof ElysiaType.Numeric\n\t\tInteger: typeof ElysiaType.Integer\n\t\tFile: typeof ElysiaType.File\n\t\tFiles: typeof ElysiaType.Files\n\t\tNullable: typeof ElysiaType.Nullable\n\t\tMaybeEmpty: typeof ElysiaType.MaybeEmpty\n\t\tCookie: typeof ElysiaType.Cookie\n\t\tUnionEnum: typeof ElysiaType.UnionEnum\n\t}\n\n\tinterface SchemaOptions {\n\t\terror?:\n\t\t\t| string\n\t\t\t| boolean\n\t\t\t| number\n\t\t\t| Object\n\t\t\t| ((validation: {\n\t\t\t\t\terrors: ValueError[]\n\t\t\t\t\ttype: string\n\t\t\t\t\tvalidator: TypeCheck<any>\n\t\t\t\t\tvalue: unknown\n\t\t\t  }) => string | boolean | number | Object | void)\n\t}\n}\n\n/**\n * A Boolean string\n *\n * Will be parsed to a Boolean\n */\nt.BooleanString = ElysiaType.BooleanString\nt.ObjectString = ElysiaType.ObjectString\nt.ArrayString = ElysiaType.ArrayString\n\n/**\n * A Numeric string\n *\n * Will be parsed to a Number\n */\nt.Numeric = ElysiaType.Numeric\nt.Integer = ElysiaType.Integer\n\nt.File = (arg = {}) =>\n\tElysiaType.File({\n\t\tdefault: 'File',\n\t\t...arg,\n\t\textension: arg?.type,\n\t\ttype: 'string',\n\t\tformat: 'binary'\n\t})\n\nt.Files = (arg = {}) =>\n\tElysiaType.Files({\n\t\t...arg,\n\t\telysiaMeta: 'Files',\n\t\tdefault: 'Files',\n\t\textension: arg?.type,\n\t\ttype: 'array',\n\t\titems: {\n\t\t\t...arg,\n\t\t\tdefault: 'Files',\n\t\t\ttype: 'string',\n\t\t\tformat: 'binary'\n\t\t}\n\t})\n\n// t.Ref = <T extends TSchema>(schema: T) =>\n// \tType.Unsafe<Static<T>>(Type.Ref(schema.$id!))\n\nt.Nullable = (schema) => ElysiaType.Nullable(schema)\nt.MaybeEmpty = ElysiaType.MaybeEmpty as any\n\nt.Cookie = ElysiaType.Cookie\nt.Date = ElysiaType.Date\n\nt.UnionEnum = ElysiaType.UnionEnum\n\nfunction getOrSetType<TSchema = unknown, TReturn = unknown>(\n\tkind: string,\n\tfunc: TypeRegistry.TypeRegistryValidationFunction<TSchema>\n): TReturn {\n\tif (!TypeRegistry.Has(kind)) {\n\t\tTypeRegistry.Set<TSchema>(kind, func)\n\t}\n\n\treturn ((options = {}) =>\n\t\tUnsafe({ ...options, [Kind]: kind })) as unknown as TReturn\n}\n\nexport { t }\n\nexport {\n\tTypeSystemPolicy,\n\tTypeSystem,\n\tTypeSystemDuplicateFormat,\n\tTypeSystemDuplicateTypeKind\n} from '@sinclair/typebox/system'\nexport { TypeRegistry, FormatRegistry } from '@sinclair/typebox'\nexport { TypeCompiler, TypeCheck } from '@sinclair/typebox/compiler'\n\n// type Template =\n// \t| string\n// \t| number\n// \t| bigint\n// \t| boolean\n// \t| StringConstructor\n// \t| NumberConstructor\n// \t| undefined\n\n// type Join<A> = A extends Readonly<[infer First, ...infer Rest]>\n// \t? (\n// \t\t\tFirst extends Readonly<Template[]>\n// \t\t\t\t? First[number]\n// \t\t\t\t: First extends StringConstructor\n// \t\t\t\t? string\n// \t\t\t\t: First extends NumberConstructor\n// \t\t\t\t? `${number}`\n// \t\t\t\t: First\n// \t  ) extends infer A\n// \t\t? Rest extends []\n// \t\t\t? A extends undefined\n// \t\t\t\t? NonNullable<A> | ''\n// \t\t\t\t: A\n// \t\t\t: // @ts-ignore\n// \t\t\tA extends undefined\n// \t\t\t? `${NonNullable<A>}${Join<Rest>}` | ''\n// \t\t\t: // @ts-ignore\n// \t\t\t  `${A}${Join<Rest>}`\n// \t\t: ''\n// \t: ''\n\n// const template = <\n// \tconst T extends Readonly<(Template | Readonly<Template[]>)[]>\n// >(\n// \t...p: T\n// ): Join<T> => {\n// \treturn a as any\n// }\n\n// const create =\n// \t<const T extends string>(t: T): ((t: T) => void) =>\n// \t(t) =>\n// \t\tt\n\n// const optional = <\n// \tconst T extends Readonly<(Template | Readonly<Template[]>)[]>\n// >(\n// \t...p: T\n// ): T | undefined => {\n// \treturn undefined\n// }\n\n// template.optional = optional\n\n// const hi = create(\n// \ttemplate(\n// \t\t['seminar', 'millennium'],\n// \t\t':',\n// \t\t['Rio', 'Yuuka', 'Noa', 'Koyuki'],\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki'])),\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki'])),\n// \t\ttemplate.optional(template(',', ['Rio', 'Yuuka', 'Noa', 'Koyuki']))\n// \t)\n// )\n\n// hi(`seminar:Noa,Koyuki,Yuuka`)\n\n// const a = TypeCompiler.Compile(t.String())\n\n// console.log(v.Decode.toString())\n\n// const T = t.Transform(v.schema)\n// \t.Decode((value) => new Date(value)) // required: number to Date\n// \t.Encode((value) => value.getTime()) // required: Date to number\n\n// const decoded = Value.Decode(T, 0) // const decoded = Date(1970-01-01T00:00:00.000Z)\n// const encoded = Value.Encode(T, decoded)\n",
    "/**\n * ? Fork of ajv-formats without ajv as dependencies\n *\n * @see https://github.com/ajv-validator/ajv-formats/blob/master/src/formats.ts\n **/\n\n/* eslint-disable no-control-regex */\nexport type FormatName =\n\t| 'date'\n\t| 'time'\n\t| 'date-time'\n\t| 'iso-time'\n\t| 'iso-date-time'\n\t| 'duration'\n\t| 'uri'\n\t| 'uri-reference'\n\t| 'uri-template'\n\t| 'url'\n\t| 'email'\n\t| 'hostname'\n\t| 'ipv4'\n\t| 'ipv6'\n\t| 'regex'\n\t| 'uuid'\n\t| 'json-pointer'\n\t| 'json-pointer-uri-fragment'\n\t| 'relative-json-pointer'\n\t| 'byte'\n\t| 'int32'\n\t| 'int64'\n\t| 'float'\n\t| 'double'\n\t| 'password'\n\t| 'binary'\n\nexport const fullFormats = {\n\t// date: http://tools.ietf.org/html/rfc3339#section-5.6\n\tdate,\n\t// date-time: http://tools.ietf.org/html/rfc3339#section-5.6\n\ttime: getTime(true),\n\t'date-time': getDateTime(true),\n\t'iso-time': getTime(false),\n\t'iso-date-time': getDateTime(false),\n\t// duration: https://tools.ietf.org/html/rfc3339#appendix-A\n\tduration:\n\t\t/^P(?!$)((\\d+Y)?(\\d+M)?(\\d+D)?(T(?=\\d)(\\d+H)?(\\d+M)?(\\d+S)?)?|(\\d+W)?)$/,\n\turi,\n\t'uri-reference':\n\t\t/^(?:[a-z][a-z0-9+\\-.]*:)?(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'\"()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'\"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\\?(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'\"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,\n\t// uri-template: https://tools.ietf.org/html/rfc6570\n\t'uri-template':\n\t\t/^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i,\n\t// For the source: https://gist.github.com/dperini/729294\n\t// For test cases: https://mathiasbynens.be/demo/url-regex\n\turl: /^(?:https?|ftp):\\/\\/(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1,3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)(?:\\.(?:[a-z0-9\\u{00a1}-\\u{ffff}]+-)*[a-z0-9\\u{00a1}-\\u{ffff}]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu,\n\temail: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,\n\thostname:\n\t\t/^(?=.{1,253}\\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\\.?$/i,\n\t// optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n\tipv4: /^(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)$/,\n\tipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))$/i,\n\tregex,\n\t// uuid: http://tools.ietf.org/html/rfc4122\n\tuuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,\n\t// JSON-pointer: https://tools.ietf.org/html/rfc6901\n\t// uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n\t'json-pointer': /^(?:\\/(?:[^~/]|~0|~1)*)*$/,\n\t'json-pointer-uri-fragment':\n\t\t/^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,\n\t// relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00\n\t'relative-json-pointer': /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/,\n\t// the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types\n\t// byte: https://github.com/miguelmota/is-base64\n\tbyte,\n\t// signed 32 bit integer\n\tint32: { type: 'number', validate: validateInt32 },\n\t// signed 64 bit integer\n\tint64: { type: 'number', validate: validateInt64 },\n\t// C-type float\n\tfloat: { type: 'number', validate: validateNumber },\n\t// C-type double\n\tdouble: { type: 'number', validate: validateNumber },\n\t// hint to the UI to hide input strings\n\tpassword: true,\n\t// unchecked string payload\n\tbinary: true\n} as const\n\nfunction isLeapYear(year: number): boolean {\n\t// https://tools.ietf.org/html/rfc3339#appendix-C\n\treturn year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0)\n}\n\nconst DATE = /^(\\d\\d\\d\\d)-(\\d\\d)-(\\d\\d)$/\nconst DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\nfunction date(str: string): boolean {\n\t// full-date from http://tools.ietf.org/html/rfc3339#section-5.6\n\tconst matches: string[] | null = DATE.exec(str)\n\tif (!matches) return false\n\tconst year: number = +matches[1]\n\tconst month: number = +matches[2]\n\tconst day: number = +matches[3]\n\treturn (\n\t\tmonth >= 1 &&\n\t\tmonth <= 12 &&\n\t\tday >= 1 &&\n\t\tday <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month])\n\t)\n}\n\nconst TIME = /^(\\d\\d):(\\d\\d):(\\d\\d(?:\\.\\d+)?)(z|([+-])(\\d\\d)(?::?(\\d\\d))?)?$/i\n\nfunction getTime(strictTimeZone?: boolean): (str: string) => boolean {\n\treturn function time(str: string): boolean {\n\t\tconst matches: string[] | null = TIME.exec(str)\n\t\tif (!matches) return false\n\t\tconst hr: number = +matches[1]\n\t\tconst min: number = +matches[2]\n\t\tconst sec: number = +matches[3]\n\t\tconst tz: string | undefined = matches[4]\n\t\tconst tzSign: number = matches[5] === '-' ? -1 : 1\n\t\tconst tzH: number = +(matches[6] || 0)\n\t\tconst tzM: number = +(matches[7] || 0)\n\t\tif (tzH > 23 || tzM > 59 || (strictTimeZone && !tz)) return false\n\t\tif (hr <= 23 && min <= 59 && sec < 60) return true\n\t\t// leap second\n\t\tconst utcMin = min - tzM * tzSign\n\t\tconst utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0)\n\t\treturn (\n\t\t\t(utcHr === 23 || utcHr === -1) &&\n\t\t\t(utcMin === 59 || utcMin === -1) &&\n\t\t\tsec < 61\n\t\t)\n\t}\n}\n\nconst DATE_TIME_SEPARATOR = /t|\\s/i\nfunction getDateTime(strictTimeZone?: boolean): (str: string) => boolean {\n\tconst time = getTime(strictTimeZone)\n\n\treturn function date_time(str: string): boolean {\n\t\t// http://tools.ietf.org/html/rfc3339#section-5.6\n\t\tconst dateTime: string[] = str.split(DATE_TIME_SEPARATOR)\n\t\treturn dateTime.length === 2 && date(dateTime[0]) && time(dateTime[1])\n\t}\n}\n\nconst NOT_URI_FRAGMENT = /\\/|:/\nconst URI =\n\t/^(?:[a-z][a-z0-9+\\-.]*:)(?:\\/?\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\\.[a-z0-9\\-._~!$&'()*+,;=:]+)\\]|(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)|(?:[a-z0-9\\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\\d*)?(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\\/(?:(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\\/(?:[a-z0-9\\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\\?(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i\n\nfunction uri(str: string): boolean {\n\t// http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required \".\"\n\treturn NOT_URI_FRAGMENT.test(str) && URI.test(str)\n}\n\nconst BYTE =\n\t/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm\n\nfunction byte(str: string): boolean {\n\tBYTE.lastIndex = 0\n\treturn BYTE.test(str)\n}\n\nconst MIN_INT32 = -(2 ** 31)\nconst MAX_INT32 = 2 ** 31 - 1\n\nfunction validateInt32(value: number): boolean {\n\treturn Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32\n}\n\nfunction validateInt64(value: number): boolean {\n\t// JSON and javascript max Int is 2**53, so any int that passes isInteger is valid for Int64\n\treturn Number.isInteger(value)\n}\n\nfunction validateNumber(): boolean {\n\treturn true\n}\n\nconst Z_ANCHOR = /[^\\\\]\\\\Z/\nfunction regex(str: string): boolean {\n\tif (Z_ANCHOR.test(str)) return false\n\ttry {\n\t\tnew RegExp(str)\n\t\treturn true\n\t} catch (e) {\n\t\treturn false\n\t}\n}\n\n/**\n * @license\n * \n * MIT License\n * \n * Copyright (c) 2020 Evgeny Poberezkin\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n",
    "import type { TSchema } from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport type { TypeCheck, ValueError } from '@sinclair/typebox/compiler'\n\nimport { StatusMap, InvertedStatusMap } from './utils'\n\n// ? Cloudflare worker support\nconst env =\n\ttypeof Bun !== 'undefined'\n\t\t? Bun.env\n\t\t: typeof process !== 'undefined'\n\t\t\t? process?.env\n\t\t\t: undefined\n\nexport const ERROR_CODE = Symbol('ElysiaErrorCode')\nexport type ERROR_CODE = typeof ERROR_CODE\n\nexport const isProduction = (env?.NODE_ENV ?? env?.ENV) === 'production'\n\nexport type ElysiaErrors =\n\t| InternalServerError\n\t| NotFoundError\n\t| ParseError\n\t| ValidationError\n\t| InvalidCookieSignature\n\nexport class ElysiaCustomStatusResponse<\n\tconst Code extends number | keyof StatusMap,\n\tconst T = Code extends keyof InvertedStatusMap\n\t\t? InvertedStatusMap[Code]\n\t\t: Code,\n\tconst Status extends Code extends keyof StatusMap\n\t\t? StatusMap[Code]\n\t\t: Code = Code extends keyof StatusMap ? StatusMap[Code] : Code\n> {\n\tcode: Status\n\tresponse: T\n\n\tconstructor(code: Code, response: T) {\n\t\tconst res =\n\t\t\tresponse ??\n\t\t\t(code in InvertedStatusMap\n\t\t\t\t? // @ts-expect-error Always correct\n\t\t\t\t\tInvertedStatusMap[code]\n\t\t\t\t: code)\n\n\t\t// @ts-ignore Trust me bro\n\t\tthis.code = StatusMap[code] ?? code\n\t\tthis.response = res\n\t}\n}\n\nexport const error = <\n\tconst Code extends number | keyof StatusMap,\n\tconst T = Code extends keyof InvertedStatusMap\n\t\t? InvertedStatusMap[Code]\n\t\t: Code\n>(\n\tcode: Code,\n\tresponse?: T\n) => new ElysiaCustomStatusResponse<Code, T>(code, response as any)\n\nexport class InternalServerError extends Error {\n\tcode = 'INTERNAL_SERVER_ERROR'\n\tstatus = 500\n\n\tconstructor(message?: string) {\n\t\tsuper(message ?? 'INTERNAL_SERVER_ERROR')\n\t}\n}\n\nexport class NotFoundError extends Error {\n\tcode = 'NOT_FOUND'\n\tstatus = 404\n\n\tconstructor(message?: string) {\n\t\tsuper(message ?? 'NOT_FOUND')\n\t}\n}\n\nexport class ParseError extends Error {\n\tcode = 'PARSE'\n\tstatus = 400\n\n\tconstructor() {\n\t\tsuper('Bad Request')\n\t}\n}\n\nexport class InvalidCookieSignature extends Error {\n\tcode = 'INVALID_COOKIE_SIGNATURE'\n\tstatus = 400\n\n\tconstructor(\n\t\tpublic key: string,\n\t\tmessage?: string\n\t) {\n\t\tsuper(message ?? `\"${key}\" has invalid cookie signature`)\n\t}\n}\n\nexport const mapValueError = (error: ValueError | undefined) => {\n\tif (!error)\n\t\treturn {\n\t\t\tsummary: undefined\n\t\t}\n\n\tconst { message, path, value, type } = error\n\n\tconst property = path.slice(1).replaceAll('/', '.')\n\tconst isRoot = path === ''\n\n\tswitch (type) {\n\t\tcase 42:\n\t\t\treturn {\n\t\t\t\t...error,\n\t\t\t\tsummary: isRoot\n\t\t\t\t\t? `Value should not be provided`\n\t\t\t\t\t: `Property '${property}' should not be provided`\n\t\t\t}\n\n\t\tcase 45:\n\t\t\treturn {\n\t\t\t\t...error,\n\t\t\t\tsummary: isRoot\n\t\t\t\t\t? `Value is missing`\n\t\t\t\t\t: `Property '${property}' is missing`\n\t\t\t}\n\n\t\tcase 50:\n\t\t\t// Expected string to match 'email' format\n\t\t\tconst quoteIndex = message.indexOf(\"'\")!\n\t\t\tconst format = message.slice(\n\t\t\t\tquoteIndex + 1,\n\t\t\t\tmessage.indexOf(\"'\", quoteIndex + 1)\n\t\t\t)\n\n\t\t\treturn {\n\t\t\t\t...error,\n\t\t\t\tsummary: isRoot\n\t\t\t\t\t? `Value should be an email`\n\t\t\t\t\t: `Property '${property}' should be ${format}`\n\t\t\t}\n\n\t\tcase 54:\n\t\t\treturn {\n\t\t\t\t...error,\n\t\t\t\tsummary: `${message.slice(\n\t\t\t\t\t0,\n\t\t\t\t\t9\n\t\t\t\t)} property '${property}' to be ${message.slice(\n\t\t\t\t\t8\n\t\t\t\t)} but found: ${value}`\n\t\t\t}\n\n\t\tcase 62:\n\t\t\tconst union = error.schema.anyOf\n\t\t\t\t.map((x: Record<string, unknown>) => `'${x?.format ?? x.type}'`)\n\t\t\t\t.join(', ')\n\n\t\t\treturn {\n\t\t\t\t...error,\n\t\t\t\tsummary: isRoot\n\t\t\t\t\t? `Value should be one of ${union}`\n\t\t\t\t\t: `Property '${property}' should be one of: ${union}`\n\t\t\t}\n\n\t\tdefault:\n\t\t\treturn { summary: message, ...error }\n\t}\n}\n\nexport class ValidationError extends Error {\n\tcode = 'VALIDATION'\n\tstatus = 422\n\n\tconstructor(\n\t\tpublic type: string,\n\t\tpublic validator: TSchema | TypeCheck<any>,\n\t\tpublic value: unknown\n\t) {\n\t\tif (\n\t\t\tvalue &&\n\t\t\ttypeof value === 'object' &&\n\t\t\tvalue instanceof ElysiaCustomStatusResponse\n\t\t)\n\t\t\tvalue = value.response\n\n\t\tconst error = isProduction\n\t\t\t? undefined\n\t\t\t: 'Errors' in validator\n\t\t\t\t? validator.Errors(value).First()\n\t\t\t\t: Value.Errors(validator, value).First()\n\n\t\tconst customError =\n\t\t\terror?.schema?.message || error?.schema?.error !== undefined\n\t\t\t\t? typeof error.schema.error === 'function'\n\t\t\t\t\t? error.schema.error({\n\t\t\t\t\t\t\ttype,\n\t\t\t\t\t\t\tvalidator,\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\tget errors() {\n\t\t\t\t\t\t\t\treturn [...validator.Errors(value)].map(\n\t\t\t\t\t\t\t\t\tmapValueError\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})\n\t\t\t\t\t: error.schema.error\n\t\t\t\t: undefined\n\n\t\tconst accessor = error?.path || 'root'\n\t\tlet message = ''\n\n\t\tif (customError !== undefined) {\n\t\t\tmessage =\n\t\t\t\ttypeof customError === 'object'\n\t\t\t\t\t? JSON.stringify(customError)\n\t\t\t\t\t: customError + ''\n\t\t} else if (isProduction) {\n\t\t\tmessage = JSON.stringify({\n\t\t\t\ttype: 'validation',\n\t\t\t\ton: type,\n\t\t\t\tsummary: mapValueError(error).summary,\n\t\t\t\tmessage: error?.message,\n\t\t\t\tfound: value\n\t\t\t})\n\t\t} else {\n\t\t\t// @ts-ignore private field\n\t\t\tconst schema = validator?.schema ?? validator\n\t\t\tconst errors =\n\t\t\t\t'Errors' in validator\n\t\t\t\t\t? [...validator.Errors(value)].map(mapValueError)\n\t\t\t\t\t: [...Value.Errors(validator, value)].map(mapValueError)\n\n\t\t\tlet expected\n\n\t\t\ttry {\n\t\t\t\texpected = Value.Create(schema)\n\t\t\t} catch (error) {\n\t\t\t\texpected = {\n\t\t\t\t\ttype: 'Could not create expected value',\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tmessage: error?.message,\n\t\t\t\t\terror\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmessage = JSON.stringify(\n\t\t\t\t{\n\t\t\t\t\ttype: 'validation',\n\t\t\t\t\ton: type,\n\t\t\t\t\tsummary: mapValueError(error).summary,\n\t\t\t\t\tproperty: accessor,\n\t\t\t\t\tmessage: error?.message,\n\t\t\t\t\texpected,\n\t\t\t\t\tfound: value,\n\t\t\t\t\terrors\n\t\t\t\t},\n\t\t\t\tnull,\n\t\t\t\t2\n\t\t\t)\n\t\t}\n\n\t\tsuper(message)\n\n\t\tObject.setPrototypeOf(this, ValidationError.prototype)\n\t}\n\n\tget all() {\n\t\treturn 'Errors' in this.validator\n\t\t\t? [...this.validator.Errors(this.value)].map(mapValueError)\n\t\t\t: // @ts-ignore\n\t\t\t\t[...Value.Errors(this.validator, this.value)].map(mapValueError)\n\t}\n\n\tstatic simplifyModel(validator: TSchema | TypeCheck<any>) {\n\t\t// @ts-ignore\n\t\tconst model = 'schema' in validator ? validator.schema : validator\n\n\t\ttry {\n\t\t\treturn Value.Create(model)\n\t\t} catch {\n\t\t\treturn model\n\t\t}\n\t}\n\n\tget model() {\n\t\treturn ValidationError.simplifyModel(this.validator)\n\t}\n\n\ttoResponse(headers?: Record<string, any>) {\n\t\treturn new Response(this.message, {\n\t\t\tstatus: 400,\n\t\t\theaders: {\n\t\t\t\t...headers,\n\t\t\t\t'content-type': 'application/json'\n\t\t\t}\n\t\t})\n\t}\n}\n",
    "import type { BunFile } from 'bun'\nimport {\n\tKind,\n\tTAnySchema,\n\tTModule,\n\tTransformKind,\n\ttype TSchema\n} from '@sinclair/typebox'\nimport { Value } from '@sinclair/typebox/value'\nimport { TypeCheck, TypeCompiler } from '@sinclair/typebox/compiler'\n\nimport { t } from './type-system'\nimport type { Sucrose } from './sucrose'\n\nimport type { TraceHandler } from './trace'\nimport type {\n\tLifeCycleStore,\n\tMaybeArray,\n\tInputSchema,\n\tBaseMacro,\n\tLifeCycleType,\n\tHookContainer,\n\tGracefulHandler,\n\tPreHandler,\n\tBodyHandler,\n\tTransformHandler,\n\tOptionalHandler,\n\tAfterHandler,\n\tMapResponse,\n\tErrorHandler,\n\tReplace,\n\tAfterResponseHandler,\n\tSchemaValidator,\n\tAnyLocalHook\n} from './types'\nimport type { CookieOptions } from './cookies'\nimport { mapValueError } from './error'\n\nexport const hasHeaderShorthand = 'toJSON' in new Headers()\n\nexport const replaceUrlPath = (url: string, pathname: string) => {\n\tconst urlObject = new URL(url)\n\turlObject.pathname = pathname\n\treturn urlObject.toString()\n}\n\nexport const isClass = (v: Object) =>\n\t(typeof v === 'function' && /^\\s*class\\s+/.test(v.toString())) ||\n\t// Handle Object.create(null)\n\t(v.toString &&\n\t\t// Handle import * as Sentry from '@sentry/bun'\n\t\t// This also handle [object Date], [object Array]\n\t\t// and FFI value like [object Prisma]\n\t\tv.toString().startsWith('[object ') &&\n\t\tv.toString() !== '[object Object]') ||\n\t// If object prototype is not pure, then probably a class-like object\n\tisNotEmpty(Object.getPrototypeOf(v))\n\nconst isObject = (item: any): item is Object =>\n\titem && typeof item === 'object' && !Array.isArray(item)\n\nexport const mergeDeep = <\n\tA extends Record<string, any>,\n\tB extends Record<string, any>\n>(\n\ttarget: A,\n\tsource: B,\n\t{\n\t\tskipKeys,\n\t\toverride = true\n\t}: {\n\t\tskipKeys?: string[]\n\t\toverride?: boolean\n\t} = {}\n): A & B => {\n\tif (!isObject(target) || !isObject(source)) return target as A & B\n\n\tfor (const [key, value] of Object.entries(source)) {\n\t\tif (skipKeys?.includes(key)) continue\n\n\t\tif (!isObject(value) || !(key in target) || isClass(value)) {\n\t\t\tif (override || !(key in target))\n\t\t\t\ttarget[key as keyof typeof target] = value\n\n\t\t\tcontinue\n\t\t}\n\n\t\ttarget[key as keyof typeof target] = mergeDeep(\n\t\t\t(target as any)[key] as any,\n\t\t\tvalue,\n\t\t\t{ skipKeys, override }\n\t\t)\n\t}\n\n\treturn target as A & B\n}\nexport const mergeCookie = <const A extends Object, const B extends Object>(\n\ta: A,\n\tb: B\n): A & B => {\n\tconst v = mergeDeep(Object.assign({}, a), b, {\n\t\tskipKeys: ['properties']\n\t}) as A & B\n\n\tif ('properties' in v) delete v.properties\n\n\treturn v\n}\n\nexport const mergeObjectArray = <T extends HookContainer>(\n\ta: T | T[] = [],\n\tb: T | T[] = []\n): T[] | undefined => {\n\tif (!a) return undefined\n\tif (!b) return a as any\n\n\t// ! Must copy to remove side-effect\n\tconst array = <T[]>[]\n\tconst checksums = <(number | undefined)[]>[]\n\n\tif (!Array.isArray(a)) a = [a]\n\tif (!Array.isArray(b)) b = [b]\n\n\tfor (const item of a) {\n\t\tarray.push(item)\n\n\t\tif (item.checksum) checksums.push(item.checksum)\n\t}\n\n\tfor (const item of b)\n\t\tif (!checksums.includes(item.checksum)) array.push(item)\n\n\treturn array\n}\n\nexport const primitiveHooks = [\n\t'start',\n\t'request',\n\t'parse',\n\t'transform',\n\t'resolve',\n\t'beforeHandle',\n\t'afterHandle',\n\t'mapResponse',\n\t'afterResponse',\n\t'trace',\n\t'error',\n\t'stop',\n\t'body',\n\t'headers',\n\t'params',\n\t'query',\n\t'response',\n\t'type',\n\t'detail'\n] as const\n\nconst primitiveHookMap = primitiveHooks.reduce(\n\t(acc, x) => ((acc[x] = true), acc),\n\t{} as Record<string, boolean>\n)\n\nexport const mergeResponse = (\n\ta: InputSchema['response'],\n\tb: InputSchema['response']\n) => {\n\t// If both are Record<number, ...> then merge them,\n\t// giving preference to b.\n\ttype RecordNumber = Record<number, any>\n\tconst isRecordNumber = (x: typeof a | typeof b): x is RecordNumber =>\n\t\ttypeof x === 'object' && Object.keys(x).every(isNumericString)\n\n\tif (isRecordNumber(a) && isRecordNumber(b)) return Object.assign(a, b)\n\telse if (a && !isRecordNumber(a) && isRecordNumber(b))\n\t\treturn Object.assign({ 200: a }, b)\n\n\treturn b ?? a\n}\n\nexport const mergeSchemaValidator = (\n\ta?: SchemaValidator | null,\n\tb?: SchemaValidator | null\n): SchemaValidator => {\n\treturn {\n\t\tbody: b?.body ?? a?.body,\n\t\theaders: b?.headers ?? a?.headers,\n\t\tparams: b?.params ?? a?.params,\n\t\tquery: b?.query ?? a?.query,\n\t\tcookie: b?.cookie ?? a?.cookie,\n\t\t// @ts-ignore ? This order is correct - SaltyAom\n\t\tresponse: mergeResponse(\n\t\t\t// @ts-ignore\n\t\t\ta?.response,\n\t\t\t// @ts-ignore\n\t\t\tb?.response\n\t\t)\n\t}\n}\n\nexport const mergeHook = (\n\ta?: Partial<LifeCycleStore>,\n\tb?: AnyLocalHook\n\t// { allowMacro = false }: { allowMacro?: boolean } = {}\n): LifeCycleStore => {\n\t// In case if merging union is need\n\t// const customAStore: Record<string, unknown> = {}\n\t// const customBStore: Record<string, unknown> = {}\n\n\t// for (const [key, value] of Object.entries(a)) {\n\t// \tif (primitiveHooks.includes(key as any)) continue\n\n\t// \tcustomAStore[key] = value\n\t// }\n\n\t// for (const [key, value] of Object.entries(b)) {\n\t// \tif (primitiveHooks.includes(key as any)) continue\n\n\t// \tcustomBStore[key] = value\n\t// }\n\n\t// const unioned = Object.keys(customAStore).filter((x) =>\n\t// \tObject.keys(customBStore).includes(x)\n\t// )\n\n\t// // Must provide empty object to prevent reference side-effect\n\t// const customStore = Object.assign({}, customAStore, customBStore)\n\n\t// for (const union of unioned)\n\t// \tcustomStore[union] = mergeObjectArray(\n\t// \t\tcustomAStore[union],\n\t// \t\tcustomBStore[union]\n\t// \t)\n\n\t// @ts-expect-error\n\tconst { resolve: resolveA, ...restA } = a ?? {}\n\tconst { resolve: resolveB, ...restB } = b ?? {}\n\n\treturn {\n\t\t...restA,\n\t\t...restB,\n\t\t// Merge local hook first\n\t\t// @ts-ignore\n\t\tbody: b?.body ?? a?.body,\n\t\t// @ts-ignore\n\t\theaders: b?.headers ?? a?.headers,\n\t\t// @ts-ignore\n\t\tparams: b?.params ?? a?.params,\n\t\t// @ts-ignore\n\t\tquery: b?.query ?? a?.query,\n\t\t// @ts-ignore\n\t\tcookie: b?.cookie ?? a?.cookie,\n\t\t// ? This order is correct - SaltyAom\n\t\tresponse: mergeResponse(\n\t\t\t// @ts-ignore\n\t\t\ta?.response,\n\t\t\t// @ts-ignore\n\t\t\tb?.response\n\t\t),\n\t\ttype: a?.type || b?.type,\n\t\tdetail: mergeDeep(\n\t\t\t// @ts-ignore\n\t\t\tb?.detail ?? {},\n\t\t\t// @ts-ignore\n\t\t\ta?.detail ?? {}\n\t\t),\n\t\tparse: mergeObjectArray(a?.parse as any, b?.parse),\n\t\ttransform: mergeObjectArray(a?.transform, b?.transform),\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\tmergeObjectArray(\n\t\t\t\tfnToContainer(resolveA, 'resolve'),\n\t\t\t\ta?.beforeHandle\n\t\t\t),\n\t\t\tmergeObjectArray(\n\t\t\t\tfnToContainer(resolveB, 'resolve'),\n\t\t\t\tb?.beforeHandle\n\t\t\t)\n\t\t),\n\t\tafterHandle: mergeObjectArray(a?.afterHandle, b?.afterHandle),\n\t\tmapResponse: mergeObjectArray(a?.mapResponse, b?.mapResponse) as any,\n\t\tafterResponse: mergeObjectArray(\n\t\t\ta?.afterResponse,\n\t\t\tb?.afterResponse\n\t\t) as any,\n\t\ttrace: mergeObjectArray(a?.trace, b?.trace) as any,\n\t\terror: mergeObjectArray(a?.error, b?.error)\n\t}\n}\n\ninterface ReplaceSchemaTypeOptions {\n\tfrom: TSchema\n\tto(options: Object): TSchema\n\texcludeRoot?: boolean\n\trootOnly?: boolean\n\t/**\n\t * Traverse until object is found except root object\n\t **/\n\tuntilObjectFound?: boolean\n}\n\nexport const replaceSchemaType = (\n\tschema: TSchema,\n\toptions: MaybeArray<ReplaceSchemaTypeOptions>,\n\troot = true\n) => {\n\tif (!Array.isArray(options))\n\t\treturn _replaceSchemaType(schema, options, root)\n\n\tfor (const option of options)\n\t\tschema = _replaceSchemaType(schema, option, root)\n\n\treturn schema\n}\n\nconst _replaceSchemaType = (\n\tschema: TSchema,\n\toptions: ReplaceSchemaTypeOptions,\n\troot = true\n) => {\n\tif (!schema) return schema\n\tif (options.untilObjectFound && !root && schema.type === 'object')\n\t\treturn schema\n\n\tconst fromSymbol = options.from[Kind]\n\n\tif (schema.oneOf) {\n\t\tfor (let i = 0; i < schema.oneOf.length; i++)\n\t\t\tschema.oneOf[i] = _replaceSchemaType(schema.oneOf[i], options, root)\n\n\t\treturn schema\n\t}\n\n\tif (schema.anyOf) {\n\t\tfor (let i = 0; i < schema.anyOf.length; i++)\n\t\t\tschema.anyOf[i] = _replaceSchemaType(schema.anyOf[i], options, root)\n\n\t\treturn schema\n\t}\n\n\tif (schema.allOf) {\n\t\tfor (let i = 0; i < schema.allOf.length; i++)\n\t\t\tschema.allOf[i] = _replaceSchemaType(schema.allOf[i], options, root)\n\n\t\treturn schema\n\t}\n\n\tif (schema.not) {\n\t\tfor (let i = 0; i < schema.not.length; i++)\n\t\t\tschema.not[i] = _replaceSchemaType(schema.not[i], options, root)\n\n\t\treturn schema\n\t}\n\n\tconst isRoot = root && !!options.excludeRoot\n\n\tif (schema[Kind] === fromSymbol) {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\tconst { anyOf, oneOf, allOf, not, properties, items, ...rest } = schema\n\t\tconst to = options.to(rest)\n\n\t\t// If t.Transform is used, we need to re-calculate Encode, Decode\n\t\tlet transform\n\n\t\tconst composeProperties = (v: TSchema) => {\n\t\t\tif (properties && v.type === 'object') {\n\t\t\t\tconst newProperties = <Record<string, unknown>>{}\n\t\t\t\tfor (const [key, value] of Object.entries(properties))\n\t\t\t\t\tnewProperties[key] = _replaceSchemaType(\n\t\t\t\t\t\tvalue as TSchema,\n\t\t\t\t\t\toptions,\n\t\t\t\t\t\tfalse\n\t\t\t\t\t)\n\n\t\t\t\treturn {\n\t\t\t\t\t...rest,\n\t\t\t\t\t...v,\n\t\t\t\t\tproperties: newProperties\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (items && v.type === 'array')\n\t\t\t\treturn {\n\t\t\t\t\t...rest,\n\t\t\t\t\t...v,\n\t\t\t\t\titems: _replaceSchemaType(items, options, false)\n\t\t\t\t}\n\n\t\t\tconst value = {\n\t\t\t\t...rest,\n\t\t\t\t...v\n\t\t\t}\n\n\t\t\t// Remove required as it's not object\n\t\t\tdelete value['required']\n\n\t\t\t// Create default value for ObjectString\n\t\t\tif (\n\t\t\t\tproperties &&\n\t\t\t\tv.type === 'string' &&\n\t\t\t\tv.format === 'ObjectString' &&\n\t\t\t\tv.default === '{}'\n\t\t\t) {\n\t\t\t\ttransform = t.ObjectString(properties, rest)\n\t\t\t\tvalue.default = JSON.stringify(\n\t\t\t\t\tValue.Create(t.Object(properties))\n\t\t\t\t)\n\t\t\t\tvalue.properties = properties\n\t\t\t}\n\n\t\t\t// Create default value for ArrayString\n\t\t\tif (\n\t\t\t\titems &&\n\t\t\t\tv.type === 'string' &&\n\t\t\t\tv.format === 'ArrayString' &&\n\t\t\t\tv.default === '[]'\n\t\t\t) {\n\t\t\t\ttransform = t.ArrayString(items, rest)\n\t\t\t\tvalue.default = JSON.stringify(Value.Create(t.Array(items)))\n\t\t\t\tvalue.items = items\n\t\t\t}\n\n\t\t\treturn value\n\t\t}\n\n\t\tif (isRoot) {\n\t\t\tif (properties) {\n\t\t\t\tconst newProperties = <Record<string, unknown>>{}\n\t\t\t\tfor (const [key, value] of Object.entries(properties))\n\t\t\t\t\tnewProperties[key] = _replaceSchemaType(\n\t\t\t\t\t\tvalue as TSchema,\n\t\t\t\t\t\toptions,\n\t\t\t\t\t\tfalse\n\t\t\t\t\t)\n\n\t\t\t\treturn {\n\t\t\t\t\t...rest,\n\t\t\t\t\tproperties: newProperties\n\t\t\t\t}\n\t\t\t} else if (items?.map)\n\t\t\t\treturn {\n\t\t\t\t\t...rest,\n\t\t\t\t\titems: items.map((v: TSchema) =>\n\t\t\t\t\t\t_replaceSchemaType(v, options, false)\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\treturn rest\n\t\t}\n\n\t\tif (to.anyOf)\n\t\t\tfor (let i = 0; i < to.anyOf.length; i++)\n\t\t\t\tto.anyOf[i] = composeProperties(to.anyOf[i])\n\t\telse if (to.oneOf)\n\t\t\tfor (let i = 0; i < to.oneOf.length; i++)\n\t\t\t\tto.oneOf[i] = composeProperties(to.oneOf[i])\n\t\telse if (to.allOf)\n\t\t\tfor (let i = 0; i < to.allOf.length; i++)\n\t\t\t\tto.allOf[i] = composeProperties(to.allOf[i])\n\t\telse if (to.not)\n\t\t\tfor (let i = 0; i < to.not.length; i++)\n\t\t\t\tto.not[i] = composeProperties(to.not[i])\n\n\t\tif (transform) to[TransformKind as any] = transform[TransformKind]\n\n\t\tif (to.anyOf || to.oneOf || to.allOf || to.not) return to\n\n\t\tif (properties) {\n\t\t\tconst newProperties = <Record<string, unknown>>{}\n\t\t\tfor (const [key, value] of Object.entries(properties))\n\t\t\t\tnewProperties[key] = _replaceSchemaType(\n\t\t\t\t\tvalue as TSchema,\n\t\t\t\t\toptions,\n\t\t\t\t\tfalse\n\t\t\t\t)\n\n\t\t\treturn {\n\t\t\t\t...rest,\n\t\t\t\t...to,\n\t\t\t\tproperties: newProperties\n\t\t\t}\n\t\t} else if (items?.map)\n\t\t\treturn {\n\t\t\t\t...rest,\n\t\t\t\t...to,\n\t\t\t\titems: items.map((v: TSchema) =>\n\t\t\t\t\t_replaceSchemaType(v, options, false)\n\t\t\t\t)\n\t\t\t}\n\n\t\treturn {\n\t\t\t...rest,\n\t\t\t...to\n\t\t}\n\t}\n\n\tconst properties = schema?.properties as Record<string, TSchema>\n\n\tif (properties && root && options.rootOnly !== true)\n\t\tfor (const [key, value] of Object.entries(properties)) {\n\t\t\tswitch (value[Kind]) {\n\t\t\t\tcase fromSymbol:\n\t\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\t\tconst { anyOf, oneOf, allOf, not, type, ...rest } = value\n\t\t\t\t\tconst to = options.to(rest)\n\n\t\t\t\t\tif (to.anyOf)\n\t\t\t\t\t\tfor (let i = 0; i < to.anyOf.length; i++)\n\t\t\t\t\t\t\tto.anyOf[i] = { ...rest, ...to.anyOf[i] }\n\t\t\t\t\telse if (to.oneOf)\n\t\t\t\t\t\tfor (let i = 0; i < to.oneOf.length; i++)\n\t\t\t\t\t\t\tto.oneOf[i] = { ...rest, ...to.oneOf[i] }\n\t\t\t\t\telse if (to.allOf)\n\t\t\t\t\t\tfor (let i = 0; i < to.allOf.length; i++)\n\t\t\t\t\t\t\tto.allOf[i] = { ...rest, ...to.allOf[i] }\n\t\t\t\t\telse if (to.not)\n\t\t\t\t\t\tfor (let i = 0; i < to.not.length; i++)\n\t\t\t\t\t\t\tto.not[i] = { ...rest, ...to.not[i] }\n\n\t\t\t\t\tproperties[key] = {\n\t\t\t\t\t\t...rest,\n\t\t\t\t\t\t..._replaceSchemaType(rest, options, false)\n\t\t\t\t\t}\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'Object':\n\t\t\t\tcase 'Union':\n\t\t\t\t\tproperties[key] = _replaceSchemaType(value, options, false)\n\t\t\t\t\tbreak\n\n\t\t\t\tdefault:\n\t\t\t\t\tif (Array.isArray(value.items)) {\n\t\t\t\t\t\tfor (let i = 0; i < value.items.length; i++) {\n\t\t\t\t\t\t\tvalue.items[i] = _replaceSchemaType(\n\t\t\t\t\t\t\t\tvalue.items[i],\n\t\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tvalue.anyOf ||\n\t\t\t\t\t\tvalue.oneOf ||\n\t\t\t\t\t\tvalue.allOf ||\n\t\t\t\t\t\tvalue.not\n\t\t\t\t\t)\n\t\t\t\t\t\tproperties[key] = _replaceSchemaType(\n\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t)\n\t\t\t\t\telse if (value.type === 'array') {\n\t\t\t\t\t\tvalue.items = _replaceSchemaType(\n\t\t\t\t\t\t\tvalue.items,\n\t\t\t\t\t\t\toptions,\n\t\t\t\t\t\t\tfalse\n\t\t\t\t\t\t)\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\treturn schema\n}\n\nconst createCleaner = (schema: TAnySchema) => (value: unknown) => {\n\tif (typeof value === 'object')\n\t\ttry {\n\t\t\treturn Value.Clean(schema, structuredClone(value))\n\t\t} catch {\n\t\t\ttry {\n\t\t\t\treturn Value.Clean(schema, value)\n\t\t\t} catch {\n\t\t\t\treturn value\n\t\t\t}\n\t\t}\n\n\treturn value\n}\n\nexport const getSchemaValidator = <T extends TSchema | string | undefined>(\n\ts: T,\n\t{\n\t\tmodels = {},\n\t\tdynamic = false,\n\t\tmodules,\n\t\tnormalize = false,\n\t\tadditionalProperties = false,\n\t\tcoerce = false,\n\t\tadditionalCoerce = []\n\t}: {\n\t\tmodels?: Record<string, TSchema>\n\t\tmodules: TModule<any, any>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t\tnormalize?: boolean\n\t\tcoerce?: boolean\n\t\tadditionalCoerce?: MaybeArray<ReplaceSchemaTypeOptions>\n\t} = {\n\t\tmodules: t.Module({})\n\t}\n): T extends TSchema ? TypeCheck<TSchema> : undefined => {\n\tif (!s) return undefined as any\n\n\tlet schema: TSchema =\n\t\ttypeof s === 'string'\n\t\t\t? s.endsWith('[]')\n\t\t\t\t? t.Array(t.Ref(models[s.substring(0, s.length - 2)]))\n\t\t\t\t: // @ts-expect-error\n\t\t\t\t\t((modules as TModule<{}, {}>).Import(s) ?? models[s])\n\t\t\t: s\n\n\tif (!schema) return undefined as any\n\n\tif (coerce || additionalCoerce) {\n\t\tif (coerce)\n\t\t\tschema = replaceSchemaType(schema, [\n\t\t\t\t{\n\t\t\t\t\tfrom: t.Ref(''),\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tto: (options) => modules.Import(options['$ref'])\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tfrom: t.Number(),\n\t\t\t\t\tto: (options) => t.Numeric(options),\n\t\t\t\t\tuntilObjectFound: true\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tfrom: t.Boolean(),\n\t\t\t\t\tto: (options) => t.BooleanString(options),\n\t\t\t\t\tuntilObjectFound: true\n\t\t\t\t},\n\t\t\t\t...(Array.isArray(additionalCoerce)\n\t\t\t\t\t? additionalCoerce\n\t\t\t\t\t: [additionalCoerce])\n\t\t\t])\n\t\telse {\n\t\t\tschema = replaceSchemaType(schema, [\n\t\t\t\t{\n\t\t\t\t\tfrom: t.Ref(''),\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tto: (options) => modules.Import(options['$ref'])\n\t\t\t\t},\n\t\t\t\t...(Array.isArray(additionalCoerce)\n\t\t\t\t\t? additionalCoerce\n\t\t\t\t\t: [additionalCoerce])\n\t\t\t])\n\t\t}\n\t}\n\n\t// @ts-ignore\n\tif (schema.type === 'object' && 'additionalProperties' in schema === false)\n\t\tschema.additionalProperties = additionalProperties\n\n\tif (dynamic) {\n\t\tconst validator = {\n\t\t\tschema,\n\t\t\treferences: '',\n\t\t\tcheckFunc: () => {},\n\t\t\tcode: '',\n\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\tCode: () => '',\n\t\t\tClean: createCleaner(schema),\n\t\t\tDecode: (value: unknown) => Value.Decode(schema, value),\n\t\t\tEncode: (value: unknown) => Value.Encode(schema, value)\n\t\t} as unknown as TypeCheck<TSchema>\n\n\t\tif (normalize && schema.additionalProperties === false)\n\t\t\t// @ts-ignore\n\t\t\tvalidator.Clean = createCleaner(schema)\n\n\t\t// @ts-ignore\n\t\tif (schema.config) {\n\t\t\t// @ts-ignore\n\t\t\tvalidator.config = schema.config\n\n\t\t\t// @ts-ignore\n\t\t\tif (validator?.schema?.config)\n\t\t\t\t// @ts-ignore\n\t\t\t\tdelete validator.schema.config\n\t\t}\n\n\t\t// @ts-ignore\n\t\tvalidator.parse = (v) => {\n\t\t\ttry {\n\t\t\t\treturn validator.Decode(v)\n\t\t\t} catch (error) {\n\t\t\t\tthrow [...validator.Errors(v)].map(mapValueError)\n\t\t\t}\n\t\t}\n\n\t\t// @ts-ignore\n\t\tvalidator.safeParse = (v) => {\n\t\t\ttry {\n\t\t\t\treturn { success: true, data: validator.Decode(v), error: null }\n\t\t\t} catch (error) {\n\t\t\t\tconst errors = [...compiled.Errors(v)].map(mapValueError)\n\n\t\t\t\treturn {\n\t\t\t\t\tsuccess: false,\n\t\t\t\t\tdata: null,\n\t\t\t\t\terror: errors[0]?.summary,\n\t\t\t\t\terrors\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn validator as any\n\t}\n\n\tconst compiled = TypeCompiler.Compile(schema, Object.values(models))\n\n\t// @ts-expect-error\n\tcompiled.Clean = createCleaner(schema)\n\n\t// @ts-ignore\n\tif (schema.config) {\n\t\t// @ts-ignore\n\t\tcompiled.config = schema.config\n\n\t\t// @ts-ignore\n\t\tif (compiled?.schema?.config)\n\t\t\t// @ts-ignore\n\t\t\tdelete compiled.schema.config\n\t}\n\n\t// @ts-ignore\n\tcompiled.parse = (v) => {\n\t\ttry {\n\t\t\treturn compiled.Decode(v)\n\t\t} catch (error) {\n\t\t\tthrow [...compiled.Errors(v)].map(mapValueError)\n\t\t}\n\t}\n\n\t// @ts-ignore\n\tcompiled.safeParse = (v) => {\n\t\ttry {\n\t\t\treturn { success: true, data: compiled.Decode(v), error: null }\n\t\t} catch (error) {\n\t\t\tconst errors = [...compiled.Errors(v)].map(mapValueError)\n\n\t\t\treturn {\n\t\t\t\tsuccess: false,\n\t\t\t\tdata: null,\n\t\t\t\terror: errors[0]?.summary,\n\t\t\t\terrors\n\t\t\t}\n\t\t}\n\t}\n\n\treturn compiled as any\n}\n\nexport const getResponseSchemaValidator = (\n\ts: InputSchema['response'] | undefined,\n\t{\n\t\tmodels = {},\n\t\tmodules,\n\t\tdynamic = false,\n\t\tnormalize = false,\n\t\tadditionalProperties = false\n\t}: {\n\t\tmodules: TModule<any, any>\n\t\tmodels?: Record<string, TSchema>\n\t\tadditionalProperties?: boolean\n\t\tdynamic?: boolean\n\t\tnormalize?: boolean\n\t}\n): Record<number, TypeCheck<any>> | undefined => {\n\tif (!s) return\n\n\tconst maybeSchemaOrRecord =\n\t\ttypeof s === 'string'\n\t\t\t? s.endsWith('[]')\n\t\t\t\t? t.Array(t.Ref(models[s.substring(0, s.length - 2)])) // @ts-ignore\n\t\t\t\t: ((modules as TModule<{}, {}>).Import(s) ?? models[s])\n\t\t\t: s\n\n\tif (!maybeSchemaOrRecord) return\n\n\tconst compile = (schema: TSchema, references?: TSchema[]) => {\n\t\tif (dynamic)\n\t\t\treturn {\n\t\t\t\tschema,\n\t\t\t\treferences: '',\n\t\t\t\tcheckFunc: () => {},\n\t\t\t\tcode: '',\n\t\t\t\tCheck: (value: unknown) => Value.Check(schema, value),\n\t\t\t\tErrors: (value: unknown) => Value.Errors(schema, value),\n\t\t\t\tCode: () => '',\n\t\t\t\tClean: createCleaner(schema),\n\t\t\t\tDecode: (value: unknown) => Value.Decode(schema, value),\n\t\t\t\tEncode: (value: unknown) => Value.Encode(schema, value)\n\t\t\t} as unknown as TypeCheck<TSchema>\n\n\t\tconst compiledValidator = TypeCompiler.Compile(schema, references)\n\n\t\tif (normalize && schema.additionalProperties === false)\n\t\t\t// @ts-ignore\n\t\t\tcompiledValidator.Clean = createCleaner(schema)\n\n\t\treturn compiledValidator\n\t}\n\n\tconst modelValues = Object.values(models)\n\n\tif (Kind in maybeSchemaOrRecord) {\n\t\tif ('additionalProperties' in maybeSchemaOrRecord === false)\n\t\t\tmaybeSchemaOrRecord.additionalProperties = additionalProperties\n\n\t\treturn {\n\t\t\t200: compile(maybeSchemaOrRecord, modelValues)\n\t\t}\n\t}\n\n\tconst record: Record<number, TypeCheck<any>> = {}\n\n\tObject.keys(maybeSchemaOrRecord).forEach((status): TSchema | undefined => {\n\t\tconst maybeNameOrSchema = maybeSchemaOrRecord[+status]\n\n\t\tif (typeof maybeNameOrSchema === 'string') {\n\t\t\tif (maybeNameOrSchema in models) {\n\t\t\t\tconst schema = models[maybeNameOrSchema]\n\t\t\t\tschema.type === 'object' &&\n\t\t\t\t\t'additionalProperties' in schema === false\n\n\t\t\t\t// Inherits model maybe already compiled\n\t\t\t\trecord[+status] =\n\t\t\t\t\tKind in schema ? compile(schema, modelValues) : schema\n\t\t\t}\n\n\t\t\treturn undefined\n\t\t}\n\n\t\tif (\n\t\t\tmaybeNameOrSchema.type === 'object' &&\n\t\t\t'additionalProperties' in maybeNameOrSchema === false\n\t\t)\n\t\t\tmaybeNameOrSchema.additionalProperties = additionalProperties\n\n\t\t// Inherits model maybe already compiled\n\t\trecord[+status] =\n\t\t\tKind in maybeNameOrSchema\n\t\t\t\t? compile(maybeNameOrSchema, modelValues)\n\t\t\t\t: maybeNameOrSchema\n\t})\n\n\treturn record\n}\n\nconst isBun = typeof Bun !== 'undefined'\nconst hasHash = isBun && typeof Bun.hash === 'function'\n\n// https://stackoverflow.com/a/52171480\nexport const checksum = (s: string) => {\n\tif (hasHash) return Bun.hash(s) as number\n\n\tlet h = 9\n\n\tfor (let i = 0; i < s.length; ) h = Math.imul(h ^ s.charCodeAt(i++), 9 ** 9)\n\n\treturn (h = h ^ (h >>> 9))\n}\n\nlet _stringToStructureCoercions: ReplaceSchemaTypeOptions[]\n\nexport const stringToStructureCoercions = () => {\n\tif (!_stringToStructureCoercions) {\n\t\t_stringToStructureCoercions = [\n\t\t\t{\n\t\t\t\tfrom: t.Object({}),\n\t\t\t\tto: () => t.ObjectString({}),\n\t\t\t\texcludeRoot: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tfrom: t.Array(t.Any()),\n\t\t\t\tto: () => t.ArrayString(t.Any())\n\t\t\t}\n\t\t] satisfies ReplaceSchemaTypeOptions[]\n\t}\n\n\treturn _stringToStructureCoercions\n}\n\nlet _coercePrimitiveRoot: ReplaceSchemaTypeOptions[]\n\nexport const coercePrimitiveRoot = () => {\n\tif (!_coercePrimitiveRoot)\n\t\t_coercePrimitiveRoot = [\n\t\t\t{\n\t\t\t\tfrom: t.Number(),\n\t\t\t\tto: (options) => t.Numeric(options),\n\t\t\t\trootOnly: true\n\t\t\t},\n\t\t\t{\n\t\t\t\tfrom: t.Boolean(),\n\t\t\t\tto: (options) => t.BooleanString(options),\n\t\t\t\trootOnly: true\n\t\t\t}\n\t\t] satisfies ReplaceSchemaTypeOptions[]\n\n\treturn _coercePrimitiveRoot\n}\n\nexport const getCookieValidator = ({\n\tvalidator,\n\tmodules,\n\tdefaultConfig = {},\n\tconfig,\n\tdynamic,\n\tmodels\n}: {\n\tvalidator: TSchema | string | undefined\n\tmodules: TModule<any, any>\n\tdefaultConfig: CookieOptions | undefined\n\tconfig: CookieOptions\n\tdynamic: boolean\n\tmodels: Record<string, TSchema> | undefined\n}) => {\n\tlet cookieValidator = getSchemaValidator(validator, {\n\t\tmodules,\n\t\tdynamic,\n\t\tmodels,\n\t\tadditionalProperties: true,\n\t\tcoerce: true,\n\t\tadditionalCoerce: stringToStructureCoercions()\n\t})\n\n\tif (isNotEmpty(defaultConfig)) {\n\t\tif (cookieValidator) {\n\t\t\t// @ts-expect-error private\n\t\t\tcookieValidator.config = mergeCookie(\n\t\t\t\t// @ts-expect-error private\n\t\t\t\tcookieValidator.config,\n\t\t\t\tconfig\n\t\t\t)\n\t\t} else {\n\t\t\tcookieValidator = getSchemaValidator(t.Cookie({}), {\n\t\t\t\tmodules,\n\t\t\t\tdynamic,\n\t\t\t\tmodels,\n\t\t\t\tadditionalProperties: true\n\t\t\t})\n\n\t\t\t// @ts-expect-error private\n\t\t\tcookieValidator.config = defaultConfig\n\t\t}\n\t}\n\n\treturn cookieValidator\n}\n\nexport const injectChecksum = (\n\tchecksum: number | undefined,\n\tx: MaybeArray<HookContainer> | undefined\n) => {\n\tif (!x) return\n\n\tif (!Array.isArray(x)) {\n\t\t// ? clone fn is required to prevent side-effect from changing hookType\n\t\tconst fn = x\n\n\t\tif (checksum && !fn.checksum) fn.checksum = checksum\n\t\tif (fn.scope === 'scoped') fn.scope = 'local'\n\n\t\treturn fn\n\t}\n\n\t// ? clone fns is required to prevent side-effect from changing hookType\n\tconst fns = [...x]\n\n\tfor (const fn of fns) {\n\t\tif (checksum && !fn.checksum) fn.checksum = checksum\n\n\t\tif (fn.scope === 'scoped') fn.scope = 'local'\n\t}\n\n\treturn fns\n}\n\nexport const mergeLifeCycle = (\n\ta: Partial<LifeCycleStore>,\n\tb: Partial<LifeCycleStore | AnyLocalHook>,\n\tchecksum?: number\n): LifeCycleStore => {\n\treturn {\n\t\tstart: mergeObjectArray(\n\t\t\ta.start,\n\t\t\tinjectChecksum(checksum, b?.start)\n\t\t) as HookContainer<GracefulHandler<any>>[],\n\t\trequest: mergeObjectArray(\n\t\t\ta.request,\n\t\t\tinjectChecksum(checksum, b?.request)\n\t\t) as HookContainer<PreHandler<any, any>>[],\n\t\tparse: mergeObjectArray(\n\t\t\ta.parse,\n\t\t\tinjectChecksum(checksum, b?.parse)\n\t\t) as HookContainer<BodyHandler<any, any>>[],\n\t\ttransform: mergeObjectArray(\n\t\t\ta.transform,\n\t\t\tinjectChecksum(checksum, b?.transform)\n\t\t) as HookContainer<TransformHandler<any, any>>[],\n\t\tbeforeHandle: mergeObjectArray(\n\t\t\tmergeObjectArray(\n\t\t\t\t// @ts-ignore\n\t\t\t\tfnToContainer(a.resolve, 'resolve'),\n\t\t\t\ta.beforeHandle\n\t\t\t),\n\t\t\tinjectChecksum(\n\t\t\t\tchecksum,\n\t\t\t\tmergeObjectArray(\n\t\t\t\t\tfnToContainer(b?.resolve, 'resolve'),\n\t\t\t\t\tb?.beforeHandle\n\t\t\t\t)\n\t\t\t)\n\t\t) as HookContainer<OptionalHandler<any, any>>[],\n\t\tafterHandle: mergeObjectArray(\n\t\t\ta.afterHandle,\n\t\t\tinjectChecksum(checksum, b?.afterHandle)\n\t\t) as HookContainer<AfterHandler<any, any>>[],\n\t\tmapResponse: mergeObjectArray(\n\t\t\ta.mapResponse,\n\t\t\tinjectChecksum(checksum, b?.mapResponse)\n\t\t) as HookContainer<MapResponse<any, any>>[],\n\t\tafterResponse: mergeObjectArray(\n\t\t\ta.afterResponse,\n\t\t\tinjectChecksum(checksum, b?.afterResponse)\n\t\t) as HookContainer<AfterResponseHandler<any, any>>[],\n\t\t// Already merged on Elysia._use, also logic is more complicated, can't directly merge\n\t\ttrace: mergeObjectArray(\n\t\t\ta.trace,\n\t\t\tinjectChecksum(checksum, b?.trace)\n\t\t) as HookContainer<TraceHandler<any, any>>[],\n\t\terror: mergeObjectArray(\n\t\t\ta.error,\n\t\t\tinjectChecksum(checksum, b?.error)\n\t\t) as HookContainer<ErrorHandler<any, any, any>>[],\n\t\tstop: mergeObjectArray(\n\t\t\ta.stop,\n\t\t\tinjectChecksum(checksum, b?.stop)\n\t\t) as HookContainer<GracefulHandler<any>>[]\n\t}\n}\n\nexport const asHookType = (\n\tfn: HookContainer,\n\tinject: LifeCycleType,\n\t{ skipIfHasType = false }: { skipIfHasType?: boolean } = {}\n) => {\n\tif (!fn) return fn\n\n\tif (!Array.isArray(fn)) {\n\t\tif (skipIfHasType) fn.scope ??= inject\n\t\telse fn.scope = inject\n\n\t\treturn fn\n\t}\n\n\tfor (const x of fn)\n\t\tif (skipIfHasType) x.scope ??= inject\n\t\telse x.scope = inject\n\n\treturn fn\n}\n\nconst filterGlobal = (fn: MaybeArray<HookContainer>) => {\n\tif (!fn) return fn\n\n\tif (!Array.isArray(fn))\n\t\tswitch (fn.scope) {\n\t\t\tcase 'global':\n\t\t\tcase 'scoped':\n\t\t\t\treturn { ...fn }\n\n\t\t\tdefault:\n\t\t\t\treturn { fn }\n\t\t}\n\n\tconst array = <any>[]\n\n\tfor (const x of fn)\n\t\tswitch (x.scope) {\n\t\t\tcase 'global':\n\t\t\tcase 'scoped':\n\t\t\t\tarray.push({\n\t\t\t\t\t...x\n\t\t\t\t})\n\t\t\t\tbreak\n\t\t}\n\n\treturn array\n}\n\nexport const filterGlobalHook = (hook: AnyLocalHook): AnyLocalHook => {\n\treturn {\n\t\t// rest is validator\n\t\t...hook,\n\t\ttype: hook?.type,\n\t\tdetail: hook?.detail,\n\t\tparse: filterGlobal(hook?.parse),\n\t\ttransform: filterGlobal(hook?.transform),\n\t\tbeforeHandle: filterGlobal(hook?.beforeHandle),\n\t\tafterHandle: filterGlobal(hook?.afterHandle),\n\t\tmapResponse: filterGlobal(hook?.mapResponse),\n\t\tafterResponse: filterGlobal(hook?.afterResponse),\n\t\terror: filterGlobal(hook?.error),\n\t\ttrace: filterGlobal(hook?.trace)\n\t}\n}\n\nexport const StatusMap = {\n\tContinue: 100,\n\t'Switching Protocols': 101,\n\tProcessing: 102,\n\t'Early Hints': 103,\n\tOK: 200,\n\tCreated: 201,\n\tAccepted: 202,\n\t'Non-Authoritative Information': 203,\n\t'No Content': 204,\n\t'Reset Content': 205,\n\t'Partial Content': 206,\n\t'Multi-Status': 207,\n\t'Already Reported': 208,\n\t'Multiple Choices': 300,\n\t'Moved Permanently': 301,\n\tFound: 302,\n\t'See Other': 303,\n\t'Not Modified': 304,\n\t'Temporary Redirect': 307,\n\t'Permanent Redirect': 308,\n\t'Bad Request': 400,\n\tUnauthorized: 401,\n\t'Payment Required': 402,\n\tForbidden: 403,\n\t'Not Found': 404,\n\t'Method Not Allowed': 405,\n\t'Not Acceptable': 406,\n\t'Proxy Authentication Required': 407,\n\t'Request Timeout': 408,\n\tConflict: 409,\n\tGone: 410,\n\t'Length Required': 411,\n\t'Precondition Failed': 412,\n\t'Payload Too Large': 413,\n\t'URI Too Long': 414,\n\t'Unsupported Media Type': 415,\n\t'Range Not Satisfiable': 416,\n\t'Expectation Failed': 417,\n\t\"I'm a teapot\": 418,\n\t'Misdirected Request': 421,\n\t'Unprocessable Content': 422,\n\tLocked: 423,\n\t'Failed Dependency': 424,\n\t'Too Early': 425,\n\t'Upgrade Required': 426,\n\t'Precondition Required': 428,\n\t'Too Many Requests': 429,\n\t'Request Header Fields Too Large': 431,\n\t'Unavailable For Legal Reasons': 451,\n\t'Internal Server Error': 500,\n\t'Not Implemented': 501,\n\t'Bad Gateway': 502,\n\t'Service Unavailable': 503,\n\t'Gateway Timeout': 504,\n\t'HTTP Version Not Supported': 505,\n\t'Variant Also Negotiates': 506,\n\t'Insufficient Storage': 507,\n\t'Loop Detected': 508,\n\t'Not Extended': 510,\n\t'Network Authentication Required': 511\n} as const\n\nexport const InvertedStatusMap = Object.fromEntries(\n\tObject.entries(StatusMap).map(([k, v]) => [v, k])\n) as {\n\t[K in keyof StatusMap as StatusMap[K]]: K\n}\n\nexport type StatusMap = typeof StatusMap\nexport type InvertedStatusMap = typeof InvertedStatusMap\n\nfunction removeTrailingEquals(digest: string): string {\n\tlet trimmedDigest = digest\n\twhile (trimmedDigest.endsWith('=')) {\n\t\ttrimmedDigest = trimmedDigest.slice(0, -1)\n\t}\n\treturn trimmedDigest\n}\n\nconst encoder = new TextEncoder()\n\nexport const signCookie = async (val: string, secret: string | null) => {\n\tif (typeof val !== 'string')\n\t\tthrow new TypeError('Cookie value must be provided as a string.')\n\n\tif (secret === null) throw new TypeError('Secret key must be provided.')\n\n\tconst secretKey = await crypto.subtle.importKey(\n\t\t'raw',\n\t\tencoder.encode(secret),\n\t\t{ name: 'HMAC', hash: 'SHA-256' },\n\t\tfalse,\n\t\t['sign']\n\t)\n\tconst hmacBuffer = await crypto.subtle.sign(\n\t\t'HMAC',\n\t\tsecretKey,\n\t\tencoder.encode(val)\n\t)\n\n\treturn (\n\t\tval +\n\t\t'.' +\n\t\tremoveTrailingEquals(Buffer.from(hmacBuffer).toString('base64'))\n\t)\n}\n\nexport const unsignCookie = async (input: string, secret: string | null) => {\n\tif (typeof input !== 'string')\n\t\tthrow new TypeError('Signed cookie string must be provided.')\n\n\tif (null === secret) throw new TypeError('Secret key must be provided.')\n\n\tconst tentativeValue = input.slice(0, input.lastIndexOf('.'))\n\tconst expectedInput = await signCookie(tentativeValue, secret)\n\n\treturn expectedInput === input ? tentativeValue : false\n}\n\nexport const traceBackMacro = (\n\textension: unknown,\n\tproperty: Record<string, unknown>,\n\tmanage: ReturnType<typeof createMacroManager>\n) => {\n\tif (!extension || typeof extension !== 'object' || !property) return\n\n\tfor (const [key, value] of Object.entries(property)) {\n\t\tif (key in primitiveHookMap || !(key in extension)) continue\n\n\t\tconst v = extension[\n\t\t\tkey as unknown as keyof typeof extension\n\t\t] as BaseMacro[string]\n\n\t\tif (typeof v === 'function') {\n\t\t\tconst hook = v(value)\n\n\t\t\tif (typeof hook === 'object') {\n\t\t\t\tfor (const [k, v] of Object.entries(hook)) {\n\t\t\t\t\tmanage(k as keyof LifeCycleStore)({\n\t\t\t\t\t\tfn: v as any\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdelete property[key as unknown as keyof typeof extension]\n\t}\n}\n\nexport const createMacroManager =\n\t({\n\t\tglobalHook,\n\t\tlocalHook\n\t}: {\n\t\tglobalHook: Partial<LifeCycleStore>\n\t\tlocalHook: Partial<AnyLocalHook>\n\t}) =>\n\t(stackName: keyof LifeCycleStore) =>\n\t(\n\t\ttype:\n\t\t\t| {\n\t\t\t\t\tinsert?: 'before' | 'after'\n\t\t\t\t\tstack?: 'global' | 'local'\n\t\t\t  }\n\t\t\t| MaybeArray<HookContainer>,\n\t\tfn?: MaybeArray<HookContainer>\n\t) => {\n\t\tif (typeof type === 'function')\n\t\t\ttype = {\n\t\t\t\tfn: type\n\t\t\t}\n\n\t\t// @ts-expect-error this is available in macro v2\n\t\tif (stackName === 'resolve') {\n\t\t\ttype = {\n\t\t\t\t...type,\n\t\t\t\tsubType: 'resolve'\n\t\t\t}\n\t\t}\n\n\t\tif ('fn' in type || Array.isArray(type)) {\n\t\t\tif (!localHook[stackName]) localHook[stackName] = []\n\t\t\tif (typeof localHook[stackName] === 'function')\n\t\t\t\tlocalHook[stackName] = [localHook[stackName]]\n\n\t\t\tif (Array.isArray(type))\n\t\t\t\tlocalHook[stackName] = (\n\t\t\t\t\tlocalHook[stackName] as unknown[]\n\t\t\t\t).concat(type) as any\n\t\t\telse localHook[stackName].push(type)\n\n\t\t\treturn\n\t\t}\n\n\t\tconst { insert = 'after', stack = 'local' } = type\n\n\t\tif (typeof fn === 'function') fn = { fn }\n\n\t\tif (stack === 'global') {\n\t\t\tif (!Array.isArray(fn)) {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\t;(globalHook[stackName] as any[]).unshift(fn)\n\t\t\t\t} else {\n\t\t\t\t\t;(globalHook[stackName] as any[]).push(fn)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\tglobalHook[stackName] = fn.concat(\n\t\t\t\t\t\tglobalHook[stackName] as any\n\t\t\t\t\t) as any\n\t\t\t\t} else {\n\t\t\t\t\tglobalHook[stackName] = (\n\t\t\t\t\t\tglobalHook[stackName] as any[]\n\t\t\t\t\t).concat(fn)\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!localHook[stackName]) localHook[stackName] = []\n\t\t\tif (typeof localHook[stackName] === 'function')\n\t\t\t\tlocalHook[stackName] = [localHook[stackName]]\n\n\t\t\tif (!Array.isArray(fn)) {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\t;(localHook[stackName] as any[]).unshift(fn)\n\t\t\t\t} else {\n\t\t\t\t\t;(localHook[stackName] as any[]).push(fn)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (insert === 'before') {\n\t\t\t\t\tlocalHook[stackName] = fn.concat(localHook[stackName])\n\t\t\t\t} else {\n\t\t\t\t\tlocalHook[stackName] = localHook[stackName].concat(fn)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nconst parseNumericString = (message: string | number): number | null => {\n\tif (typeof message === 'number') return message\n\n\tif (message.length < 16) {\n\t\tif (message.trim().length === 0) return null\n\n\t\tconst length = Number(message)\n\t\tif (Number.isNaN(length)) return null\n\n\t\treturn length\n\t}\n\n\t// if 16 digit but less then 9,007,199,254,740,991 then can be parsed\n\tif (message.length === 16) {\n\t\tif (message.trim().length === 0) return null\n\n\t\tconst number = Number(message)\n\t\tif (Number.isNaN(number) || number.toString() !== message) return null\n\n\t\treturn number\n\t}\n\n\treturn null\n}\n\nexport const isNumericString = (message: string | number): boolean =>\n\tparseNumericString(message) !== null\n\nexport class PromiseGroup implements PromiseLike<void> {\n\troot: Promise<any> | null = null\n\tpromises: Promise<any>[] = []\n\n\tconstructor(public onError: (error: any) => void = console.error) {}\n\n\t/**\n\t * The number of promises still being awaited.\n\t */\n\tget size() {\n\t\treturn this.promises.length\n\t}\n\n\t/**\n\t * Add a promise to the group.\n\t * @returns The promise that was added.\n\t */\n\tadd<T>(promise: Promise<T>) {\n\t\tthis.promises.push(promise)\n\t\tthis.root ||= this.drain()\n\t\treturn promise\n\t}\n\n\tprivate async drain() {\n\t\twhile (this.promises.length > 0) {\n\t\t\ttry {\n\t\t\t\tawait this.promises[0]\n\t\t\t} catch (error) {\n\t\t\t\tthis.onError(error)\n\t\t\t}\n\t\t\tthis.promises.shift()\n\t\t}\n\t\tthis.root = null\n\t}\n\n\t// Allow the group to be awaited.\n\tthen<TResult1 = void, TResult2 = never>(\n\t\tonfulfilled?:\n\t\t\t| ((value: void) => TResult1 | PromiseLike<TResult1>)\n\t\t\t| undefined\n\t\t\t| null,\n\t\tonrejected?:\n\t\t\t| ((reason: any) => TResult2 | PromiseLike<TResult2>)\n\t\t\t| undefined\n\t\t\t| null\n\t): PromiseLike<TResult1 | TResult2> {\n\t\treturn (this.root ?? Promise.resolve()).then(onfulfilled, onrejected)\n\t}\n}\n\nexport const fnToContainer = (\n\tfn: MaybeArray<Function | HookContainer>,\n\t/** Only add subType to non contained fn */\n\tsubType?: HookContainer['subType']\n): MaybeArray<HookContainer> => {\n\tif (!fn) return fn\n\n\tif (!Array.isArray(fn)) {\n\t\t// parse can be a label since 1.2.0\n\t\tif (typeof fn === 'function' || typeof fn === 'string')\n\t\t\treturn subType ? { fn, subType } : { fn }\n\t\telse if ('fn' in fn) return fn\n\t}\n\n\tconst fns = <HookContainer[]>[]\n\tfor (const x of fn) {\n\t\t// parse can be a label since 1.2.0\n\t\tif (typeof x === 'function' || typeof x === 'string')\n\t\t\tfns.push(subType ? { fn: x, subType } : { fn: x })\n\t\telse if ('fn' in x) fns.push(x)\n\t}\n\n\treturn fns\n}\n\nexport const localHookToLifeCycleStore = (a: AnyLocalHook): LifeCycleStore => {\n\treturn {\n\t\t...a,\n\t\tstart: fnToContainer(a?.start),\n\t\trequest: fnToContainer(a?.request),\n\t\tparse: fnToContainer(a?.parse),\n\t\ttransform: fnToContainer(a?.transform),\n\t\tbeforeHandle: fnToContainer(a?.beforeHandle),\n\t\tafterHandle: fnToContainer(a?.afterHandle),\n\t\tmapResponse: fnToContainer(a?.mapResponse),\n\t\tafterResponse: fnToContainer(a?.afterResponse),\n\t\ttrace: fnToContainer(a?.trace),\n\t\terror: fnToContainer(a?.error),\n\t\tstop: fnToContainer(a?.stop)\n\t}\n}\n\nexport const lifeCycleToFn = (a: Partial<LifeCycleStore>): AnyLocalHook => {\n\tconst hook: Partial<HookContainer> = {}\n\n\t// @ts-expect-error\n\tif (a.start?.map) hook.start = a.start.map((x) => x.fn)\n\t// @ts-expect-error\n\tif (a.request?.map) hook.request = a.request.map((x) => x.fn)\n\t// @ts-expect-error\n\tif (a.parse?.map) hook.parse = a.parse.map((x) => x.fn)\n\t// @ts-expect-error\n\tif (a.transform?.map) hook.transform = a.transform.map((x) => x.fn)\n\t// @ts-expect-error\n\tif (a.beforeHandle?.map) hook.beforeHandle = a.beforeHandle.map((x) => x.fn)\n\t// @ts-expect-error\n\tif (a.afterHandle?.map) hook.afterHandle = a.afterHandle.map((x) => x.fn)\n\t// @ts-expect-error\n\tif (a.mapResponse?.map) hook.mapResponse = a.mapResponse.map((x) => x.fn)\n\tif (a.afterResponse?.map)\n\t\t// @ts-expect-error\n\t\thook.afterResponse = a.afterResponse.map((x) => x.fn)\n\t// @ts-expect-error\n\tif (a.trace?.map) hook.trace = a.trace.map((x) => x.fn)\n\t// @ts-expect-error\n\tif (a.error?.map) hook.error = a.error.map((x) => x.fn)\n\t// @ts-expect-error\n\tif (a.stop?.map) hook.stop = a.stop.map((x) => x.fn)\n\n\treturn hook\n}\n\nexport const cloneInference = (inference: Sucrose.Inference) =>\n\t({\n\t\tbody: inference.body,\n\t\tcookie: inference.cookie,\n\t\theaders: inference.headers,\n\t\tquery: inference.query,\n\t\tset: inference.set,\n\t\tserver: inference.server,\n\t\trequest: inference.request,\n\t\troute: inference.route\n\t}) satisfies Sucrose.Inference\n\n/**\n *\n * @param url URL to redirect to\n * @param HTTP status code to send,\n */\nexport const redirect = (\n\turl: string,\n\tstatus: 301 | 302 | 303 | 307 | 308 = 302\n) => Response.redirect(url, status)\n\nexport type redirect = typeof redirect\n\nexport const ELYSIA_FORM_DATA = Symbol('ElysiaFormData')\nexport type ELYSIA_FORM_DATA = typeof ELYSIA_FORM_DATA\n\ntype ElysiaFormData<T extends Record<string | number, unknown>> = FormData & {\n\t[ELYSIA_FORM_DATA]: Replace<T, BunFile, File>\n}\n\nexport const ELYSIA_REQUEST_ID = Symbol('ElysiaRequestId')\nexport type ELYSIA_REQUEST_ID = typeof ELYSIA_REQUEST_ID\n\nexport const form = <const T extends Record<string | number, unknown>>(\n\titems: T\n): ElysiaFormData<T> => {\n\tconst formData = new FormData()\n\n\tfor (const [key, value] of Object.entries(items)) {\n\t\tif (Array.isArray(value)) {\n\t\t\tfor (const v of value) {\n\t\t\t\tif (value instanceof File)\n\t\t\t\t\tformData.append(key, value, value.name)\n\n\t\t\t\tformData.append(key, v)\n\t\t\t}\n\n\t\t\tcontinue\n\t\t}\n\n\t\tif (value instanceof File) formData.append(key, value, value.name)\n\t\tformData.append(key, value)\n\t}\n\n\treturn formData as any\n}\n\nexport const randomId = () => {\n\tconst uuid = crypto.randomUUID()\n\treturn uuid.slice(0, 8) + uuid.slice(24, 32)\n}\n\n// ! Deduplicate current instance\nexport const deduplicateChecksum = <T extends Function>(\n\tarray: HookContainer<T>[]\n): HookContainer<T>[] => {\n\tconst hashes: number[] = []\n\n\tfor (let i = 0; i < array.length; i++) {\n\t\tconst item = array[i]\n\n\t\tif (item.checksum) {\n\t\t\tif (hashes.includes(item.checksum)) {\n\t\t\t\tarray.splice(i, 1)\n\t\t\t\ti--\n\t\t\t}\n\n\t\t\thashes.push(item.checksum)\n\t\t}\n\t}\n\n\treturn array\n}\n\n/**\n * Since it's a plugin, which means that ephemeral is demoted to volatile.\n * Which  means there's no volatile and all previous ephemeral become volatile\n * We can just promote back without worry\n */\nexport const promoteEvent = (\n\tevents?: (HookContainer | Function)[],\n\tas: 'scoped' | 'global' = 'scoped'\n): void => {\n\tif (!events) return\n\n\tif (as === 'scoped') {\n\t\tfor (const event of events)\n\t\t\tif ('scope' in event && event.scope === 'local')\n\t\t\t\tevent.scope = 'scoped'\n\n\t\treturn\n\t}\n\n\tfor (const event of events) if ('scope' in event) event.scope = 'global'\n}\n\n// type PropertyKeys<T> = {\n// \t[K in keyof T]: T[K] extends (...args: any[]) => any ? never : K\n// }[keyof T]\n\n// type PropertiesOnly<T> = Pick<T, PropertyKeys<T>>\n\n// export const classToObject = <T>(\n// \tinstance: T,\n// \tprocessed: WeakMap<object, object> = new WeakMap()\n// ): T extends object ? PropertiesOnly<T> : T => {\n// \tif (typeof instance !== 'object' || instance === null)\n// \t\treturn instance as any\n\n// \tif (Array.isArray(instance))\n// \t\treturn instance.map((x) => classToObject(x, processed)) as any\n\n// \tif (processed.has(instance)) return processed.get(instance) as any\n\n// \tconst result: Partial<T> = {}\n\n// \tfor (const key of Object.keys(instance) as Array<keyof T>) {\n// \t\tconst value = instance[key]\n// \t\tif (typeof value === 'object' && value !== null)\n// \t\t\tresult[key] = classToObject(value, processed) as T[keyof T]\n// \t\telse result[key] = value\n// \t}\n\n// \tconst prototype = Object.getPrototypeOf(instance)\n// \tif (!prototype) return result as any\n\n// \tconst properties = Object.getOwnPropertyNames(prototype)\n\n// \tfor (const property of properties) {\n// \t\tconst descriptor = Object.getOwnPropertyDescriptor(\n// \t\t\tObject.getPrototypeOf(instance),\n// \t\t\tproperty\n// \t\t)\n\n// \t\tif (descriptor && typeof descriptor.get === 'function') {\n// \t\t\t// ? Very important to prevent prototype pollution\n// \t\t\tif (property === '__proto__') continue\n\n// \t\t\t;(result as any)[property as keyof typeof instance] = classToObject(\n// \t\t\t\tinstance[property as keyof typeof instance]\n// \t\t\t)\n// \t\t}\n// \t}\n\n// \treturn result as any\n// }\n\nexport const getLoosePath = (path: string) => {\n\tif (path.charCodeAt(path.length - 1) === 47)\n\t\treturn path.slice(0, path.length - 1)\n\n\treturn path + '/'\n}\n\nexport const isNotEmpty = (obj?: Object) => {\n\tif (!obj) return false\n\n\tfor (const x in obj) return true\n\n\treturn false\n}\n\nconst isEmptyHookProperty = (prop: unknown) => {\n\tif (Array.isArray(prop)) return prop.length === 0\n\n\treturn !prop\n}\n\nexport const compressHistoryHook = (hook: LifeCycleStore) => {\n\tconst history: Partial<LifeCycleStore> = { ...hook }\n\n\tif (isEmptyHookProperty(hook.afterHandle)) delete history.afterHandle\n\tif (isEmptyHookProperty(hook.afterResponse)) delete history.afterResponse\n\tif (isEmptyHookProperty(hook.beforeHandle)) delete history.beforeHandle\n\tif (isEmptyHookProperty(hook.error)) delete history.error\n\tif (isEmptyHookProperty(hook.mapResponse)) delete history.mapResponse\n\tif (isEmptyHookProperty(hook.parse)) delete history.parse\n\tif (isEmptyHookProperty(hook.request)) delete history.request\n\tif (isEmptyHookProperty(hook.start)) delete history.start\n\tif (isEmptyHookProperty(hook.stop)) delete history.stop\n\tif (isEmptyHookProperty(hook.trace)) delete history.trace\n\tif (isEmptyHookProperty(hook.transform)) delete history.transform\n\n\tif (!history.type) delete history.type\n\t// @ts-expect-error\n\tif (history.detail && !Object.keys(history.detail).length)\n\t\t// @ts-expect-error\n\t\tdelete history.detail\n\n\t// @ts-expect-error\n\tif (!history.body) delete history.body\n\t// @ts-expect-error\n\tif (!history.cookie) delete history.cookie\n\t// @ts-expect-error\n\tif (!history.headers) delete history.headers\n\t// @ts-expect-error\n\tif (!history.query) delete history.query\n\t// @ts-expect-error\n\tif (!history.params) delete history.params\n\t// @ts-expect-error\n\tif (!history.response) delete history.response\n\n\treturn history\n}\n\nexport const decompressHistoryHook = (hook: Partial<LifeCycleStore>) => {\n\tconst history = { ...hook } as LifeCycleStore\n\n\tif (!history.afterHandle) history.afterHandle = []\n\tif (!history.afterResponse) history.afterResponse = []\n\tif (!history.beforeHandle) history.beforeHandle = []\n\tif (!history.error) history.error = []\n\tif (!history.mapResponse) history.mapResponse = []\n\tif (!history.parse) history.parse = []\n\tif (!history.request) history.request = []\n\tif (!history.start) history.start = []\n\tif (!history.stop) history.stop = []\n\tif (!history.trace) history.trace = []\n\tif (!history.transform) history.transform = []\n\n\t// @ts-expect-error\n\tif (!history.body) history.body = undefined\n\t// @ts-expect-error\n\tif (!history.cookie) history.cookie = undefined\n\t// @ts-expect-error\n\tif (!history.headers) history.headers = undefined\n\t// @ts-expect-error\n\tif (!history.query) history.query = undefined\n\t// @ts-expect-error\n\tif (!history.params) history.params = undefined\n\t// @ts-expect-error\n\tif (!history.response) history.response = undefined\n\n\treturn history\n}\n\nexport const encodePath = (path: string, { dynamic = false } = {}) => {\n\tlet encoded = encodeURIComponent(path).replace(/%2F/g, '/')\n\n\tif (dynamic) encoded = encoded.replace(/%3A/g, ':').replace(/%3F/g, '?')\n\n\treturn encoded\n}\n",
    "/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable no-constant-condition */\nimport type { Handler, HookContainer, LifeCycleStore } from './types'\n\nexport namespace Sucrose {\n\texport interface Inference {\n\t\tquery: boolean\n\t\theaders: boolean\n\t\tbody: boolean\n\t\tcookie: boolean\n\t\tset: boolean\n\t\tserver: boolean\n\t\troute: boolean\n\t\trequest: boolean\n\t}\n\n\texport interface LifeCycle extends Partial<LifeCycleStore> {\n\t\thandler?: Handler\n\t}\n}\n\nexport const hasReturn = (fn: string | HookContainer<any> | Function) => {\n\tconst fnLiteral =\n\t\ttypeof fn === 'object'\n\t\t\t? fn.fn.toString()\n\t\t\t: typeof fn === 'string'\n\t\t\t\t? fn.toString()\n\t\t\t\t: fn\n\n\tconst parenthesisEnd = fnLiteral.indexOf(')')\n\n\t// Is direct arrow function return eg. () => 1\n\tif (\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 2) === 61 &&\n\t\tfnLiteral.charCodeAt(parenthesisEnd + 5) !== 123\n\t) {\n\t\treturn true\n\t}\n\n\treturn fnLiteral.includes('return')\n}\n\n/**\n * Separate stringified function body and paramter\n *\n * @example\n * ```typescript\n * separateFunction('async ({ hello }) => { return hello }') // => ['({ hello })', '{ return hello }']\n * ```\n */\nexport const separateFunction = (\n\tcode: string\n): [string, string, { isArrowReturn: boolean }] => {\n\t// Remove async keyword without removing space (both minify and non-minify)\n\tif (code.startsWith('async')) code = code.slice(5)\n\tcode = code.trimStart()\n\n\tlet index = -1\n\n\t// JSC: Starts with '(', is an arrow function\n\tif (code.charCodeAt(0) === 40) {\n\t\tindex = code.indexOf('=>', code.indexOf(')'))\n\n\t\tif (index !== -1) {\n\t\t\tlet bracketEndIndex = index\n\t\t\t// Walk back to find bracket end\n\t\t\twhile (bracketEndIndex > 0)\n\t\t\t\tif (code.charCodeAt(--bracketEndIndex) === 41) break\n\n\t\t\tlet body = code.slice(index + 2)\n\t\t\tif (body.charCodeAt(0) === 32) body = body.trimStart()\n\n\t\t\treturn [\n\t\t\t\tcode.slice(1, bracketEndIndex),\n\t\t\t\tbody,\n\t\t\t\t{\n\t\t\t\t\tisArrowReturn: body.charCodeAt(0) !== 123\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t}\n\n\t// V8: bracket is removed for 1 parameter arrow function\n\tif (/^(\\w+)=>/g.test(code)) {\n\t\tindex = code.indexOf('=>')\n\n\t\tif (index !== -1) {\n\t\t\tlet body = code.slice(index + 2)\n\t\t\tif (body.charCodeAt(0) === 32) body = body.trimStart()\n\n\t\t\treturn [\n\t\t\t\tcode.slice(0, index),\n\t\t\t\tbody,\n\t\t\t\t{\n\t\t\t\t\tisArrowReturn: body.charCodeAt(0) !== 123\n\t\t\t\t}\n\t\t\t]\n\t\t}\n\t}\n\n\t// Using function keyword\n\tif (code.startsWith('function')) {\n\t\tindex = code.indexOf('(')\n\t\tconst end = code.indexOf(')')\n\n\t\treturn [\n\t\t\tcode.slice(index + 1, end),\n\t\t\tcode.slice(end + 2),\n\t\t\t{\n\t\t\t\tisArrowReturn: false\n\t\t\t}\n\t\t]\n\t}\n\n\t// Probably Declare as method\n\tconst start = code.indexOf('(')\n\n\tif (start !== -1) {\n\t\tconst sep = code.indexOf('\\n', 2)\n\t\tconst parameter = code.slice(0, sep)\n\t\tconst end = parameter.lastIndexOf(')') + 1\n\n\t\tconst body = code.slice(sep + 1)\n\n\t\treturn [\n\t\t\tparameter.slice(start, end),\n\t\t\t'{' + body,\n\t\t\t{\n\t\t\t\tisArrowReturn: false\n\t\t\t}\n\t\t]\n\t}\n\n\t// Unknown case\n\tconst x = code.split('\\n', 2)\n\n\treturn [x[0], x[1], { isArrowReturn: false }]\n}\n\n/**\n * Get range between bracket pair\n *\n * @example\n * ```typescript\n * bracketPairRange('hello: { world: { a } }, elysia') // [6, 20]\n * ```\n */\nexport const bracketPairRange = (parameter: string): [number, number] => {\n\tconst start = parameter.indexOf('{')\n\tif (start === -1) return [-1, 0]\n\n\tlet end = start + 1\n\tlet deep = 1\n\n\tfor (; end < parameter.length; end++) {\n\t\tconst char = parameter.charCodeAt(end)\n\n\t\t// Open bracket\n\t\tif (char === 123) deep++\n\t\t// Close bracket\n\t\telse if (char === 125) deep--\n\n\t\tif (deep === 0) break\n\t}\n\n\tif (deep !== 0) return [0, parameter.length]\n\n\treturn [start, end + 1]\n}\n\n/**\n * Similar to `bracketPairRange` but in reverse order\n * Get range between bracket pair from end to beginning\n *\n * @example\n * ```typescript\n * bracketPairRange('hello: { world: { a } }, elysia') // [6, 20]\n * ```\n */\nexport const bracketPairRangeReverse = (\n\tparameter: string\n): [number, number] => {\n\tconst end = parameter.lastIndexOf('}')\n\tif (end === -1) return [-1, 0]\n\n\tlet start = end - 1\n\tlet deep = 1\n\n\tfor (; start >= 0; start--) {\n\t\tconst char = parameter.charCodeAt(start)\n\n\t\t// Open bracket\n\t\tif (char === 125) deep++\n\t\t// Close bracket\n\t\telse if (char === 123) deep--\n\n\t\tif (deep === 0) break\n\t}\n\n\tif (deep !== 0) return [-1, 0]\n\n\treturn [start, end + 1]\n}\n\nexport const removeColonAlias = (parameter: string) => {\n\twhile (true) {\n\t\tconst start = parameter.indexOf(':')\n\t\tif (start === -1) break\n\n\t\tlet end = parameter.indexOf(',', start)\n\t\tif (end === -1) end = parameter.indexOf('}', start) - 1\n\t\tif (end === -2) end = parameter.length\n\n\t\tparameter = parameter.slice(0, start) + parameter.slice(end)\n\t}\n\n\treturn parameter\n}\n\n/**\n * Retrieve only root paramters of a function\n *\n * @example\n * ```typescript\n * retrieveRootParameters('({ hello: { world: { a } }, elysia })') // => {\n *   parameters: ['hello', 'elysia'],\n *   hasParenthesis: true\n * }\n * ```\n */\nexport const retrieveRootParamters = (parameter: string) => {\n\tlet hasParenthesis = false\n\n\t// Remove () from parameter\n\tif (parameter.charCodeAt(0) === 40) parameter = parameter.slice(1, -1)\n\n\t// Remove {} from parameter\n\tif (parameter.charCodeAt(0) === 123) {\n\t\thasParenthesis = true\n\t\tparameter = parameter.slice(1, -1)\n\t}\n\n\tparameter = parameter.replace(/( |\\t|\\n)/g, '').trim()\n\tlet parameters = <string[]>[]\n\n\t// Object destructuring\n\twhile (true) {\n\t\t// eslint-disable-next-line prefer-const\n\t\tlet [start, end] = bracketPairRange(parameter)\n\t\tif (start === -1) break\n\n\t\t// Remove colon from object structuring cast\n\t\tparameters.push(parameter.slice(0, start - 1))\n\t\tif (parameter.charCodeAt(end) === 44) end++\n\t\tparameter = parameter.slice(end)\n\t}\n\n\tparameter = removeColonAlias(parameter)\n\tif (parameter) parameters = parameters.concat(parameter.split(','))\n\n\tconst newParameters = []\n\tfor (const p of parameters) {\n\t\tif (p.indexOf(',') === -1) {\n\t\t\tnewParameters.push(p)\n\t\t\tcontinue\n\t\t}\n\n\t\tfor (const q of p.split(',')) newParameters.push(q.trim())\n\t}\n\tparameters = newParameters\n\n\treturn {\n\t\thasParenthesis,\n\t\tparameters\n\t}\n}\n\n/**\n * Find inference from parameter\n *\n * @param parameter stringified parameter\n */\nexport const findParameterReference = (\n\tparameter: string,\n\tinference: Sucrose.Inference\n) => {\n\tconst { parameters, hasParenthesis } = retrieveRootParamters(parameter)\n\n\t// Check if root is an object destructuring\n\tif (!inference.query && parameters.includes('query')) inference.query = true\n\tif (!inference.headers && parameters.includes('headers'))\n\t\tinference.headers = true\n\tif (!inference.body && parameters.includes('body')) inference.body = true\n\tif (!inference.cookie && parameters.includes('cookie'))\n\t\tinference.cookie = true\n\tif (!inference.set && parameters.includes('set')) inference.set = true\n\tif (!inference.server && parameters.includes('server'))\n\t\tinference.server = true\n\tif (!inference.request && parameters.includes('request'))\n\t\tinference.request = true\n\tif (!inference.route && parameters.includes('route')) inference.route = true\n\n\tif (hasParenthesis) return `{ ${parameters.join(', ')} }`\n\n\treturn parameters.join(', ')\n}\n\nconst findEndIndex = (\n\ttype: string,\n\tcontent: string,\n\tindex?: number | undefined\n) => {\n\tconst newLineIndex = content.indexOf(type + '\\n', index)\n\tconst newTabIndex = content.indexOf(type + '\\t', index)\n\tconst commaIndex = content.indexOf(type + ',', index)\n\tconst semicolonIndex = content.indexOf(type + ';', index)\n\tconst emptyIndex = content.indexOf(type + ' ', index)\n\n\t// Pick the smallest index that is not -1 or 0\n\treturn (\n\t\t[newLineIndex, newTabIndex, commaIndex, semicolonIndex, emptyIndex]\n\t\t\t.filter((i) => i > 0)\n\t\t\t.sort((a, b) => a - b)[0] || -1\n\t)\n}\n\nconst findEndQueryBracketIndex = (\n\ttype: string,\n\tcontent: string,\n\tindex?: number | undefined\n) => {\n\tconst bracketEndIndex = content.indexOf(type + ']', index)\n\tconst singleQuoteIndex = content.indexOf(type + \"'\", index)\n\tconst doubleQuoteIndex = content.indexOf(type + '\"', index)\n\n\t// Pick the smallest index that is not -1 or 0\n\treturn (\n\t\t[bracketEndIndex, singleQuoteIndex, doubleQuoteIndex]\n\t\t\t.filter((i) => i > 0)\n\t\t\t.sort((a, b) => a - b)[0] || -1\n\t)\n}\n\n/**\n * Find alias of variable from function body\n *\n * @example\n * ```typescript\n * findAlias('body', '{ const a = body, b = body }') // => ['a', 'b']\n * ```\n */\nexport const findAlias = (type: string, body: string, depth = 0) => {\n\tif (depth > 5) return []\n\n\tconst aliases: string[] = []\n\n\tlet content = body\n\n\twhile (true) {\n\t\tlet index = findEndIndex(' = ' + type, content)\n\t\t// V8 engine minified the code\n\t\tif (index === -1) index = findEndIndex('=' + type, content)\n\n\t\tif (index === -1) {\n\t\t\t/**\n\t\t\t * Check if pattern is at the end of the string\n\t\t\t *\n\t\t\t * @example\n\t\t\t * ```typescript\n\t\t\t * 'const a = body' // true\n\t\t\t * ```\n\t\t\t **/\n\t\t\tlet lastIndex = content.indexOf(' = ' + type)\n\t\t\tif (lastIndex === -1) lastIndex = content.indexOf('=' + type)\n\n\t\t\tif (lastIndex + 3 + type.length !== content.length) break\n\n\t\t\tindex = lastIndex\n\t\t}\n\n\t\tconst part = content.slice(0, index)\n\n\t\t// V8 engine minified the code\n\t\tconst lastPart = part.lastIndexOf(' ')\n\t\t/**\n\t\t * aliased variable last character\n\t\t *\n\t\t * @example\n\t\t * ```typescript\n\t\t * const { hello } = body // } is the last character\n\t\t * ```\n\t\t **/\n\t\tlet variable = part.slice(lastPart !== -1 ? lastPart + 1 : -1)\n\n\t\t// Variable is using object destructuring, find the bracket pair\n\t\tif (variable === '}') {\n\t\t\tconst [start, end] = bracketPairRangeReverse(part)\n\n\t\t\taliases.push(removeColonAlias(content.slice(start, end)))\n\n\t\t\tcontent = content.slice(index + 3 + type.length)\n\n\t\t\tcontinue\n\t\t}\n\n\t\t// Remove comma\n\t\twhile (variable.charCodeAt(0) === 44) variable = variable.slice(1)\n\t\twhile (variable.charCodeAt(0) === 9) variable = variable.slice(1)\n\n\t\tif (!variable.includes('(')) aliases.push(variable)\n\n\t\tcontent = content.slice(index + 3 + type.length)\n\t}\n\n\tfor (const alias of aliases) {\n\t\tif (alias.charCodeAt(0) === 123) continue\n\n\t\tconst deepAlias = findAlias(alias, body)\n\t\tif (deepAlias.length > 0) aliases.push(...deepAlias)\n\t}\n\n\treturn aliases\n}\n\n// ? This is normalized to dot notation in Bun\n// const accessor = <T extends string, P extends string>(parent: T, prop: P) =>\n// \t[\n// \t\tparent + '.' + prop,\n// \t\tparent + '[\"' + prop + '\"]',\n// \t\tparent + \"['\" + prop + \"']\"\n// \t] as const\n\nexport const extractMainParameter = (parameter: string) => {\n\tif (!parameter) return\n\n\tif (parameter.charCodeAt(0) !== 123) return parameter\n\n\tparameter = parameter.slice(2, -2)\n\n\tconst hasComma = parameter.includes(',')\n\tif (!hasComma) {\n\t\t// This happens when spread operator is used as the only parameter\n\t\tif (parameter.includes('...'))\n\t\t\treturn parameter.slice(parameter.indexOf('...') + 3)\n\n\t\treturn\n\t}\n\n\tconst spreadIndex = parameter.indexOf('...')\n\tif (spreadIndex === -1) return\n\n\t// Spread parameter is always the last parameter, no need for further checking\n\treturn parameter.slice(spreadIndex + 3).trimEnd()\n}\n\n/**\n * Analyze if context is mentioned in body\n */\nexport const inferBodyReference = (\n\tcode: string,\n\taliases: string[],\n\tinference: Sucrose.Inference\n) => {\n\tconst access = (type: string, alias: string) =>\n\t\tcode.includes(alias + '.' + type) ||\n\t\tcode.includes(alias + '[\"' + type + '\"]') ||\n\t\tcode.includes(alias + \"['\" + type + \"']\")\n\n\tfor (const alias of aliases) {\n\t\tif (!alias) continue\n\n\t\t// Scan object destructured property\n\t\tif (alias.charCodeAt(0) === 123) {\n\t\t\tconst parameters = retrieveRootParamters(alias).parameters\n\n\t\t\tif (!inference.query && parameters.includes('query'))\n\t\t\t\tinference.query = true\n\n\t\t\tif (!inference.headers && parameters.includes('headers'))\n\t\t\t\tinference.headers = true\n\n\t\t\tif (!inference.body && parameters.includes('body'))\n\t\t\t\tinference.body = true\n\n\t\t\tif (!inference.cookie && parameters.includes('cookie'))\n\t\t\t\tinference.cookie = true\n\n\t\t\tif (!inference.set && parameters.includes('set'))\n\t\t\t\tinference.set = true\n\n\t\t\tif (!inference.query && parameters.includes('server'))\n\t\t\t\tinference.server = true\n\n\t\t\tif (!inference.request && parameters.includes('request'))\n\t\t\t\tinference.request = true\n\n\t\t\tif (!inference.route && parameters.includes('route'))\n\t\t\t\tinference.route = true\n\n\t\t\tcontinue\n\t\t}\n\n\t\tif (!inference.query && access('query', alias)) inference.query = true\n\n\t\tif (\n\t\t\tcode.includes('return ' + alias) ||\n\t\t\tcode.includes('return ' + alias + '.query')\n\t\t)\n\t\t\tinference.query = true\n\n\t\tif (!inference.headers && access('headers', alias))\n\t\t\tinference.headers = true\n\n\t\tif (!inference.body && access('body', alias)) inference.body = true\n\n\t\tif (!inference.cookie && access('cookie', alias))\n\t\t\tinference.cookie = true\n\n\t\tif (!inference.set && access('set', alias)) inference.set = true\n\t\tif (!inference.server && access('server', alias))\n\t\t\tinference.server = true\n\n\t\tif (\n\t\t\tinference.query &&\n\t\t\tinference.headers &&\n\t\t\tinference.body &&\n\t\t\tinference.cookie &&\n\t\t\tinference.set &&\n\t\t\tinference.server &&\n\t\t\tinference.server &&\n\t\t\tinference.route\n\t\t)\n\t\t\tbreak\n\t}\n\n\treturn aliases\n}\n\nexport const removeDefaultParameter = (parameter: string) => {\n\twhile (true) {\n\t\tconst index = parameter.indexOf('=')\n\t\tif (index === -1) break\n\n\t\tconst commaIndex = parameter.indexOf(',', index)\n\t\tconst bracketIndex = parameter.indexOf('}', index)\n\n\t\tconst end =\n\t\t\t[commaIndex, bracketIndex]\n\t\t\t\t.filter((i) => i > 0)\n\t\t\t\t.sort((a, b) => a - b)[0] || -1\n\n\t\tif (end === -1) {\n\t\t\tparameter = parameter.slice(0, index)\n\n\t\t\tbreak\n\t\t}\n\n\t\tparameter = parameter.slice(0, index) + parameter.slice(end)\n\t}\n\n\treturn parameter\n\t\t.split(',')\n\t\t.map((i) => i.trim())\n\t\t.join(', ')\n}\n\nexport const isContextPassToFunction = (\n\tcontext: string,\n\tbody: string,\n\tinference: Sucrose.Inference\n) => {\n\t// ! Function is passed to another function, assume as all is accessed\n\ttry {\n\t\tconst captureFunction = new RegExp(`(?:\\\\w)\\\\((?:.*)?${context}`, 'gs')\n\t\tcaptureFunction.test(body)\n\n\t\t/*\n\t\tSince JavaScript engine already format the code (removing whitespace, newline, etc.),\n\t\twe can safely assume that the next character is either a closing bracket or a comma\n\t\tif the function is passed to another function\n\t\t*/\n\t\tconst nextChar = body.charCodeAt(captureFunction.lastIndex)\n\n\t\tif (nextChar === 41 || nextChar === 44) {\n\t\t\tinference.query = true\n\t\t\tinference.headers = true\n\t\t\tinference.body = true\n\t\t\tinference.cookie = true\n\t\t\tinference.set = true\n\t\t\tinference.server = true\n\t\t\tinference.route = true\n\t\t\tinference.request = true\n\n\t\t\treturn true\n\t\t}\n\n\t\treturn false\n\t} catch (error) {\n\t\tconsole.log(\n\t\t\t'[Sucrose] warning: unexpected isContextPassToFunction error, you may continue development as usual but please report the following to maintainers:'\n\t\t)\n\t\tconsole.log('--- body ---')\n\t\tconsole.log(body)\n\t\tconsole.log('--- context ---')\n\t\tconsole.log(context)\n\n\t\treturn true\n\t}\n}\n\nexport const sucrose = (\n\tlifeCycle: Sucrose.LifeCycle,\n\tinference: Sucrose.Inference = {\n\t\tquery: false,\n\t\theaders: false,\n\t\tbody: false,\n\t\tcookie: false,\n\t\tset: false,\n\t\tserver: false,\n\t\trequest: false,\n\t\troute: false\n\t}\n): Sucrose.Inference => {\n\tconst events = []\n\n\tif (lifeCycle.handler && typeof lifeCycle.handler === 'function')\n\t\tevents.push(lifeCycle.handler)\n\n\tif (lifeCycle.request?.length) events.push(...lifeCycle.request)\n\tif (lifeCycle.beforeHandle?.length) events.push(...lifeCycle.beforeHandle)\n\tif (lifeCycle.parse?.length) events.push(...lifeCycle.parse)\n\tif (lifeCycle.error?.length) events.push(...lifeCycle.error)\n\tif (lifeCycle.transform?.length) events.push(...lifeCycle.transform)\n\tif (lifeCycle.afterHandle?.length) events.push(...lifeCycle.afterHandle)\n\tif (lifeCycle.mapResponse?.length) events.push(...lifeCycle.mapResponse)\n\tif (lifeCycle.afterResponse?.length) events.push(...lifeCycle.afterResponse)\n\n\tfor (const e of events) {\n\t\tif (!e) continue\n\n\t\tconst event = 'fn' in e ? e.fn : e\n\n\t\t// parse can be either a function or string\n\t\tif(typeof event !== \"function\") continue\n\n\t\tconst [parameter, body, { isArrowReturn }] = separateFunction(\n\t\t\tevent.toString()\n\t\t)\n\n\t\tconst rootParameters = findParameterReference(parameter, inference)\n\t\tconst mainParameter = extractMainParameter(rootParameters)\n\n\t\tif (mainParameter) {\n\t\t\tconst aliases = findAlias(mainParameter, body)\n\t\t\taliases.splice(0, -1, mainParameter)\n\n\t\t\tif (!isContextPassToFunction(mainParameter, body, inference))\n\t\t\t\tinferBodyReference(body, aliases, inference)\n\n\t\t\tif (\n\t\t\t\t!inference.query &&\n\t\t\t\tbody.includes('return ' + mainParameter + '.query')\n\t\t\t)\n\t\t\t\tinference.query = true\n\t\t}\n\n\t\tif (\n\t\t\tinference.query &&\n\t\t\tinference.headers &&\n\t\t\tinference.body &&\n\t\t\tinference.cookie &&\n\t\t\tinference.set &&\n\t\t\tinference.server &&\n\t\t\tinference.request &&\n\t\t\tinference.route\n\t\t)\n\t\t\tbreak\n\t}\n\n\treturn inference\n}\n",
    "import { parse, serialize } from 'cookie'\n\nimport { decode as decodeURIComponent } from './deuri'\n\nimport { isNotEmpty, unsignCookie } from './utils'\nimport { InvalidCookieSignature } from './error'\n\nimport type { Context } from './context'\nimport type { Prettify } from './types'\n\nexport interface CookieOptions {\n\t/**\n\t * Specifies the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.3|Domain Set-Cookie attribute}. By default, no\n\t * domain is set, and most clients will consider the cookie to apply to only\n\t * the current domain.\n\t */\n\tdomain?: string | undefined\n\n\t/**\n\t * Specifies the `Date` object to be the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.1|`Expires` `Set-Cookie` attribute}. By default,\n\t * no expiration is set, and most clients will consider this a \"non-persistent cookie\" and will delete\n\t * it on a condition like exiting a web browser application.\n\t *\n\t * *Note* the {@link https://tools.ietf.org/html/rfc6265#section-5.3|cookie storage model specification}\n\t * states that if both `expires` and `maxAge` are set, then `maxAge` takes precedence, but it is\n\t * possible not all clients by obey this, so if both are set, they should\n\t * point to the same date and time.\n\t */\n\texpires?: Date | undefined\n\t/**\n\t * Specifies the boolean value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.6|`HttpOnly` `Set-Cookie` attribute}.\n\t * When truthy, the `HttpOnly` attribute is set, otherwise it is not. By\n\t * default, the `HttpOnly` attribute is not set.\n\t *\n\t * *Note* be careful when setting this to true, as compliant clients will\n\t * not allow client-side JavaScript to see the cookie in `document.cookie`.\n\t */\n\thttpOnly?: boolean | undefined\n\t/**\n\t * Specifies the number (in seconds) to be the value for the `Max-Age`\n\t * `Set-Cookie` attribute. The given number will be converted to an integer\n\t * by rounding down. By default, no maximum age is set.\n\t *\n\t * *Note* the {@link https://tools.ietf.org/html/rfc6265#section-5.3|cookie storage model specification}\n\t * states that if both `expires` and `maxAge` are set, then `maxAge` takes precedence, but it is\n\t * possible not all clients by obey this, so if both are set, they should\n\t * point to the same date and time.\n\t */\n\tmaxAge?: number | undefined\n\t/**\n\t * Specifies the value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.4|`Path` `Set-Cookie` attribute}.\n\t * By default, the path is considered the \"default path\".\n\t */\n\tpath?: string | undefined\n\t/**\n\t * Specifies the `string` to be the value for the [`Priority` `Set-Cookie` attribute][rfc-west-cookie-priority-00-4.1].\n\t *\n\t * - `'low'` will set the `Priority` attribute to `Low`.\n\t * - `'medium'` will set the `Priority` attribute to `Medium`, the default priority when not set.\n\t * - `'high'` will set the `Priority` attribute to `High`.\n\t *\n\t * More information about the different priority levels can be found in\n\t * [the specification][rfc-west-cookie-priority-00-4.1].\n\t *\n\t * **note** This is an attribute that has not yet been fully standardized, and may change in the future.\n\t * This also means many clients may ignore this attribute until they understand it.\n\t */\n\tpriority?: 'low' | 'medium' | 'high' | undefined\n\t/**\n\t * Specifies the `boolean` value for the [`Partitioned` `Set-Cookie`](rfc-cutler-httpbis-partitioned-cookies)\n\t * attribute. When truthy, the `Partitioned` attribute is set, otherwise it is not. By default, the\n\t * `Partitioned` attribute is not set.\n\t *\n\t * **note** This is an attribute that has not yet been fully standardized, and may change in the future.\n\t * This also means many clients may ignore this attribute until they understand it.\n\t *\n\t * More information about can be found in [the proposal](https://github.com/privacycg/CHIPS)\n\t */\n\tpartitioned?: boolean | undefined\n\t/**\n\t * Specifies the boolean or string to be the value for the {@link https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7|`SameSite` `Set-Cookie` attribute}.\n\t *\n\t * - `true` will set the `SameSite` attribute to `Strict` for strict same\n\t * site enforcement.\n\t * - `false` will not set the `SameSite` attribute.\n\t * - `'lax'` will set the `SameSite` attribute to Lax for lax same site\n\t * enforcement.\n\t * - `'strict'` will set the `SameSite` attribute to Strict for strict same\n\t * site enforcement.\n\t *  - `'none'` will set the SameSite attribute to None for an explicit\n\t *  cross-site cookie.\n\t *\n\t * More information about the different enforcement levels can be found in {@link https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-4.1.2.7|the specification}.\n\t *\n\t * *note* This is an attribute that has not yet been fully standardized, and may change in the future. This also means many clients may ignore this attribute until they understand it.\n\t */\n\tsameSite?: true | false | 'lax' | 'strict' | 'none' | undefined\n\t/**\n\t * Specifies the boolean value for the {@link https://tools.ietf.org/html/rfc6265#section-5.2.5|`Secure` `Set-Cookie` attribute}. When truthy, the\n\t * `Secure` attribute is set, otherwise it is not. By default, the `Secure` attribute is not set.\n\t *\n\t * *Note* be careful when setting this to `true`, as compliant clients will\n\t * not send the cookie back to the server in the future if the browser does\n\t * not have an HTTPS connection.\n\t */\n\tsecure?: boolean | undefined\n\n\t/**\n\t * Secret key for signing cookie\n\t *\n\t * If array is passed, will use Key Rotation.\n\t *\n\t * Key rotation is when an encryption key is retired\n\t * and replaced by generating a new cryptographic key.\n\t */\n\tsecrets?: string | string[]\n}\n\nexport type ElysiaCookie = Prettify<\n\tCookieOptions & {\n\t\tvalue?: unknown\n\t}\n>\n\ntype Updater<T> = T | ((value: T) => T)\n\nexport class Cookie<T> implements ElysiaCookie {\n\tconstructor(\n\t\tprivate name: string,\n\t\tprivate jar: Record<string, ElysiaCookie>,\n\t\tprivate initial: Partial<ElysiaCookie> = {}\n\t) {}\n\n\tget cookie() {\n\t\treturn this.jar[this.name] ?? this.initial\n\t}\n\n\tset cookie(jar: ElysiaCookie) {\n\t\tif (!(this.name in this.jar)) this.jar[this.name] = this.initial\n\n\t\tthis.jar[this.name] = jar\n\t}\n\n\tprotected get setCookie() {\n\t\tif (!(this.name in this.jar)) this.jar[this.name] = this.initial\n\n\t\treturn this.jar[this.name]\n\t}\n\n\tprotected set setCookie(jar: ElysiaCookie) {\n\t\tthis.cookie = jar\n\t}\n\n\tget value(): T {\n\t\treturn this.cookie.value as T\n\t}\n\n\tset value(value: T) {\n\t\tthis.setCookie.value = value\n\t}\n\n\tget expires() {\n\t\treturn this.cookie.expires\n\t}\n\n\tset expires(expires) {\n\t\tthis.setCookie.expires = expires\n\t}\n\n\tget maxAge() {\n\t\treturn this.cookie.maxAge\n\t}\n\n\tset maxAge(maxAge) {\n\t\tthis.setCookie.maxAge = maxAge\n\t}\n\n\tget domain() {\n\t\treturn this.cookie.domain\n\t}\n\n\tset domain(domain) {\n\t\tthis.setCookie.domain = domain\n\t}\n\n\tget path() {\n\t\treturn this.cookie.path\n\t}\n\n\tset path(path) {\n\t\tthis.setCookie.path = path\n\t}\n\n\tget secure() {\n\t\treturn this.cookie.secure\n\t}\n\n\tset secure(secure) {\n\t\tthis.setCookie.secure = secure\n\t}\n\n\tget httpOnly() {\n\t\treturn this.cookie.httpOnly\n\t}\n\n\tset httpOnly(httpOnly) {\n\t\tthis.setCookie.httpOnly = httpOnly\n\t}\n\n\tget sameSite() {\n\t\treturn this.cookie.sameSite\n\t}\n\n\tset sameSite(sameSite) {\n\t\tthis.setCookie.sameSite = sameSite\n\t}\n\n\tget priority() {\n\t\treturn this.cookie.priority\n\t}\n\n\tset priority(priority) {\n\t\tthis.setCookie.priority = priority\n\t}\n\n\tget partitioned() {\n\t\treturn this.cookie.partitioned\n\t}\n\n\tset partitioned(partitioned) {\n\t\tthis.setCookie.partitioned = partitioned\n\t}\n\n\tget secrets() {\n\t\treturn this.cookie.secrets\n\t}\n\n\tset secrets(secrets) {\n\t\tthis.setCookie.secrets = secrets\n\t}\n\n\tupdate(config: Updater<Partial<ElysiaCookie>>) {\n\t\tthis.setCookie = Object.assign(\n\t\t\tthis.cookie,\n\t\t\ttypeof config === 'function' ? config(this.cookie) : config\n\t\t)\n\n\t\treturn this\n\t}\n\n\tset(config: Updater<Partial<ElysiaCookie>>) {\n\t\tthis.setCookie = Object.assign(\n\t\t\t{\n\t\t\t\t...this.initial,\n\t\t\t\tvalue: this.value\n\t\t\t},\n\t\t\ttypeof config === 'function' ? config(this.cookie) : config\n\t\t)\n\n\t\treturn this\n\t}\n\n\tremove() {\n\t\tif (this.value === undefined) return\n\n\t\tthis.set({\n\t\t\texpires: new Date(0),\n\t\t\tmaxAge: 0,\n\t\t\tvalue: ''\n\t\t})\n\n\t\treturn this\n\t}\n\n\ttoString() {\n\t\treturn typeof this.value === 'object'\n\t\t\t? JSON.stringify(this.value)\n\t\t\t: (this.value?.toString() ?? '')\n\t}\n}\n\nexport const createCookieJar = (\n\tset: Context['set'],\n\tstore: Record<string, ElysiaCookie>,\n\tinitial?: Partial<ElysiaCookie>\n): Record<string, Cookie<unknown>> => {\n\tif (!set.cookie) set.cookie = {}\n\n\treturn new Proxy(store, {\n\t\tget(_, key: string) {\n\t\t\tif (key in store)\n\t\t\t\treturn new Cookie(\n\t\t\t\t\tkey,\n\t\t\t\t\tset.cookie as Record<string, ElysiaCookie>,\n\t\t\t\t\tObject.assign({}, initial ?? {}, store[key])\n\t\t\t\t)\n\n\t\t\treturn new Cookie(\n\t\t\t\tkey,\n\t\t\t\tset.cookie as Record<string, ElysiaCookie>,\n\t\t\t\tObject.assign({}, initial)\n\t\t\t)\n\t\t}\n\t}) as Record<string, Cookie<unknown>>\n}\n\nexport const parseCookie = async (\n\tset: Context['set'],\n\tcookieString?: string | null,\n\t{\n\t\tsecrets,\n\t\tsign,\n\t\t...initial\n\t}: CookieOptions & {\n\t\tsign?: true | string | string[]\n\t} = {}\n) => {\n\tif (!cookieString) return createCookieJar(set, {}, initial)\n\n\tconst isStringKey = typeof secrets === 'string'\n\tif (sign && sign !== true && !Array.isArray(sign)) sign = [sign]\n\n\tconst jar: Record<string, ElysiaCookie> = {}\n\n\tconst cookies = parse(cookieString)\n\tfor (const [name, v] of Object.entries(cookies)) {\n\t\tif (v === undefined) continue\n\n\t\tlet value = decodeURIComponent(v)\n\n\t\tif (sign === true || sign?.includes(name)) {\n\t\t\tif (!secrets)\n\t\t\t\tthrow new Error('No secret is provided to cookie plugin')\n\n\t\t\tif (isStringKey) {\n\t\t\t\tconst temp = await unsignCookie(value as string, secrets)\n\t\t\t\tif (temp === false) throw new InvalidCookieSignature(name)\n\n\t\t\t\tvalue = temp\n\t\t\t} else {\n\t\t\t\tlet decoded = true\n\t\t\t\tfor (let i = 0; i < secrets.length; i++) {\n\t\t\t\t\tconst temp = await unsignCookie(value as string, secrets[i])\n\n\t\t\t\t\tif (temp !== false) {\n\t\t\t\t\t\tdecoded = true\n\t\t\t\t\t\tvalue = temp\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!decoded) throw new InvalidCookieSignature(name)\n\t\t\t}\n\t\t}\n\n\t\tjar[name] = {\n\t\t\tvalue\n\t\t}\n\t}\n\n\treturn createCookieJar(set, jar, initial)\n}\n\nexport const serializeCookie = (cookies: Context['set']['cookie']) => {\n\tif (!cookies || !isNotEmpty(cookies)) return undefined\n\n\tconst set: string[] = []\n\n\tfor (const [key, property] of Object.entries(cookies)) {\n\t\tif (!key || !property) continue\n\n\t\tconst value = property.value\n\t\tif (value === undefined || value === null) continue\n\n\t\tset.push(\n\t\t\tserialize(\n\t\t\t\tkey,\n\t\t\t\ttypeof value === 'object' ? JSON.stringify(value) : value + '',\n\t\t\t\tproperty\n\t\t\t)\n\t\t)\n\t}\n\n\tif (set.length === 0) return undefined\n\tif (set.length === 1) return set[0]\n\n\treturn set\n}\n",
    "// deuri doesn't support cjs output so I have to copy the code here\n// @see https://github.com/re-utils/deuri\n\n/* eslint-disable */\nconst hex: number[] = []\nfor (let i = 48; i < 58; i++) hex[i] = i - 48\n\n// A - F (index 65 - 70)\n// a - f (index 97 - 102)\nfor (let i = 0; i < 6; i++)\n\t// 10 to 15\n\thex[i + 65] = hex[i + 97] = i + 10\n\nconst calcHex = (a: number, b: number): number => {\n\tif (a in hex && b in hex) return (hex[a] << 4) | hex[b]\n\n\treturn 255\n}\n\n// Map bytes to character to a transition\nconst type: number[] = [\n\t...new Array(128).fill(0),\n\t...new Array(16).fill(1),\n\t...new Array(16).fill(2),\n\t...new Array(32).fill(3),\n\n\t4,\n\t4,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t5,\n\t6,\n\t7,\n\t7,\n\t7,\n\t7,\n\t7,\n\t7,\n\t7,\n\t7,\n\t7,\n\t7,\n\t7,\n\t7,\n\t8,\n\t7,\n\t7,\n\t10,\n\t9,\n\t9,\n\t9,\n\t11,\n\t4,\n\t4,\n\t4,\n\t4,\n\t4,\n\t4,\n\t4,\n\t4,\n\t4,\n\t4,\n\t4\n]\n\n// Maps a state to a new state when adding a transition\nconst next = [\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 12, 0, 0, 0, 0, 24, 36, 48, 60, 72, 84,\n\t96, 0, 12, 12, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 24, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 24, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 48, 48, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 48, 48, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 48, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n]\n\n// Maps the current transition to a mask that needs to apply to the byte\nconst mask = type.map(\n\t(val) =>\n\t\t[\n\t\t\t0x7f, 0x3f, 0x3f, 0x3f, 0x00, 0x1f, 0x0f, 0x0f, 0x0f, 0x07, 0x07,\n\t\t\t0x07\n\t\t][val]\n)\n\n/**\n * Decode the full string\n */\nexport const decode = (url: string): string | null => {\n\tlet percentPosition = url.indexOf('%')\n\tif (percentPosition === -1) return url\n\n\t// Ensure percentPosition always has 2 chars after\n\tlet end = url.length - 3\n\tif (percentPosition > end) return null\n\n\tlet decoded = '',\n\t\tstart = 0,\n\t\tcodepoint = 0,\n\t\tstartOfOctets = percentPosition,\n\t\t// UTF_ACCEPT\n\t\tstate = 12,\n\t\tbyte: number\n\n\tfor (;;) {\n\t\tbyte = calcHex(\n\t\t\turl.charCodeAt(percentPosition + 1),\n\t\t\turl.charCodeAt(percentPosition + 2)\n\t\t)\n\t\tstate = next[state + type[byte]]\n\t\tif (state === 0) return null\n\t\tif (state === 12) {\n\t\t\tdecoded += url.substring(start, startOfOctets)\n\n\t\t\t// Calculate current codepoint\n\t\t\tcodepoint = (codepoint << 6) | (byte & mask[byte])\n\n\t\t\tif (codepoint > 0xffff)\n\t\t\t\tdecoded += String.fromCharCode(\n\t\t\t\t\t0xd7c0 + (codepoint >> 10),\n\t\t\t\t\t0xdc00 + (codepoint & 0x3ff)\n\t\t\t\t)\n\t\t\telse decoded += String.fromCharCode(codepoint)\n\n\t\t\t// Search next encoded component\n\t\t\tstart = percentPosition + 3\n\n\t\t\tpercentPosition = url.indexOf('%', start)\n\t\t\tif (percentPosition === -1) return decoded + url.substring(start)\n\n\t\t\t// Ensure percentPosition always has 2 chars after\n\t\t\tif (percentPosition > end) return null\n\n\t\t\tstartOfOctets = percentPosition\n\t\t\tcodepoint = 0\n\t\t} else {\n\t\t\t// Check next %\n\t\t\tpercentPosition += 3\n\t\t\tif (percentPosition > end || url.charCodeAt(percentPosition) !== 37)\n\t\t\t\treturn null\n\n\t\t\t// Calculate current codepoint\n\t\t\tcodepoint = (codepoint << 6) | (byte & mask[byte])\n\t\t}\n\t}\n}\n\n/**\n * Encode URI components\n */\nexport const encode = (str: string): string | null =>\n\tstr.isWellFormed() ? encodeURIComponent(str) : null\n\n/**\n * Decode a substring of an input string\n */\nexport const decodeSegment = (\n\turl: string,\n\tstart: number,\n\tend: number\n): string | null => {\n\tlet percentPosition = url.indexOf('%')\n\tif (percentPosition === -1) return url\n\n\t// Ensure percentPosition always has 2 chars after\n\tend -= 3\n\tif (percentPosition > end) return null\n\n\tlet decoded = '',\n\t\tcodepoint = 0,\n\t\tstartOfOctets = percentPosition,\n\t\t// UTF_ACCEPT\n\t\tstate = 12,\n\t\tbyte: number\n\n\tfor (;;) {\n\t\tbyte = calcHex(\n\t\t\turl.charCodeAt(percentPosition + 1),\n\t\t\turl.charCodeAt(percentPosition + 2)\n\t\t)\n\t\tstate = next[state + type[byte]]\n\t\tif (state === 0) return null\n\t\tif (state === 12) {\n\t\t\tdecoded += url.substring(start, startOfOctets)\n\n\t\t\t// Calculate current codepoint\n\t\t\tcodepoint = (codepoint << 6) | (byte & mask[byte])\n\n\t\t\tif (codepoint > 0xffff)\n\t\t\t\tdecoded += String.fromCharCode(\n\t\t\t\t\t0xd7c0 + (codepoint >> 10),\n\t\t\t\t\t0xdc00 + (codepoint & 0x3ff)\n\t\t\t\t)\n\t\t\telse decoded += String.fromCharCode(codepoint)\n\n\t\t\t// Search next encoded component\n\t\t\tstart = percentPosition + 3\n\n\t\t\tpercentPosition = url.indexOf('%', start)\n\t\t\tif (percentPosition === -1) return decoded + url.substring(start)\n\n\t\t\t// Ensure percentPosition always has 2 chars after\n\t\t\tif (percentPosition > end) return null\n\n\t\t\tstartOfOctets = percentPosition\n\t\t\tcodepoint = 0\n\t\t} else {\n\t\t\t// Check next %\n\t\t\tpercentPosition += 3\n\t\t\tif (percentPosition > end || url.charCodeAt(percentPosition) !== 37)\n\t\t\t\treturn null\n\n\t\t\t// Calculate current codepoint\n\t\t\tcodepoint = (codepoint << 6) | (byte & mask[byte])\n\t\t}\n\t}\n}\n",
    "/* eslint-disable sonarjs/no-nested-switch */\n/* eslint-disable sonarjs/no-duplicate-string */\nimport { isNotEmpty, hasHeaderShorthand, StatusMap } from '../../utils'\n\nimport { Cookie, serializeCookie } from '../../cookies'\n\nimport type { Context } from '../../context'\nimport type { AnyLocalHook } from '../../types'\nimport { ElysiaCustomStatusResponse } from '../../error'\nimport { ElysiaFile } from '../../universal/file'\n\n// type SetResponse = Omit<Context['set'], 'status'> & {\n// \tstatus: number\n// }\n\nconst handleFile = (response: File | Blob, set?: Context['set']) => {\n\tconst size = response.size\n\n\tif (\n\t\t(!set && size) ||\n\t\t(size &&\n\t\t\tset &&\n\t\t\tset.status !== 206 &&\n\t\t\tset.status !== 304 &&\n\t\t\tset.status !== 412 &&\n\t\t\tset.status !== 416)\n\t) {\n\t\tif (set) {\n\t\t\tif (set.headers instanceof Headers) {\n\t\t\t\tlet setHeaders: Record<string, any> = {\n\t\t\t\t\t'accept-ranges': 'bytes',\n\t\t\t\t\t'content-range': `bytes 0-${size - 1}/${size}`,\n\t\t\t\t\t'transfer-encoding': 'chunked'\n\t\t\t\t}\n\n\t\t\t\tif (hasHeaderShorthand)\n\t\t\t\t\tsetHeaders = (set.headers as unknown as Headers).toJSON()\n\t\t\t\telse {\n\t\t\t\t\tsetHeaders = {}\n\t\t\t\t\tfor (const [key, value] of set.headers.entries())\n\t\t\t\t\t\tif (key in set.headers) setHeaders[key] = value\n\t\t\t\t}\n\n\t\t\t\treturn new Response(response as Blob, {\n\t\t\t\t\tstatus: set.status as number,\n\t\t\t\t\theaders: setHeaders\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tif (isNotEmpty(set.headers))\n\t\t\t\treturn new Response(response as Blob, {\n\t\t\t\t\tstatus: set.status as number,\n\t\t\t\t\theaders: Object.assign(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t'accept-ranges': 'bytes',\n\t\t\t\t\t\t\t'content-range': `bytes 0-${size - 1}/${size}`,\n\t\t\t\t\t\t\t'transfer-encoding': 'chunked'\n\t\t\t\t\t\t} as any,\n\t\t\t\t\t\tset.headers\n\t\t\t\t\t)\n\t\t\t\t})\n\t\t}\n\n\t\treturn new Response(response as Blob, {\n\t\t\theaders: {\n\t\t\t\t'accept-ranges': 'bytes',\n\t\t\t\t'content-range': `bytes 0-${size - 1}/${size}`,\n\t\t\t\t'transfer-encoding': 'chunked'\n\t\t\t}\n\t\t})\n\t}\n\n\treturn new Response(response as Blob)\n}\n\nexport const parseSetCookies = (headers: Headers, setCookie: string[]) => {\n\tif (!headers) return headers\n\n\theaders.delete('set-cookie')\n\n\tfor (let i = 0; i < setCookie.length; i++) {\n\t\tconst index = setCookie[i].indexOf('=')\n\n\t\theaders.append(\n\t\t\t'set-cookie',\n\t\t\t`${setCookie[i].slice(0, index)}=${\n\t\t\t\tsetCookie[i].slice(index + 1) || ''\n\t\t\t}`\n\t\t)\n\t}\n\n\treturn headers\n}\n\nconst responseToSetHeaders = (response: Response, set?: Context['set']) => {\n\tif (set?.headers) {\n\t\tif (response) {\n\t\t\tif (hasHeaderShorthand)\n\t\t\t\t// @ts-expect-error\n\t\t\t\tObject.assign(set.headers, response.headers.toJSON())\n\t\t\telse\n\t\t\t\tfor (const [key, value] of response.headers.entries())\n\t\t\t\t\tif (key in set.headers) set.headers[key] = value\n\t\t}\n\n\t\tif (set.status === 200) set.status = response.status\n\n\t\t// ? `content-encoding` prevent response streaming\n\t\tif (set.headers['content-encoding'])\n\t\t\tdelete set.headers['content-encoding']\n\n\t\treturn set\n\t}\n\n\tif (!response)\n\t\treturn {\n\t\t\theaders: {},\n\t\t\tstatus: set?.status ?? 200\n\t\t}\n\n\tif (hasHeaderShorthand) {\n\t\tset = {\n\t\t\t// @ts-expect-error\n\t\t\theaders: response.headers.toJSON(),\n\t\t\tstatus: set?.status ?? 200\n\t\t}\n\n\t\t// ? `content-encoding` prevent response streaming\n\t\tif (set.headers['content-encoding'])\n\t\t\tdelete set.headers['content-encoding']\n\n\t\treturn set\n\t}\n\n\tset = {\n\t\theaders: {},\n\t\tstatus: set?.status ?? 200\n\t}\n\n\tfor (const [key, value] of response.headers.entries()) {\n\t\t// ? `content-encoding` prevent response streaming\n\n\t\tif (key === 'content-encoding') continue\n\n\t\tif (key in set.headers) set.headers[key] = value\n\t}\n\n\treturn set\n}\n\nconst handleStream = async (\n\tgenerator: Generator | AsyncGenerator,\n\tset?: Context['set'],\n\trequest?: Request\n) => {\n\tlet init = generator.next()\n\tif (init instanceof Promise) init = await init\n\n\tif (init.done) {\n\t\tif (set) return mapResponse(init.value, set, request)\n\t\treturn mapCompactResponse(init.value, request)\n\t}\n\n\tif (set?.headers) {\n\t\tif (!set.headers['transfer-encoding'])\n\t\t\tset.headers['transfer-encoding'] = 'chunked'\n\t\tif (!set.headers['content-type'])\n\t\t\tset.headers['content-type'] = 'text/event-stream; charset=utf-8'\n\t} else {\n\t\tset = {\n\t\t\tstatus: 200,\n\t\t\theaders: {\n\t\t\t\t'content-type': 'text/event-stream; charset=utf-8',\n\t\t\t\t'transfer-encoding': 'chunked'\n\t\t\t}\n\t\t}\n\t}\n\n\treturn new Response(\n\t\tnew ReadableStream({\n\t\t\tasync start(controller) {\n\t\t\t\tlet end = false\n\n\t\t\t\trequest?.signal?.addEventListener('abort', () => {\n\t\t\t\t\tend = true\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcontroller.close()\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// nothing\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tif (init.value !== undefined && init.value !== null) {\n\t\t\t\t\tif (typeof init.value === 'object')\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcontroller.enqueue(\n\t\t\t\t\t\t\t\t// @ts-expect-error this is a valid operation\n\t\t\t\t\t\t\t\tBuffer.from(JSON.stringify(init.value))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\tcontroller.enqueue(\n\t\t\t\t\t\t\t\t// @ts-expect-error this is a valid operation\n\t\t\t\t\t\t\t\tBuffer.from(init.value.toString())\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tcontroller.enqueue(\n\t\t\t\t\t\t\t// @ts-expect-error this is a valid operation\n\t\t\t\t\t\t\tBuffer.from(init.value.toString())\n\t\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tfor await (const chunk of generator) {\n\t\t\t\t\tif (end) break\n\t\t\t\t\tif (chunk === undefined || chunk === null) continue\n\n\t\t\t\t\tif (typeof chunk === 'object')\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tcontroller.enqueue(\n\t\t\t\t\t\t\t\t// @ts-expect-error this is a valid operation\n\t\t\t\t\t\t\t\tBuffer.from(JSON.stringify(chunk))\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t} catch {\n\t\t\t\t\t\t\tcontroller.enqueue(\n\t\t\t\t\t\t\t\t// @ts-expect-error this is a valid operation\n\t\t\t\t\t\t\t\tBuffer.from(chunk.toString())\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tcontroller.enqueue(\n\t\t\t\t\t\t\t// @ts-expect-error this is a valid operation\n\t\t\t\t\t\t\tBuffer.from(chunk.toString())\n\t\t\t\t\t\t)\n\n\t\t\t\t\t// Wait for the next event loop\n\t\t\t\t\t// Otherwise the data will be mixed up\n\t\t\t\t\tawait new Promise<void>((resolve) =>\n\t\t\t\t\t\tsetTimeout(() => resolve(), 0)\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tcontroller.close()\n\t\t\t\t} catch {\n\t\t\t\t\t// nothing\n\t\t\t\t}\n\t\t\t}\n\t\t}),\n\t\tset as any\n\t)\n}\n\nexport async function* streamResponse(response: Response) {\n\tconst body = response.body\n\n\tif (!body) return\n\n\tconst reader = body.getReader()\n\tconst decoder = new TextDecoder()\n\n\ttry {\n\t\twhile (true) {\n\t\t\tconst { done, value } = await reader.read()\n\t\t\tif (done) break\n\n\t\t\tyield decoder.decode(value)\n\t\t}\n\t} finally {\n\t\treader.releaseLock()\n\t}\n}\n\nexport const handleSet = (set: Context['set']) => {\n\tif (typeof set.status === 'string') set.status = StatusMap[set.status]\n\n\tif (set.cookie && isNotEmpty(set.cookie)) {\n\t\tconst cookie = serializeCookie(set.cookie)\n\n\t\tif (cookie) set.headers['set-cookie'] = cookie\n\t}\n\n\tif (set.headers['set-cookie'] && Array.isArray(set.headers['set-cookie'])) {\n\t\tset.headers = parseSetCookies(\n\t\t\tnew Headers(set.headers as any) as Headers,\n\t\t\tset.headers['set-cookie']\n\t\t) as any\n\t}\n}\n\nexport const mergeResponseWithSetHeaders = (\n\tresponse: Response,\n\tset: Context['set']\n) => {\n\tif (\n\t\t(response as Response).status !== set.status &&\n\t\tset.status !== 200 &&\n\t\t((response.status as number) <= 300 ||\n\t\t\t(response.status as number) > 400)\n\t)\n\t\tresponse = new Response(response.body, {\n\t\t\theaders: response.headers,\n\t\t\tstatus: set.status as number\n\t\t})\n\n\tlet isCookieSet = false\n\n\tif (set.headers instanceof Headers)\n\t\tfor (const key of set.headers.keys()) {\n\t\t\tif (key === 'set-cookie') {\n\t\t\t\tif (isCookieSet) continue\n\n\t\t\t\tisCookieSet = true\n\n\t\t\t\tfor (const cookie of set.headers.getSetCookie())\n\t\t\t\t\tresponse.headers.append('set-cookie', cookie)\n\t\t\t} else response.headers.append(key, set.headers?.get(key) ?? '')\n\t\t}\n\telse\n\t\tfor (const key in set.headers)\n\t\t\t(response as Response).headers.append(key, set.headers[key] as any)\n\n\treturn response\n}\n\nexport const mapResponse = (\n\tresponse: unknown,\n\tset: Context['set'],\n\trequest?: Request\n): Response => {\n\tif (isNotEmpty(set.headers) || set.status !== 200 || set.cookie) {\n\t\thandleSet(set)\n\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\treturn new Response(response as string, set as any)\n\n\t\t\tcase 'Array':\n\t\t\tcase 'Object':\n\t\t\t\treturn Response.json(response, set as any)\n\n\t\t\tcase 'ElysiaFile':\n\t\t\t\treturn handleFile((response as ElysiaFile).value as File)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as Blob, set as any)\n\n\t\t\tcase 'ElysiaCustomStatusResponse':\n\t\t\t\tset.status = (response as ElysiaCustomStatusResponse<200>).code\n\n\t\t\t\treturn mapResponse(\n\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\tset,\n\t\t\t\t\trequest\n\t\t\t\t)\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\tif (\n\t\t\t\t\t!set.headers['content-type']?.startsWith(\n\t\t\t\t\t\t'text/event-stream'\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\tset.headers['content-type'] =\n\t\t\t\t\t\t'text/event-stream; charset=utf-8'\n\n\t\t\t\trequest?.signal?.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t{\n\t\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\t\tif (request?.signal && !request?.signal?.aborted)\n\t\t\t\t\t\t\t\t(response as ReadableStream).cancel()\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn new Response(response as ReadableStream, set as any)\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('', set as any)\n\n\t\t\t\treturn Response.json(response, set as any)\n\n\t\t\tcase 'Response':\n\t\t\t\tresponse = mergeResponseWithSetHeaders(\n\t\t\t\t\tresponse as Response,\n\t\t\t\t\tset\n\t\t\t\t)\n\n\t\t\t\tif (\n\t\t\t\t\t!(response as Response).headers.has('content-length') &&\n\t\t\t\t\t(response as Response).headers.get('transfer-encoding') ===\n\t\t\t\t\t\t'chunked'\n\t\t\t\t)\n\t\t\t\t\treturn handleStream(\n\t\t\t\t\t\tstreamResponse(response as Response),\n\t\t\t\t\t\tresponseToSetHeaders(response as Response, set),\n\t\t\t\t\t\trequest\n\t\t\t\t\t) as any\n\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Promise':\n\t\t\t\treturn (response as Promise<any>).then((x) =>\n\t\t\t\t\tmapResponse(x, set, request)\n\t\t\t\t) as any\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapResponse((response as Function)(), set, request)\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response(\n\t\t\t\t\t(response as number | boolean).toString(),\n\t\t\t\t\tset as any\n\t\t\t\t)\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as any)\n\n\t\t\t\treturn new Response(response?.toString(), set as any)\n\n\t\t\tcase 'FormData':\n\t\t\t\treturn new Response(response as FormData, set as any)\n\n\t\t\tdefault:\n\t\t\t\tif (response instanceof Response) {\n\t\t\t\t\tresponse = mergeResponseWithSetHeaders(\n\t\t\t\t\t\tresponse as Response,\n\t\t\t\t\t\tset\n\t\t\t\t\t)\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t(response as Response).headers.get(\n\t\t\t\t\t\t\t'transfer-encoding'\n\t\t\t\t\t\t) === 'chunked'\n\t\t\t\t\t)\n\t\t\t\t\t\treturn handleStream(\n\t\t\t\t\t\t\tstreamResponse(response as Response),\n\t\t\t\t\t\t\tresponseToSetHeaders(response as Response, set),\n\t\t\t\t\t\t\trequest\n\t\t\t\t\t\t) as any\n\n\t\t\t\t\treturn response as Response\n\t\t\t\t}\n\n\t\t\t\tif (response instanceof Promise)\n\t\t\t\t\treturn response.then((x) => mapResponse(x, set)) as any\n\n\t\t\t\tif (response instanceof Error)\n\t\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\t\tif (response instanceof ElysiaCustomStatusResponse) {\n\t\t\t\t\tset.status = (\n\t\t\t\t\t\tresponse as ElysiaCustomStatusResponse<200>\n\t\t\t\t\t).code\n\n\t\t\t\t\treturn mapResponse(\n\t\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\t\tset,\n\t\t\t\t\t\trequest\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.next === 'function')\n\t\t\t\t\treturn handleStream(response as any, set, request) as any\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.then === 'function')\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\treturn response.then((x) => mapResponse(x, set)) as any\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.toResponse === 'function')\n\t\t\t\t\treturn mapResponse((response as any).toResponse(), set)\n\n\t\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\t\treturn new Response(\n\t\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\t\tset as any\n\t\t\t\t\t\t) as any\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new Response(response as any, set as any)\n\t\t}\n\t}\n\n\tif (\n\t\tresponse instanceof Response &&\n\t\t!(response as Response).headers.has('content-length') &&\n\t\t(response as Response).headers.get('transfer-encoding') === 'chunked'\n\t)\n\t\treturn handleStream(\n\t\t\tstreamResponse(response),\n\t\t\tresponseToSetHeaders(response as Response, set),\n\t\t\trequest\n\t\t) as any\n\n\t// Stream response defers a 'set' API, assume that it may include 'set'\n\tif (\n\t\t// @ts-expect-error\n\t\ttypeof response?.next === 'function' ||\n\t\tresponse instanceof ReadableStream\n\t)\n\t\treturn handleStream(response as any, set, request) as any\n\n\treturn mapCompactResponse(response, request)\n}\n\nexport const mapEarlyResponse = (\n\tresponse: unknown,\n\tset: Context['set'],\n\trequest?: Request\n): Response | undefined => {\n\tif (response === undefined || response === null) return\n\n\tif (isNotEmpty(set.headers) || set.status !== 200 || set.cookie) {\n\t\thandleSet(set)\n\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\treturn new Response(response as string, set as any)\n\n\t\t\tcase 'Array':\n\t\t\tcase 'Object':\n\t\t\t\treturn Response.json(response, set as any)\n\n\t\t\tcase 'ElysiaFile':\n\t\t\t\treturn handleFile((response as ElysiaFile).value as File)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as File | Blob, set)\n\n\t\t\tcase 'ElysiaCustomStatusResponse':\n\t\t\t\tset.status = (response as ElysiaCustomStatusResponse<200>).code\n\n\t\t\t\treturn mapEarlyResponse(\n\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\tset,\n\t\t\t\t\trequest\n\t\t\t\t)\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\tif (\n\t\t\t\t\t!set.headers['content-type']?.startsWith(\n\t\t\t\t\t\t'text/event-stream'\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t\t\tset.headers['content-type'] =\n\t\t\t\t\t\t'text/event-stream; charset=utf-8'\n\n\t\t\t\trequest?.signal?.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t{\n\t\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\t\tif (request?.signal && !request?.signal?.aborted)\n\t\t\t\t\t\t\t\t(response as ReadableStream).cancel()\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn new Response(response as ReadableStream, set as any)\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return\n\n\t\t\t\treturn Response.json(response, set as any)\n\n\t\t\tcase 'Response':\n\t\t\t\tresponse = mergeResponseWithSetHeaders(\n\t\t\t\t\tresponse as Response,\n\t\t\t\t\tset\n\t\t\t\t)\n\n\t\t\t\tif (\n\t\t\t\t\t!(response as Response).headers.has('content-length') &&\n\t\t\t\t\t(response as Response).headers.get('transfer-encoding') ===\n\t\t\t\t\t\t'chunked'\n\t\t\t\t)\n\t\t\t\t\treturn handleStream(\n\t\t\t\t\t\tstreamResponse(response as Response),\n\t\t\t\t\t\tresponseToSetHeaders(response as Response, set),\n\t\t\t\t\t\trequest\n\t\t\t\t\t) as any\n\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as Promise<unknown>).then((x) =>\n\t\t\t\t\tmapEarlyResponse(x, set)\n\t\t\t\t)\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapEarlyResponse((response as Function)(), set)\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response(\n\t\t\t\t\t(response as number | boolean).toString(),\n\t\t\t\t\tset as any\n\t\t\t\t)\n\n\t\t\tcase 'FormData':\n\t\t\t\treturn new Response(response as FormData)\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as any)\n\n\t\t\t\treturn new Response(response?.toString(), set as any)\n\n\t\t\tdefault:\n\t\t\t\tif (response instanceof Response) {\n\t\t\t\t\tresponse = mergeResponseWithSetHeaders(\n\t\t\t\t\t\tresponse as Response,\n\t\t\t\t\t\tset\n\t\t\t\t\t)\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t(response as Response).headers.get(\n\t\t\t\t\t\t\t'transfer-encoding'\n\t\t\t\t\t\t) === 'chunked'\n\t\t\t\t\t)\n\t\t\t\t\t\treturn handleStream(\n\t\t\t\t\t\t\tstreamResponse(response as Response),\n\t\t\t\t\t\t\tresponseToSetHeaders(response as Response, set),\n\t\t\t\t\t\t\trequest\n\t\t\t\t\t\t) as any\n\n\t\t\t\t\treturn response as Response\n\t\t\t\t}\n\n\t\t\t\tif (response instanceof Promise)\n\t\t\t\t\treturn response.then((x) => mapEarlyResponse(x, set)) as any\n\n\t\t\t\tif (response instanceof Error)\n\t\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\t\tif (response instanceof ElysiaCustomStatusResponse) {\n\t\t\t\t\tset.status = (\n\t\t\t\t\t\tresponse as ElysiaCustomStatusResponse<200>\n\t\t\t\t\t).code\n\n\t\t\t\t\treturn mapEarlyResponse(\n\t\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\t\tset,\n\t\t\t\t\t\trequest\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.next === 'function')\n\t\t\t\t\treturn handleStream(response as any, set, request) as any\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.then === 'function')\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\treturn response.then((x) => mapEarlyResponse(x, set)) as any\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.toResponse === 'function')\n\t\t\t\t\treturn mapEarlyResponse((response as any).toResponse(), set)\n\n\t\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\t\treturn new Response(\n\t\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\t\tset as any\n\t\t\t\t\t\t) as any\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new Response(response as any, set as any)\n\t\t}\n\t} else\n\t\tswitch (response?.constructor?.name) {\n\t\t\tcase 'String':\n\t\t\t\treturn new Response(response as string)\n\n\t\t\tcase 'Array':\n\t\t\tcase 'Object':\n\t\t\t\treturn Response.json(response, set as any)\n\n\t\t\tcase 'ElysiaFile':\n\t\t\t\treturn handleFile((response as ElysiaFile).value as File)\n\n\t\t\tcase 'Blob':\n\t\t\t\treturn handleFile(response as File | Blob, set)\n\n\t\t\tcase 'ElysiaCustomStatusResponse':\n\t\t\t\tset.status = (response as ElysiaCustomStatusResponse<200>).code\n\n\t\t\t\treturn mapEarlyResponse(\n\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\tset,\n\t\t\t\t\trequest\n\t\t\t\t)\n\n\t\t\tcase 'ReadableStream':\n\t\t\t\trequest?.signal?.addEventListener(\n\t\t\t\t\t'abort',\n\t\t\t\t\t{\n\t\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\t\tif (request?.signal && !request?.signal?.aborted)\n\t\t\t\t\t\t\t\t(response as ReadableStream).cancel()\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tonce: true\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t\treturn new Response(response as ReadableStream, {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'Content-Type': 'text/event-stream; charset=utf-8'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase undefined:\n\t\t\t\tif (!response) return new Response('')\n\n\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\tcase 'Response':\n\t\t\t\tif (\n\t\t\t\t\t!(response as Response).headers.has('content-length') &&\n\t\t\t\t\t(response as Response).headers.get('transfer-encoding') ===\n\t\t\t\t\t\t'chunked'\n\t\t\t\t)\n\t\t\t\t\treturn handleStream(\n\t\t\t\t\t\tstreamResponse(response as Response),\n\t\t\t\t\t\tresponseToSetHeaders(response as Response),\n\t\t\t\t\t\trequest\n\t\t\t\t\t) as any\n\n\t\t\t\treturn response as Response\n\n\t\t\tcase 'Promise':\n\t\t\t\t// @ts-ignore\n\t\t\t\treturn (response as Promise<unknown>).then((x) => {\n\t\t\t\t\tconst r = mapEarlyResponse(x, set)\n\t\t\t\t\tif (r !== undefined) return r\n\t\t\t\t})\n\n\t\t\tcase 'Error':\n\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\tcase 'Function':\n\t\t\t\treturn mapCompactResponse((response as Function)(), request)\n\n\t\t\tcase 'Number':\n\t\t\tcase 'Boolean':\n\t\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\t\tcase 'Cookie':\n\t\t\t\tif (response instanceof Cookie)\n\t\t\t\t\treturn new Response(response.value, set as any)\n\n\t\t\t\treturn new Response(response?.toString(), set as any)\n\n\t\t\tcase 'FormData':\n\t\t\t\treturn new Response(response as FormData)\n\n\t\t\tdefault:\n\t\t\t\tif (response instanceof Response) return response\n\n\t\t\t\tif (response instanceof Promise)\n\t\t\t\t\treturn response.then((x) => mapEarlyResponse(x, set)) as any\n\n\t\t\t\tif (response instanceof Error)\n\t\t\t\t\treturn errorToResponse(response as Error, set)\n\n\t\t\t\tif (response instanceof ElysiaCustomStatusResponse) {\n\t\t\t\t\tset.status = (\n\t\t\t\t\t\tresponse as ElysiaCustomStatusResponse<200>\n\t\t\t\t\t).code\n\n\t\t\t\t\treturn mapEarlyResponse(\n\t\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\t\tset,\n\t\t\t\t\t\trequest\n\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.next === 'function')\n\t\t\t\t\treturn handleStream(response as any, set, request) as any\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.then === 'function')\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\treturn response.then((x) => mapEarlyResponse(x, set)) as any\n\n\t\t\t\t// @ts-expect-error\n\t\t\t\tif (typeof response?.toResponse === 'function')\n\t\t\t\t\treturn mapEarlyResponse((response as any).toResponse(), set)\n\n\t\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\t\tif (!set.headers['Content-Type'])\n\t\t\t\t\t\t\tset.headers['Content-Type'] = 'application/json'\n\n\t\t\t\t\t\treturn new Response(\n\t\t\t\t\t\t\tJSON.stringify(response),\n\t\t\t\t\t\t\tset as any\n\t\t\t\t\t\t) as any\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn new Response(response as any)\n\t\t}\n}\n\nexport const mapCompactResponse = (\n\tresponse: unknown,\n\trequest?: Request\n): Response => {\n\tswitch (response?.constructor?.name) {\n\t\tcase 'String':\n\t\t\treturn new Response(response as string)\n\n\t\tcase 'Object':\n\t\tcase 'Array':\n\t\t\treturn Response.json(response)\n\n\t\tcase 'ElysiaFile':\n\t\t\treturn handleFile((response as ElysiaFile).value as File)\n\n\t\tcase 'Blob':\n\t\t\treturn handleFile(response as File | Blob)\n\n\t\tcase 'ElysiaCustomStatusResponse':\n\t\t\treturn mapResponse(\n\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t{\n\t\t\t\t\tstatus: (response as ElysiaCustomStatusResponse<200>).code,\n\t\t\t\t\theaders: {}\n\t\t\t\t}\n\t\t\t)\n\n\t\tcase 'ReadableStream':\n\t\t\trequest?.signal?.addEventListener(\n\t\t\t\t'abort',\n\t\t\t\t{\n\t\t\t\t\thandleEvent() {\n\t\t\t\t\t\tif (request?.signal && !request?.signal?.aborted)\n\t\t\t\t\t\t\t(response as ReadableStream).cancel()\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tonce: true\n\t\t\t\t}\n\t\t\t)\n\n\t\t\treturn new Response(response as ReadableStream, {\n\t\t\t\theaders: {\n\t\t\t\t\t'Content-Type': 'text/event-stream; charset=utf-8'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase undefined:\n\t\t\tif (!response) return new Response('')\n\n\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\theaders: {\n\t\t\t\t\t'content-type': 'application/json'\n\t\t\t\t}\n\t\t\t})\n\n\t\tcase 'Response':\n\t\t\tif (\n\t\t\t\t(response as Response).headers.get('transfer-encoding') ===\n\t\t\t\t'chunked'\n\t\t\t)\n\t\t\t\treturn handleStream(\n\t\t\t\t\tstreamResponse(response as Response),\n\t\t\t\t\tresponseToSetHeaders(response as Response),\n\t\t\t\t\trequest\n\t\t\t\t) as any\n\n\t\t\treturn response as Response\n\n\t\tcase 'Error':\n\t\t\treturn errorToResponse(response as Error)\n\n\t\tcase 'Promise':\n\t\t\treturn (response as any as Promise<unknown>).then((x) =>\n\t\t\t\tmapCompactResponse(x, request)\n\t\t\t) as any\n\n\t\t// ? Maybe response or Blob\n\t\tcase 'Function':\n\t\t\treturn mapCompactResponse((response as Function)(), request)\n\n\t\tcase 'Number':\n\t\tcase 'Boolean':\n\t\t\treturn new Response((response as number | boolean).toString())\n\n\t\tcase 'FormData':\n\t\t\treturn new Response(response as FormData)\n\n\t\tdefault:\n\t\t\tif (response instanceof Response) return response\n\n\t\t\tif (response instanceof Promise)\n\t\t\t\treturn response.then((x) =>\n\t\t\t\t\tmapCompactResponse(x, request)\n\t\t\t\t) as any\n\n\t\t\tif (response instanceof Error)\n\t\t\t\treturn errorToResponse(response as Error)\n\n\t\t\tif (response instanceof ElysiaCustomStatusResponse)\n\t\t\t\treturn mapResponse(\n\t\t\t\t\t(response as ElysiaCustomStatusResponse<200>).response,\n\t\t\t\t\t{\n\t\t\t\t\t\tstatus: (response as ElysiaCustomStatusResponse<200>)\n\t\t\t\t\t\t\t.code,\n\t\t\t\t\t\theaders: {}\n\t\t\t\t\t}\n\t\t\t\t)\n\n\t\t\t// @ts-expect-error\n\t\t\tif (typeof response?.next === 'function')\n\t\t\t\treturn handleStream(response as any, undefined, request) as any\n\n\t\t\t// @ts-expect-error\n\t\t\tif (typeof response?.then === 'function')\n\t\t\t\t// @ts-expect-error\n\t\t\t\treturn response.then((x) => mapResponse(x, set)) as any\n\n\t\t\t// @ts-expect-error\n\t\t\tif (typeof response?.toResponse === 'function')\n\t\t\t\treturn mapCompactResponse((response as any).toResponse())\n\n\t\t\tif ('charCodeAt' in (response as any)) {\n\t\t\t\tconst code = (response as any).charCodeAt(0)\n\n\t\t\t\tif (code === 123 || code === 91) {\n\t\t\t\t\treturn new Response(JSON.stringify(response), {\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'Content-Type': 'application/json'\n\t\t\t\t\t\t}\n\t\t\t\t\t}) as any\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new Response(response as any)\n\t}\n}\n\nexport const errorToResponse = (error: Error, set?: Context['set']) =>\n\tnew Response(\n\t\tJSON.stringify({\n\t\t\tname: error?.name,\n\t\t\tmessage: error?.message,\n\t\t\tcause: error?.cause\n\t\t}),\n\t\t{\n\t\t\tstatus:\n\t\t\t\tset?.status !== 200 ? ((set?.status as number) ?? 500) : 500,\n\t\t\theaders: set?.headers as any\n\t\t}\n\t)\n\nexport const createStaticHandler = (\n\thandle: unknown,\n\thooks: Partial<AnyLocalHook>,\n\tsetHeaders: Context['set']['headers'] = {}\n): (() => Response) | undefined => {\n\tif (typeof handle === 'function') return\n\n\tconst response = mapResponse(handle, {\n\t\theaders: setHeaders\n\t})\n\n\tif (\n\t\t!hooks.parse?.length &&\n\t\t!hooks.transform?.length &&\n\t\t!hooks.beforeHandle?.length &&\n\t\t!hooks.afterHandle?.length\n\t)\n\t\treturn response.clone.bind(response)\n}\n",
    "import {\n\tmapResponse,\n\tmapEarlyResponse,\n\tmapCompactResponse,\n\tcreateStaticHandler\n} from './handler'\n\nimport { getLoosePath } from '../../utils'\n\nimport type { ElysiaAdapter } from '../types'\n\nexport const WebStandardAdapter: ElysiaAdapter = {\n\tname: 'web-standard',\n\tisWebStandard: true,\n\thandler: {\n\t\tmapResponse,\n\t\tmapEarlyResponse,\n\t\tmapCompactResponse,\n\t\tcreateStaticHandler\n\t},\n\tcomposeHandler: {\n\t\tmapResponseContext: 'c.request',\n\t\tpreferWebstandardHeaders: true,\n\t\t// @ts-ignore Bun specific\n\t\theaders:\n\t\t\t'c.headers = {}\\n' +\n\t\t\t'for (const [key, value] of c.request.headers.entries())' +\n\t\t\t'c.headers[key] = value\\n',\n\t\tparser: {\n\t\t\tjson(isOptional) {\n\t\t\t\tif (isOptional)\n\t\t\t\t\treturn `try{c.body=await c.request.json()}catch{}\\n`\n\t\t\t\treturn `c.body=await c.request.json()\\n`\n\t\t\t},\n\t\t\ttext() {\n\t\t\t\treturn `c.body=await c.request.text()\\n`\n\t\t\t},\n\t\t\turlencoded() {\n\t\t\t\treturn `c.body=parseQuery(await c.request.text())\\n`\n\t\t\t},\n\t\t\tarrayBuffer() {\n\t\t\t\treturn `c.body=await c.request.arrayBuffer()\\n`\n\t\t\t},\n\t\t\tformData(isOptional) {\n\t\t\t\tlet fnLiteral = '\\nc.body={}\\n'\n\n\t\t\t\tif (isOptional)\n\t\t\t\t\tfnLiteral += `let form;try{form=await c.request.formData()}catch{}`\n\t\t\t\telse fnLiteral += `const form=await c.request.formData()\\n`\n\n\t\t\t\treturn (\n\t\t\t\t\tfnLiteral +\n\t\t\t\t\t`for(const key of form.keys()){` +\n\t\t\t\t\t`if(c.body[key]) continue\\n` +\n\t\t\t\t\t`const value=form.getAll(key)\\n` +\n\t\t\t\t\t`if(value.length===1)` +\n\t\t\t\t\t`c.body[key]=value[0]\\n` +\n\t\t\t\t\t`else c.body[key]=value` +\n\t\t\t\t\t`}`\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t},\n\tcomposeGeneralHandler: {\n\t\tparameters: 'r',\n\t\tcreateContext(app) {\n\t\t\tlet decoratorsLiteral = ''\n\t\t\tlet fnLiteral = ''\n\n\t\t\t// @ts-expect-error private\n\t\t\tconst defaultHeaders = app.setHeaders\n\n\t\t\t// @ts-ignore\n\t\t\tfor (const key of Object.keys(app.singleton.decorator))\n\t\t\t\tdecoratorsLiteral += `,${key}: decorator['${key}']`\n\n\t\t\tconst standardHostname =\n\t\t\t\tapp.config.handler?.standardHostname ?? true\n\t\t\tconst hasTrace = !!app.event.trace?.length\n\n\t\t\tfnLiteral +=\n\t\t\t\t`const u=r.url,` +\n\t\t\t\t`s=u.indexOf('/',${standardHostname ? 11 : 7}),` +\n\t\t\t\t`qi=u.indexOf('?', s + 1)\\n` +\n\t\t\t\t`let p\\n` +\n\t\t\t\t`if(qi===-1)p=u.substring(s)\\n` +\n\t\t\t\t`else p=u.substring(s, qi)\\n`\n\n\t\t\tif (hasTrace) fnLiteral += `const id=randomId()\\n`\n\n\t\t\tfnLiteral +=\n\t\t\t\t`const c={request:r,` +\n\t\t\t\t`store,` +\n\t\t\t\t`qi,` +\n\t\t\t\t`path:p,` +\n\t\t\t\t`url:u,` +\n\t\t\t\t`redirect,` +\n\t\t\t\t`error,` +\n\t\t\t\t`set:{headers:`\n\n\t\t\tfnLiteral += Object.keys(defaultHeaders ?? {}).length\n\t\t\t\t? 'Object.assign({}, app.setHeaders)'\n\t\t\t\t: '{}'\n\n\t\t\tfnLiteral += `,status:200}`\n\n\t\t\t// @ts-expect-error private\n\t\t\tif (app.inference.server)\n\t\t\t\tfnLiteral += `,get server(){return app.getServer()}`\n\t\t\tif (hasTrace) fnLiteral += ',[ELYSIA_REQUEST_ID]:id'\n\t\t\tfnLiteral += decoratorsLiteral\n\t\t\tfnLiteral += `}\\n`\n\n\t\t\treturn fnLiteral\n\t\t},\n\t\twebsocket(app) {\n\t\t\tlet fnLiteral = ''\n\n\t\t\tconst wsPaths = app.router.static.ws\n\t\t\tconst router = app.router.http\n\n\t\t\trouter.build()\n\n\t\t\tif (\n\t\t\t\tObject.keys(wsPaths).length ||\n\t\t\t\trouter.root.ws ||\n\t\t\t\trouter.history.find((x) => x['0'] === 'ws')\n\t\t\t) {\n\t\t\t\tfnLiteral += `if(r.method==='GET'){switch(p){`\n\n\t\t\t\tfor (const [path, index] of Object.entries(wsPaths)) {\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t`case'${path}':` +\n\t\t\t\t\t\t(app.config.strictPath !== true\n\t\t\t\t\t\t\t? `case'${getLoosePath(path)}':`\n\t\t\t\t\t\t\t: '') +\n\t\t\t\t\t\t`if(r.headers.get('upgrade')==='websocket')` +\n\t\t\t\t\t\t`return ht[${index}].composed(c)\\n`\n\t\t\t\t}\n\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`default:` +\n\t\t\t\t\t`if(r.headers.get('upgrade')==='websocket'){` +\n\t\t\t\t\t`const route=router.find('ws',p)\\n` +\n\t\t\t\t\t`if(route){` +\n\t\t\t\t\t`c.params=route.params\\n` +\n\t\t\t\t\t`if(route.store.handler)return route.store.handler(c)\\n` +\n\t\t\t\t\t`return (route.store.handler=route.store.compile())(c)` +\n\t\t\t\t\t`}` +\n\t\t\t\t\t`}` +\n\t\t\t\t\t`break` +\n\t\t\t\t\t`}` +\n\t\t\t\t\t`}`\n\t\t\t}\n\n\t\t\treturn fnLiteral\n\t\t},\n\t\terror404(hasEventHook, hasErrorHook) {\n\t\t\tlet findDynamicRoute = `if(route===null)return `\n\n\t\t\tif (hasErrorHook)\n\t\t\t\tfindDynamicRoute += `app.handleError(c,notFound,false,${this.parameters})`\n\t\t\telse\n\t\t\t\tfindDynamicRoute += hasEventHook\n\t\t\t\t\t? `new Response(error404Message,{` +\n\t\t\t\t\t\t`status:c.set.status===200?404:c.set.status,` +\n\t\t\t\t\t\t`headers:c.set.headers` +\n\t\t\t\t\t\t`})`\n\t\t\t\t\t: `error404.clone()`\n\n\t\t\treturn {\n\t\t\t\tdeclare: hasErrorHook\n\t\t\t\t\t? ''\n\t\t\t\t\t: `const error404Message=notFound.message.toString()\\n` +\n\t\t\t\t\t\t`const error404=new Response(error404Message,{status:404})\\n`,\n\t\t\t\tcode: findDynamicRoute\n\t\t\t}\n\t\t}\n\t},\n\tcomposeError: {\n\t\tmapResponseContext: '',\n\t\tvalidationError:\n\t\t\t`return new Response(` +\n\t\t\t`error.message,` +\n\t\t\t`{` +\n\t\t\t`headers:Object.assign(` +\n\t\t\t`{'content-type':'application/json'},` +\n\t\t\t`set.headers` +\n\t\t\t`),` +\n\t\t\t`status:set.status` +\n\t\t\t`}` +\n\t\t\t`)`,\n\t\tunknownError:\n\t\t\t`return new Response(` +\n\t\t\t`error.message,` +\n\t\t\t`{headers:set.headers,status:error.status??set.status??500}` +\n\t\t\t`)`\n\t},\n\tlisten() {\n\t\treturn () => {\n\t\t\tthrow new Error(\n\t\t\t\t'WebStandard does not support listen, you might want to export default Elysia.fetch instead'\n\t\t\t)\n\t\t}\n\t}\n}\n",
    "import type { Context } from '../../context'\nimport type { AnyLocalHook } from '../../types'\n\nimport {\n\tmapResponse,\n\tmapEarlyResponse,\n\tmapCompactResponse,\n\tcreateStaticHandler\n} from '../web-standard/handler'\n\nexport const createNativeStaticHandler = (\n\thandle: unknown,\n\thooks: AnyLocalHook,\n\tsetHeaders: Context['set']['headers'] = {}\n): (() => Response) | undefined => {\n\tif (typeof handle === 'function' || handle instanceof Blob) return\n\n\tif (\n\t\ttypeof handle === 'object' &&\n\t\thandle?.toString() === '[object HTMLBundle]'\n\t)\n\t\t// Bun HTMLBundle\n\t\treturn () => handle as any\n\n\tconst response = mapResponse(handle, {\n\t\theaders: setHeaders\n\t})\n\n\tif (\n\t\t!hooks.parse?.length &&\n\t\t!hooks.transform?.length &&\n\t\t!hooks.beforeHandle?.length &&\n\t\t!hooks.afterHandle?.length\n\t) {\n\t\tif (!response.headers.has('content-type'))\n\t\t\tresponse.headers.append('content-type', 'text/plain;charset=utf-8')\n\n\t\treturn response.clone.bind(response)\n\t}\n}\n\nexport {\n\tmapResponse,\n\tmapEarlyResponse,\n\tmapCompactResponse,\n\tcreateStaticHandler\n}\n",
    "import { isNumericString } from '../utils'\n\nimport type {\n\tServerWebSocket,\n\tServerWebSocketSendStatus,\n\tBufferSource,\n\tWebSocketHandler\n} from './bun'\n\nimport type { TSchema } from '@sinclair/typebox'\nimport type { TypeCheck } from '../type-system'\n\nimport type { FlattenResponse, WSParseHandler } from './types'\nimport type { MaybeArray, Prettify, RouteSchema } from '../types'\nimport { ValidationError } from '../error'\n\nexport const websocket: WebSocketHandler<any> = {\n\topen(ws) {\n\t\tws.data.open?.(ws)\n\t},\n\tmessage(ws, message) {\n\t\tws.data.message?.(ws, message)\n\t},\n\tdrain(ws) {\n\t\tws.data.drain?.(ws)\n\t},\n\tclose(ws, code, reason) {\n\t\tws.data.close?.(ws, code, reason)\n\t}\n}\n\ntype ElysiaServerWebSocket = Omit<\n\tServerWebSocket<unknown>,\n\t'send' | 'ping' | 'pong' | 'publish'\n>\n\nexport class ElysiaWS<Context = unknown, Route extends RouteSchema = {}>\n\timplements ElysiaServerWebSocket\n{\n\tvalidator?: TypeCheck<TSchema>;\n\t['~types']?: {\n\t\tvalidator: Prettify<Route>\n\t}\n\n\tget id() {\n\t\t// @ts-ignore\n\t\treturn this.data.id\n\t}\n\n\tconstructor(\n\t\tpublic raw: ServerWebSocket<{\n\t\t\tid?: string\n\t\t\tvalidator?: TypeCheck<TSchema>\n\t\t}>,\n\t\tpublic data: Context,\n\t\tpublic body: Route['body'] = undefined\n\t) {\n\t\tthis.validator = raw.data?.validator\n\n\t\tthis.sendText = raw.sendText.bind(raw)\n\t\tthis.sendBinary = raw.sendBinary.bind(raw)\n\t\tthis.close = raw.close.bind(raw)\n\t\tthis.terminate = raw.terminate.bind(raw)\n\t\tthis.publishText = raw.publishText.bind(raw)\n\t\tthis.publishBinary = raw.publishBinary.bind(raw)\n\t\tthis.subscribe = raw.subscribe.bind(raw)\n\t\tthis.unsubscribe = raw.unsubscribe.bind(raw)\n\t\tthis.isSubscribed = raw.isSubscribed.bind(raw)\n\t\tthis.cork = raw.cork.bind(raw)\n\t\tthis.remoteAddress = raw.remoteAddress\n\t\tthis.binaryType = raw.binaryType\n\t\tthis.data = raw.data as any\n\n\t\tthis.send = this.send.bind(this)\n\t\tthis.ping = this.ping.bind(this)\n\t\tthis.pong = this.pong.bind(this)\n\t\tthis.publish = this.publish.bind(this)\n\t}\n\n\t/**\n\t * Sends a message to the client.\n\t *\n\t * @param data The data to send.\n\t * @param compress Should the data be compressed? If the client does not support compression, this is ignored.\n\t * @example\n\t * ws.send(\"Hello!\");\n\t * ws.send(\"Compress this.\", true);\n\t * ws.send(new Uint8Array([1, 2, 3, 4]));\n\t */\n\tsend(\n\t\tdata: FlattenResponse<Route['response']> | BufferSource,\n\t\tcompress?: boolean\n\t): ServerWebSocketSendStatus {\n\t\tif (Buffer.isBuffer(data))\n\t\t\treturn this.raw.send(data as unknown as BufferSource, compress)\n\n\t\tif (this.validator?.Check(data) === false)\n\t\t\treturn this.raw.send(\n\t\t\t\tnew ValidationError('message', this.validator, data).message\n\t\t\t)\n\n\t\tif (typeof data === 'object') data = JSON.stringify(data) as any\n\n\t\treturn this.raw.send(data as unknown as string, compress)\n\t}\n\n\t/**\n\t * Sends a ping.\n\t *\n\t * @param data The data to send\n\t */\n\tping(\n\t\tdata?: FlattenResponse<Route['response']> | BufferSource\n\t): ServerWebSocketSendStatus {\n\t\tif (Buffer.isBuffer(data))\n\t\t\treturn this.raw.ping(data as unknown as BufferSource)\n\n\t\tif (this.validator?.Check(data) === false)\n\t\t\treturn this.raw.send(\n\t\t\t\tnew ValidationError('message', this.validator, data).message\n\t\t\t)\n\n\t\tif (typeof data === 'object') data = JSON.stringify(data) as any\n\n\t\treturn this.raw.ping(data as string)\n\t}\n\n\t/**\n\t * Sends a pong.\n\t *\n\t * @param data The data to send\n\t */\n\tpong(\n\t\tdata?: FlattenResponse<Route['response']> | BufferSource\n\t): ServerWebSocketSendStatus {\n\t\tif (Buffer.isBuffer(data))\n\t\t\treturn this.raw.pong(data as unknown as BufferSource)\n\n\t\tif (this.validator?.Check(data) === false)\n\t\t\treturn this.raw.send(\n\t\t\t\tnew ValidationError('message', this.validator, data).message\n\t\t\t)\n\n\t\tif (typeof data === 'object') data = JSON.stringify(data) as any\n\n\t\treturn this.raw.pong(data as string)\n\t}\n\n\t/**\n\t * Sends a message to subscribers of the topic.\n\t *\n\t * @param topic The topic name.\n\t * @param data The data to send.\n\t * @param compress Should the data be compressed? If the client does not support compression, this is ignored.\n\t * @example\n\t * ws.publish(\"chat\", \"Hello!\");\n\t * ws.publish(\"chat\", \"Compress this.\", true);\n\t * ws.publish(\"chat\", new Uint8Array([1, 2, 3, 4]));\n\t */\n\tpublish(\n\t\ttopic: string,\n\t\tdata: FlattenResponse<Route['response']> | BufferSource,\n\t\tcompress?: boolean\n\t): ServerWebSocketSendStatus {\n\t\tif (Buffer.isBuffer(data))\n\t\t\treturn this.raw.publish(\n\t\t\t\ttopic,\n\t\t\t\tdata as unknown as BufferSource,\n\t\t\t\tcompress\n\t\t\t)\n\n\t\tif (this.validator?.Check(data) === false)\n\t\t\treturn this.raw.send(\n\t\t\t\tnew ValidationError('message', this.validator, data).message\n\t\t\t)\n\n\t\tif (typeof data === 'object') data = JSON.stringify(data) as any\n\n\t\treturn this.raw.publish(topic, data as unknown as string, compress)\n\t}\n\n\tsendText: ServerWebSocket['sendText']\n\tsendBinary: ServerWebSocket['sendBinary']\n\tclose: ServerWebSocket['close']\n\tterminate: ServerWebSocket['terminate']\n\tpublishText: ServerWebSocket['publishText']\n\tpublishBinary: ServerWebSocket['publishBinary']\n\tsubscribe: ServerWebSocket['subscribe']\n\tunsubscribe: ServerWebSocket['unsubscribe']\n\tisSubscribed: ServerWebSocket['isSubscribed']\n\tcork: ServerWebSocket['cork']\n\tremoteAddress: ServerWebSocket['remoteAddress']\n\tbinaryType: ServerWebSocket['binaryType']\n\n\tget readyState() {\n\t\treturn this.raw.readyState\n\t}\n}\n\nexport const createWSMessageParser = (\n\tparse: MaybeArray<WSParseHandler<any>>\n) => {\n\tconst parsers = typeof parse === 'function' ? [parse] : parse\n\n\treturn async function parseMessage(ws: ServerWebSocket<any>, message: any) {\n\t\tif (typeof message === 'string') {\n\t\t\tconst start = message?.charCodeAt(0)\n\n\t\t\tif (start === 47 || start === 123)\n\t\t\t\ttry {\n\t\t\t\t\tmessage = JSON.parse(message)\n\t\t\t\t} catch {\n\t\t\t\t\t// Not empty\n\t\t\t\t}\n\t\t\telse if (isNumericString(message)) message = +message\n\t\t}\n\n\t\tif (parsers)\n\t\t\tfor (let i = 0; i < parsers.length; i++) {\n\t\t\t\tlet temp = parsers[i](ws as any, message)\n\t\t\t\tif (temp instanceof Promise) temp = await temp\n\n\t\t\t\tif (temp !== undefined) return temp\n\t\t\t}\n\n\t\treturn message\n\t}\n}\n\nexport const createHandleWSResponse = (\n\tvalidateResponse: TypeCheck<any> | undefined\n) => {\n\tconst handleWSResponse = (\n\t\tws: ServerWebSocket<any>,\n\t\tdata: unknown\n\t): unknown => {\n\t\tif (data instanceof Promise)\n\t\t\treturn data.then((data) => handleWSResponse(ws, data))\n\n\t\tif (Buffer.isBuffer(data)) return ws.send(data.toString())\n\n\t\tif (data === undefined) return\n\n\t\tconst send = (datum: unknown) => {\n\t\t\tif (validateResponse?.Check(datum) === false)\n\t\t\t\treturn ws.send(\n\t\t\t\t\tnew ValidationError('message', validateResponse, datum)\n\t\t\t\t\t\t.message\n\t\t\t\t)\n\n\t\t\tif (typeof datum === 'object') return ws.send(JSON.stringify(datum))\n\n\t\t\tws.send(datum)\n\t\t}\n\n\t\tif (typeof (data as Generator)?.next !== 'function')\n\t\t\treturn void send(data)\n\n\t\tconst init = (data as Generator | AsyncGenerator).next()\n\n\t\tif (init instanceof Promise)\n\t\t\treturn (async () => {\n\t\t\t\tconst first = await init\n\n\t\t\t\tif (validateResponse?.Check(first) === false)\n\t\t\t\t\treturn ws.send(\n\t\t\t\t\t\tnew ValidationError('message', validateResponse, first)\n\t\t\t\t\t\t\t.message\n\t\t\t\t\t)\n\n\t\t\t\tsend(first.value as any)\n\n\t\t\t\tif (!first.done)\n\t\t\t\t\tfor await (const datum of data as Generator) send(datum)\n\t\t\t})()\n\n\t\tsend(init.value)\n\n\t\tif (!init.done) for (const datum of data as Generator) send(datum)\n\t}\n\n\treturn handleWSResponse\n}\n\nexport type { WSLocalHook } from './types'\n",
    "/* eslint-disable sonarjs/no-duplicate-string */\nimport type { Serve } from 'bun'\nimport type { TSchema } from '@sinclair/typebox'\n\nimport { WebStandardAdapter } from '../web-standard/index'\nimport { parseSetCookies } from '../web-standard/handler'\nimport type { ElysiaAdapter } from '../types'\n\nimport { createNativeStaticHandler } from './handler'\nimport { serializeCookie } from '../../cookies'\nimport { isProduction, ValidationError } from '../../error'\nimport {\n\tgetSchemaValidator,\n\thasHeaderShorthand,\n\tisNotEmpty,\n\tisNumericString,\n\trandomId\n} from '../../utils'\n\nimport {\n\tcreateHandleWSResponse,\n\tcreateWSMessageParser,\n\tElysiaWS,\n\twebsocket\n} from '../../ws/index'\nimport type { ServerWebSocket } from '../../ws/bun'\n\nexport const BunAdapter: ElysiaAdapter = {\n\t...WebStandardAdapter,\n\tname: 'bun',\n\thandler: {\n\t\t...WebStandardAdapter.handler,\n\t\tcreateNativeStaticHandler\n\t},\n\tcomposeHandler: {\n\t\t...WebStandardAdapter.composeHandler,\n\t\theaders: hasHeaderShorthand\n\t\t\t? 'c.headers = c.request.headers.toJSON()\\n'\n\t\t\t: 'c.headers = {}\\n' +\n\t\t\t\t'for (const [key, value] of c.request.headers.entries())' +\n\t\t\t\t'c.headers[key] = value\\n'\n\t},\n\tlisten(app) {\n\t\treturn (options, callback) => {\n\t\t\tif (typeof Bun === 'undefined')\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'.listen() is designed to run on Bun only. If you are running Elysia in other environment please use a dedicated plugin or export the handler via Elysia.fetch'\n\t\t\t\t)\n\n\t\t\tapp.compile()\n\n\t\t\tif (typeof options === 'string') {\n\t\t\t\tif (!isNumericString(options))\n\t\t\t\t\tthrow new Error('Port must be a numeric value')\n\n\t\t\t\toptions = parseInt(options)\n\t\t\t}\n\n\t\t\tconst fetch = app.fetch\n\n\t\t\tconst serve =\n\t\t\t\ttypeof options === 'object'\n\t\t\t\t\t? ({\n\t\t\t\t\t\t\tdevelopment: !isProduction,\n\t\t\t\t\t\t\treusePort: true,\n\t\t\t\t\t\t\t...(app.config.serve || {}),\n\t\t\t\t\t\t\t...(options || {}),\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tstatic: {\n\t\t\t\t\t\t\t\t...app.router.static.http.static,\n\t\t\t\t\t\t\t\t...app.config.serve?.static\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\twebsocket: {\n\t\t\t\t\t\t\t\t...(app.config.websocket || {}),\n\t\t\t\t\t\t\t\t...(websocket || {})\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tfetch,\n\t\t\t\t\t\t\t// @ts-expect-error private property\n\t\t\t\t\t\t\terror: app.outerErrorHandler\n\t\t\t\t\t\t} as Serve)\n\t\t\t\t\t: ({\n\t\t\t\t\t\t\tdevelopment: !isProduction,\n\t\t\t\t\t\t\treusePort: true,\n\t\t\t\t\t\t\t...(app.config.serve || {}),\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tstatic: app.router.static.http.static,\n\t\t\t\t\t\t\twebsocket: {\n\t\t\t\t\t\t\t\t...(app.config.websocket || {}),\n\t\t\t\t\t\t\t\t...(websocket || {})\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tport: options,\n\t\t\t\t\t\t\tfetch,\n\t\t\t\t\t\t\t// @ts-expect-error private property\n\t\t\t\t\t\t\terror: app.outerErrorHandler\n\t\t\t\t\t\t} as Serve)\n\n\t\t\tapp.server = Bun?.serve(serve)\n\n\t\t\tif (app.event.start)\n\t\t\t\tfor (let i = 0; i < app.event.start.length; i++)\n\t\t\t\t\tapp.event.start[i].fn(app)\n\n\t\t\tif (callback) callback(app.server!)\n\n\t\t\tprocess.on('beforeExit', () => {\n\t\t\t\tif (app.server) {\n\t\t\t\t\tapp.server.stop?.()\n\t\t\t\t\tapp.server = null\n\n\t\t\t\t\tif (app.event.stop)\n\t\t\t\t\t\tfor (let i = 0; i < app.event.stop.length; i++)\n\t\t\t\t\t\t\tapp.event.stop[i].fn(app)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\t// @ts-expect-error private\n\t\t\tapp.promisedModules.then(() => {\n\t\t\t\tBun?.gc(false)\n\t\t\t})\n\t\t}\n\t},\n\tws(app, path, options) {\n\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\tconst { parse, body, response, ...rest } = options\n\n\t\tconst validateMessage = getSchemaValidator(body, {\n\t\t\t// @ts-expect-error private property\n\t\t\tmodules: app.definitions.typebox,\n\t\t\t// @ts-expect-error private property\n\t\t\tmodels: app.definitions.type as Record<string, TSchema>,\n\t\t\tnormalize: app.config.normalize\n\t\t})\n\n\t\tconst validateResponse = getSchemaValidator(response as any, {\n\t\t\t// @ts-expect-error private property\n\t\t\tmodules: app.definitions.typebox,\n\t\t\t// @ts-expect-error private property\n\t\t\tmodels: app.definitions.type as Record<string, TSchema>,\n\t\t\tnormalize: app.config.normalize\n\t\t})\n\n\t\tapp.route(\n\t\t\t'$INTERNALWS',\n\t\t\tpath as any,\n\t\t\tasync (context) => {\n\t\t\t\t// @ts-expect-error private property\n\t\t\t\tconst server = app.getServer()\n\n\t\t\t\t// ! Enable static code analysis just in case resolveUnknownFunction doesn't work, do not remove\n\t\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t\t\t\tconst { set, path, qi, headers, query, params } = context\n\n\t\t\t\t// @ts-ignore\n\t\t\t\tcontext.validator = validateResponse\n\n\t\t\t\tif (options.upgrade) {\n\t\t\t\t\tif (typeof options.upgrade === 'function') {\n\t\t\t\t\t\tconst temp = options.upgrade(context as any)\n\t\t\t\t\t\tif (temp instanceof Promise) await temp\n\t\t\t\t\t} else if (options.upgrade)\n\t\t\t\t\t\tObject.assign(\n\t\t\t\t\t\t\tset.headers,\n\t\t\t\t\t\t\toptions.upgrade as Record<string, any>\n\t\t\t\t\t\t)\n\t\t\t\t}\n\n\t\t\t\tif (set.cookie && isNotEmpty(set.cookie)) {\n\t\t\t\t\tconst cookie = serializeCookie(set.cookie)\n\n\t\t\t\t\tif (cookie) set.headers['set-cookie'] = cookie\n\t\t\t\t}\n\n\t\t\t\tif (\n\t\t\t\t\tset.headers['set-cookie'] &&\n\t\t\t\t\tArray.isArray(set.headers['set-cookie'])\n\t\t\t\t)\n\t\t\t\t\tset.headers = parseSetCookies(\n\t\t\t\t\t\tnew Headers(set.headers as any) as Headers,\n\t\t\t\t\t\tset.headers['set-cookie']\n\t\t\t\t\t) as any\n\n\t\t\t\tconst handleResponse = createHandleWSResponse(validateResponse)\n\t\t\t\tconst parseMessage = createWSMessageParser(parse)\n\n\t\t\t\tlet _id: string | undefined\n\n\t\t\t\tif (\n\t\t\t\t\tserver?.upgrade<any>(context.request, {\n\t\t\t\t\t\theaders: isNotEmpty(set.headers)\n\t\t\t\t\t\t\t? (set.headers as Record<string, string>)\n\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t...context,\n\t\t\t\t\t\t\tget id() {\n\t\t\t\t\t\t\t\tif (_id) return _id\n\n\t\t\t\t\t\t\t\treturn (_id = randomId())\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tvalidator: validateResponse,\n\t\t\t\t\t\t\tping(data?: unknown) {\n\t\t\t\t\t\t\t\toptions.ping?.(data)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tpong(data?: unknown) {\n\t\t\t\t\t\t\t\toptions.pong?.(data)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\topen(ws: ServerWebSocket<any>) {\n\t\t\t\t\t\t\t\thandleResponse(\n\t\t\t\t\t\t\t\t\tws,\n\t\t\t\t\t\t\t\t\toptions.open?.(\n\t\t\t\t\t\t\t\t\t\tnew ElysiaWS(ws, context as any)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tmessage: async (\n\t\t\t\t\t\t\t\tws: ServerWebSocket<any>,\n\t\t\t\t\t\t\t\t_message: any\n\t\t\t\t\t\t\t) => {\n\t\t\t\t\t\t\t\tconst message = await parseMessage(ws, _message)\n\n\t\t\t\t\t\t\t\tif (validateMessage?.Check(message) === false)\n\t\t\t\t\t\t\t\t\treturn void ws.send(\n\t\t\t\t\t\t\t\t\t\tnew ValidationError(\n\t\t\t\t\t\t\t\t\t\t\t'message',\n\t\t\t\t\t\t\t\t\t\t\tvalidateMessage,\n\t\t\t\t\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t\t\t\t\t).message as string\n\t\t\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\t\thandleResponse(\n\t\t\t\t\t\t\t\t\tws,\n\t\t\t\t\t\t\t\t\toptions.message?.(\n\t\t\t\t\t\t\t\t\t\tnew ElysiaWS(\n\t\t\t\t\t\t\t\t\t\t\tws,\n\t\t\t\t\t\t\t\t\t\t\tcontext as any,\n\t\t\t\t\t\t\t\t\t\t\tmessage\n\t\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\t\tmessage as any\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tdrain(ws: ServerWebSocket<any>) {\n\t\t\t\t\t\t\t\thandleResponse(\n\t\t\t\t\t\t\t\t\tws,\n\t\t\t\t\t\t\t\t\toptions.drain?.(\n\t\t\t\t\t\t\t\t\t\tnew ElysiaWS(ws, context as any)\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tclose(\n\t\t\t\t\t\t\t\tws: ServerWebSocket<any>,\n\t\t\t\t\t\t\t\tcode: number,\n\t\t\t\t\t\t\t\treason: string\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\thandleResponse(\n\t\t\t\t\t\t\t\t\tws,\n\t\t\t\t\t\t\t\t\toptions.close?.(\n\t\t\t\t\t\t\t\t\t\tnew ElysiaWS(ws, context as any),\n\t\t\t\t\t\t\t\t\t\tcode,\n\t\t\t\t\t\t\t\t\t\treason\n\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t)\n\t\t\t\t\treturn\n\n\t\t\t\tset.status = 400\n\t\t\t\treturn 'Expected a websocket connection'\n\t\t\t},\n\t\t\t{\n\t\t\t\t...rest,\n\t\t\t\twebsocket: options\n\t\t\t} as any\n\t\t)\n\t}\n}\n",
    "// @ts-ignore\nexport const isBun = typeof Bun !== 'undefined'\n// @ts-ignore\nexport const isDeno = typeof Deno !== 'undefined'\n",
    "import { isBun } from './utils'\n\nexport const env = isBun\n\t? Bun.env\n\t: typeof process !== 'undefined' && process?.env\n\t\t? process.env\n\t\t: {}\n",
    "import type { AnyElysia } from '.'\n\nimport { Value } from '@sinclair/typebox/value'\nimport { TypeBoxError, type TAnySchema, type TSchema } from '@sinclair/typebox'\n\nimport { parseQuery, parseQueryFromURL } from './fast-querystring'\n\nimport { decode as decodeURIComponent } from './deuri'\n\nimport {\n\tELYSIA_REQUEST_ID,\n\tgetCookieValidator,\n\tgetLoosePath,\n\tlifeCycleToFn,\n\trandomId,\n\tredirect,\n\tsignCookie,\n\tisNotEmpty,\n\tencodePath\n} from './utils'\nimport { ParseError, error } from './error'\n\nimport {\n\tNotFoundError,\n\tValidationError,\n\tInternalServerError,\n\tERROR_CODE,\n\tElysiaCustomStatusResponse\n} from './error'\nimport { ELYSIA_TRACE, type TraceHandler } from './trace'\n\nimport { Sucrose, hasReturn, sucrose } from './sucrose'\nimport { parseCookie, type CookieOptions } from './cookies'\n\nimport type { TraceEvent } from './trace'\nimport type {\n\tComposedHandler,\n\tHandler,\n\tHookContainer,\n\tLifeCycleStore,\n\tSchemaValidator\n} from './types'\nimport type { TypeCheck } from './type-system'\n\nconst TypeBoxSymbol = {\n\toptional: Symbol.for('TypeBox.Optional'),\n\tkind: Symbol.for('TypeBox.Kind')\n} as const\n\nconst isOptional = (validator?: TypeCheck<any>) => {\n\tif (!validator) return false\n\n\t// @ts-expect-error\n\tconst schema = validator?.schema\n\n\tif (schema?.[TypeBoxSymbol.kind] === 'Import')\n\t\treturn validator.References().some(isOptional as any)\n\n\treturn !!schema && TypeBoxSymbol.optional in schema\n}\n\nconst allocateIf = (value: string, condition: unknown) =>\n\tcondition ? value : ''\n\nconst defaultParsers = [\n\t'json',\n\t'text',\n\t'urlencoded',\n\t'arrayBuffer',\n\t'formdata',\n\t'application/json',\n\t// eslint-disable-next-line sonarjs/no-duplicate-string\n\t'text/plain',\n\t// eslint-disable-next-line sonarjs/no-duplicate-string\n\t'application/x-www-form-urlencoded',\n\t// eslint-disable-next-line sonarjs/no-duplicate-string\n\t'application/octet-stream',\n\t// eslint-disable-next-line sonarjs/no-duplicate-string\n\t'multipart/form-data'\n]\n\nexport const hasAdditionalProperties = (\n\t_schema: TAnySchema | TypeCheck<any>\n) => {\n\tif (!_schema) return false\n\n\t// @ts-expect-error private property\n\tconst schema: TAnySchema = (_schema as TypeCheck<any>)?.schema ?? _schema\n\n\t// @ts-expect-error private property\n\tif (schema[TypeBoxSymbol.kind] === 'Import' && _schema.References()) {\n\t\treturn _schema.References().some(hasAdditionalProperties)\n\t}\n\n\tif (schema.anyOf) return schema.anyOf.some(hasAdditionalProperties)\n\tif (schema.someOf) return schema.someOf.some(hasAdditionalProperties)\n\tif (schema.allOf) return schema.allOf.some(hasAdditionalProperties)\n\tif (schema.not) return schema.not.some(hasAdditionalProperties)\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\n\t\tif ('additionalProperties' in schema) return schema.additionalProperties\n\t\tif ('patternProperties' in schema) return false\n\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasAdditionalProperties(property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasAdditionalProperties(property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\treturn property.additionalProperties\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn false\n}\n\nconst createReport = ({\n\tcontext = 'c',\n\ttrace = [],\n\taddFn\n}: {\n\tcontext?: string\n\ttrace?: (TraceHandler | HookContainer<TraceHandler>)[]\n\taddFn(string: string): void\n}) => {\n\tif (!trace.length)\n\t\treturn () => {\n\t\t\treturn {\n\t\t\t\tresolveChild() {\n\t\t\t\t\treturn () => {}\n\t\t\t\t},\n\t\t\t\tresolve() {}\n\t\t\t}\n\t\t}\n\n\tfor (let i = 0; i < trace.length; i++)\n\t\taddFn(\n\t\t\t`let report${i}, reportChild${i}, reportErr${i}, reportErrChild${i};` +\n\t\t\t\t`let trace${i} = ${context}[ELYSIA_TRACE]?.[${i}] ?? trace[${i}](${context});\\n`\n\t\t)\n\n\treturn (\n\t\tevent: TraceEvent,\n\t\t{\n\t\t\tname,\n\t\t\ttotal = 0\n\t\t}: {\n\t\t\tname?: string\n\t\t\tattribute?: string\n\t\t\ttotal?: number\n\t\t} = {}\n\t) => {\n\t\t// ? For debug specific event\n\t\t// if (event !== 'mapResponse')\n\t\t// \treturn {\n\t\t// \t\tresolveChild() {\n\t\t// \t\t\treturn () => {}\n\t\t// \t\t},\n\t\t// \t\tresolve() {}\n\t\t// \t}\n\n\t\tif (!name) name = 'anonymous'\n\n\t\tconst reporter = event === 'error' ? 'reportErr' : 'report'\n\n\t\tfor (let i = 0; i < trace.length; i++)\n\t\t\taddFn(\n\t\t\t\t`${reporter}${i} = trace${i}.${event}({` +\n\t\t\t\t\t`id,` +\n\t\t\t\t\t`event:'${event}',` +\n\t\t\t\t\t`name:'${name}',` +\n\t\t\t\t\t`begin:performance.now(),` +\n\t\t\t\t\t`total:${total}` +\n\t\t\t\t\t`})\\n`\n\t\t\t)\n\n\t\treturn {\n\t\t\tresolve() {\n\t\t\t\tfor (let i = 0; i < trace.length; i++)\n\t\t\t\t\taddFn(`${reporter}${i}.resolve()\\n`)\n\t\t\t},\n\t\t\tresolveChild(name: string) {\n\t\t\t\tfor (let i = 0; i < trace.length; i++)\n\t\t\t\t\taddFn(\n\t\t\t\t\t\t`${reporter}Child${i}=${reporter}${i}.resolveChild?.shift()?.({` +\n\t\t\t\t\t\t\t`id,` +\n\t\t\t\t\t\t\t`event:'${event}',` +\n\t\t\t\t\t\t\t`name:'${name}',` +\n\t\t\t\t\t\t\t`begin:performance.now()` +\n\t\t\t\t\t\t\t`})\\n`\n\t\t\t\t\t)\n\n\t\t\t\treturn (binding?: string) => {\n\t\t\t\t\tfor (let i = 0; i < trace.length; i++) {\n\t\t\t\t\t\tif (binding)\n\t\t\t\t\t\t\t// Don't report error because HTTP response is expected and not an actual error to look for\n\t\t\t\t\t\t\t// if (${binding} instanceof ElysiaCustomStatusResponse) {\n\t\t\t\t\t\t\t//     ${reporter}Child${i}?.(${binding}.error)\n\t\t\t\t\t\t\t//     ${reporter}Child${i}?.()\\n\n\t\t\t\t\t\t\t// } else\n\t\t\t\t\t\t\taddFn(\n\t\t\t\t\t\t\t\t`if(${binding} instanceof Error){` +\n\t\t\t\t\t\t\t\t\t`${reporter}Child${i}?.(${binding}) ` +\n\t\t\t\t\t\t\t\t\t`}else{` +\n\t\t\t\t\t\t\t\t\t`${reporter}Child${i}?.()` +\n\t\t\t\t\t\t\t\t\t'}'\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\telse addFn(`${reporter}Child${i}?.()\\n`)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nconst composeValidationFactory = ({\n\tinjectResponse = '',\n\tnormalize = false,\n\tvalidator\n}: {\n\tinjectResponse?: string\n\tnormalize?: boolean\n\tvalidator: SchemaValidator\n}) => ({\n\tcomposeValidation: (type: string, value = `c.${type}`) =>\n\t\t`c.set.status=422;throw new ValidationError('${type}',validator.${type},${value})`,\n\tcomposeResponseValidation: (name = 'r') => {\n\t\tlet code = injectResponse + '\\n'\n\n\t\tcode +=\n\t\t\t`if(${name} instanceof ElysiaCustomStatusResponse){` +\n\t\t\t`c.set.status=${name}.code\\n` +\n\t\t\t`${name}=${name}.response` +\n\t\t\t`}` +\n\t\t\t`const isResponse=${name} instanceof Response\\n` +\n\t\t\t`switch(c.set.status){`\n\n\t\tfor (const [status, value] of Object.entries(\n\t\t\tvalidator.response as Record<string, TypeCheck<any>>\n\t\t)) {\n\t\t\tcode += `\\ncase ${status}:if(!isResponse){`\n\n\t\t\tif (\n\t\t\t\tnormalize &&\n\t\t\t\t'Clean' in value &&\n\t\t\t\t!hasAdditionalProperties(value as any)\n\t\t\t)\n\t\t\t\tcode += `${name}=validator.response['${status}'].Clean(${name})\\n`\n\n\t\t\tcode +=\n\t\t\t\t`if(validator.response['${status}'].Check(${name})===false){` +\n\t\t\t\t'c.set.status=422\\n' +\n\t\t\t\t`throw new ValidationError('response',validator.response['${status}'],${name})` +\n\t\t\t\t'}' +\n\t\t\t\t`c.set.status = ${status}` +\n\t\t\t\t'}' +\n\t\t\t\t'break\\n'\n\t\t}\n\n\t\treturn code + '}'\n\t}\n})\n\nconst KindSymbol = Symbol.for('TypeBox.Kind')\n\nexport const hasType = (type: string, schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (KindSymbol in schema && schema[KindSymbol] === type) return true\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasType(type, property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasType(type, property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\tif (KindSymbol in property && property[KindSymbol] === type)\n\t\t\t\treturn true\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn (\n\t\tschema.properties &&\n\t\tKindSymbol in schema.properties &&\n\t\tschema.properties[KindSymbol] === type\n\t)\n}\n\nexport const hasProperty = (\n\texpectedProperty: string,\n\t_schema: TAnySchema | TypeCheck<any>\n) => {\n\tif (!_schema) return\n\n\t// @ts-expect-error private property\n\tconst schema = _schema.schema ?? _schema\n\n\tif (schema[TypeBoxSymbol.kind] === 'Import')\n\t\treturn _schema\n\t\t\t.References()\n\t\t\t.some((schema: TAnySchema) => hasProperty(expectedProperty, schema))\n\n\tif (schema.type === 'object') {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\n\t\tif (!properties) return false\n\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (expectedProperty in property) return true\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasProperty(expectedProperty, property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++) {\n\t\t\t\t\tif (hasProperty(expectedProperty, property.anyOf[i]))\n\t\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn expectedProperty in schema\n}\n\nconst TransformSymbol = Symbol.for('TypeBox.Transform')\n\nexport const hasTransform = (schema: TAnySchema) => {\n\tif (!schema) return\n\n\tif (schema.type === 'object' && schema.properties) {\n\t\tconst properties = schema.properties as Record<string, TAnySchema>\n\t\tfor (const key of Object.keys(properties)) {\n\t\t\tconst property = properties[key]\n\n\t\t\tif (property.type === 'object') {\n\t\t\t\tif (hasTransform(property)) return true\n\t\t\t} else if (property.anyOf) {\n\t\t\t\tfor (let i = 0; i < property.anyOf.length; i++)\n\t\t\t\t\tif (hasTransform(property.anyOf[i])) return true\n\t\t\t}\n\n\t\t\tconst hasTransformSymbol = TransformSymbol in property\n\t\t\tif (hasTransformSymbol) return true\n\t\t}\n\n\t\treturn false\n\t}\n\n\treturn (\n\t\tTransformSymbol in schema ||\n\t\t(schema.properties && TransformSymbol in schema.properties)\n\t)\n}\n\n/**\n * This function will return the type of unioned if all unioned type is the same.\n * It's intent to use for content-type mapping only\n *\n * ```ts\n * t.Union([\n *   t.Object({\n *     password: t.String()\n *   }),\n *   t.Object({\n *     token: t.String()\n *   })\n * ])\n * ```\n */\n// const getUnionedType = (validator: TypeCheck<any> | undefined) => {\n// \tif (!validator) return\n\n// \t// @ts-ignore\n// \tconst schema = validator?.schema\n\n// \tif (schema && 'anyOf' in schema) {\n// \t\tlet foundDifference = false\n// \t\tconst type: string = schema.anyOf[0].type\n\n// \t\tfor (const validator of schema.anyOf as { type: string }[]) {\n// \t\t\tif (validator.type !== type) {\n// \t\t\t\tfoundDifference = true\n// \t\t\t\tbreak\n// \t\t\t}\n// \t\t}\n\n// \t\tif (!foundDifference) return type\n// \t}\n\n// \t// @ts-ignore\n// \treturn validator.schema?.type\n// }\n\nconst matchFnReturn = /(?:return|=>) \\S+\\(/g\n\nexport const isAsyncName = (v: Function | HookContainer) => {\n\t// @ts-ignore\n\tconst fn = v?.fn ?? v\n\n\treturn fn.constructor.name === 'AsyncFunction'\n}\n\nexport const isAsync = (v: Function | HookContainer) => {\n\t// @ts-ignore\n\tconst fn = v?.fn ?? v\n\n\tif (fn.constructor.name === 'AsyncFunction') return true\n\n\tconst literal = fn.toString()\n\tif (literal.includes('=> response.clone(')) return false\n\tif (literal.includes('await')) return true\n\tif (literal.includes('async')) return true\n\t// v8 minified\n\tif (literal.includes('=>response.clone(')) return false\n\n\treturn !!literal.match(matchFnReturn)\n}\n\nexport const isGenerator = (v: Function | HookContainer) => {\n\t// @ts-ignore\n\tconst fn = v?.fn ?? v\n\n\treturn (\n\t\tfn.constructor.name === 'AsyncGeneratorFunction' ||\n\t\tfn.constructor.name === 'GeneratorFunction'\n\t)\n}\n\nexport const composeHandler = ({\n\tapp,\n\tpath,\n\tmethod,\n\thooks,\n\tvalidator,\n\thandler,\n\tallowMeta = false,\n\tinference,\n\tasManifest = false\n}: {\n\tapp: AnyElysia\n\tpath: string\n\tmethod: string\n\thooks: Partial<LifeCycleStore>\n\tvalidator: SchemaValidator\n\thandler: unknown | Handler<any, any>\n\tallowMeta?: boolean\n\tinference: Sucrose.Inference\n\tasManifest?: boolean\n}): ComposedHandler => {\n\tconst adapter = app['~adapter'].composeHandler\n\tconst adapterHandler = app['~adapter'].handler\n\tconst isHandleFn = typeof handler === 'function'\n\n\tif (!isHandleFn) {\n\t\thandler = adapterHandler.mapResponse(handler, {\n\t\t\t// @ts-expect-error private property\n\t\t\theaders: app.setHeaders ?? {}\n\t\t})\n\n\t\tif (\n\t\t\thooks.parse?.length &&\n\t\t\thooks.transform?.length &&\n\t\t\thooks.beforeHandle?.length &&\n\t\t\thooks.afterHandle?.length\n\t\t) {\n\t\t\tif (handler instanceof Response)\n\t\t\t\treturn Function(\n\t\t\t\t\t'a',\n\t\t\t\t\t`return function(){return a.clone()}`\n\t\t\t\t)(handler)\n\n\t\t\treturn Function('a', 'return function(){return a}')(handler)\n\t\t}\n\t}\n\n\tconst handle = isHandleFn ? `handler(c)` : `handler`\n\tconst hasAfterResponse = !!hooks.afterResponse?.length\n\n\tconst hasTrace = !!hooks.trace?.length\n\tlet fnLiteral = ''\n\n\tinference = sucrose(\n\t\tObject.assign({}, hooks, {\n\t\t\thandler: handler as any\n\t\t}),\n\t\tinference\n\t)\n\n\tif (adapter.declare) {\n\t\tconst literal = adapter.declare(inference)\n\n\t\tif (literal) fnLiteral += literal\n\t}\n\n\tif (inference.server)\n\t\tfnLiteral +=\n\t\t\t\"Object.defineProperty(c,'server',{\" +\n\t\t\t'get:function(){return getServer()}' +\n\t\t\t'})\\n'\n\n\tvalidator.createBody?.()\n\tvalidator.createQuery?.()\n\tvalidator.createHeaders?.()\n\tvalidator.createParams?.()\n\tvalidator.createCookie?.()\n\tvalidator.createResponse?.()\n\n\tconst hasValidation =\n\t\tvalidator.body ||\n\t\tvalidator.headers ||\n\t\tvalidator.params ||\n\t\tvalidator.query ||\n\t\tvalidator.cookie ||\n\t\tvalidator.response\n\n\tconst hasQuery = inference.query || !!validator.query\n\n\tconst hasBody =\n\t\tmethod !== '$INTERNALWS' &&\n\t\tmethod !== 'GET' &&\n\t\tmethod !== 'HEAD' &&\n\t\t(inference.body || !!validator.body || !!hooks.parse?.length)\n\n\tif (hasBody) fnLiteral += `let isParsing=false\\n`\n\n\t// @ts-expect-error private\n\tconst defaultHeaders = app.setHeaders\n\tconst hasDefaultHeaders =\n\t\tdefaultHeaders && !!Object.keys(defaultHeaders).length\n\n\t// ? defaultHeaders doesn't imply that user will use headers in handler\n\tconst hasHeaders =\n\t\tinference.headers ||\n\t\tvalidator.headers ||\n\t\t(adapter.preferWebstandardHeaders !== true && inference.body)\n\n\tconst hasCookie = inference.cookie || !!validator.cookie\n\n\tconst cookieValidator = hasCookie\n\t\t? getCookieValidator({\n\t\t\t\t// @ts-expect-error private property\n\t\t\t\tmodules: app.definitions.typebox,\n\t\t\t\tvalidator: validator.cookie as any,\n\t\t\t\tdefaultConfig: app.config.cookie,\n\t\t\t\tdynamic: !!app.config.aot,\n\t\t\t\t// @ts-expect-error\n\t\t\t\tconfig: validator.cookie?.config ?? {},\n\t\t\t\t// @ts-expect-error\n\t\t\t\tmodels: app.definitions.type\n\t\t\t})\n\t\t: undefined\n\n\t// @ts-ignore private property\n\tconst cookieMeta = cookieValidator?.config as {\n\t\tsecrets?: string | string[]\n\t\tsign: string[] | true\n\t\tproperties: { [x: string]: Object }\n\t}\n\n\tlet encodeCookie = ''\n\n\tif (cookieMeta?.sign) {\n\t\tif (!cookieMeta.secrets)\n\t\t\tthrow new Error(\n\t\t\t\t`t.Cookie required secret which is not set in (${method}) ${path}.`\n\t\t\t)\n\n\t\tconst secret = !cookieMeta.secrets\n\t\t\t? undefined\n\t\t\t: typeof cookieMeta.secrets === 'string'\n\t\t\t\t? cookieMeta.secrets\n\t\t\t\t: cookieMeta.secrets[0]\n\n\t\tencodeCookie += 'const _setCookie = c.set.cookie\\n' + 'if(_setCookie){'\n\n\t\tif (cookieMeta.sign === true) {\n\t\t\tencodeCookie +=\n\t\t\t\t'for(const [key, cookie] of Object.entries(_setCookie)){' +\n\t\t\t\t`c.set.cookie[key].value=await signCookie(cookie.value,'${secret}')` +\n\t\t\t\t'}'\n\t\t} else\n\t\t\tfor (const name of cookieMeta.sign)\n\t\t\t\tencodeCookie +=\n\t\t\t\t\t`if(_setCookie['${name}']?.value){` +\n\t\t\t\t\t`c.set.cookie['${name}'].value=await signCookie(_setCookie['${name}'].value,'${secret}')` +\n\t\t\t\t\t'}'\n\n\t\tencodeCookie += '}\\n'\n\t}\n\n\tconst normalize = app.config.normalize\n\n\tconst { composeValidation, composeResponseValidation } =\n\t\tcomposeValidationFactory({\n\t\t\tnormalize,\n\t\t\tvalidator\n\t\t})\n\n\tif (hasHeaders) fnLiteral += adapter.headers\n\n\tif (hasTrace) fnLiteral += 'const id=c[ELYSIA_REQUEST_ID]\\n'\n\n\tconst report = createReport({\n\t\ttrace: hooks.trace,\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tfnLiteral += 'try{'\n\n\tif (hasCookie) {\n\t\tconst get = (name: keyof CookieOptions, defaultValue?: unknown) => {\n\t\t\t// @ts-ignore\n\t\t\tconst value = cookieMeta?.[name] ?? defaultValue\n\t\t\tif (!value)\n\t\t\t\treturn typeof defaultValue === 'string'\n\t\t\t\t\t? `${name}:\"${defaultValue}\",`\n\t\t\t\t\t: `${name}:${defaultValue},`\n\n\t\t\tif (typeof value === 'string') return `${name}:'${value}',`\n\t\t\tif (value instanceof Date)\n\t\t\t\treturn `${name}: new Date(${value.getTime()}),`\n\n\t\t\treturn `${name}:${value},`\n\t\t}\n\n\t\tconst options = cookieMeta\n\t\t\t? `{secrets:${\n\t\t\t\t\tcookieMeta.secrets !== undefined\n\t\t\t\t\t\t? typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t\t? `'${cookieMeta.secrets}'`\n\t\t\t\t\t\t\t: '[' +\n\t\t\t\t\t\t\t\tcookieMeta.secrets.reduce(\n\t\t\t\t\t\t\t\t\t(a, b) => a + `'${b}',`,\n\t\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t\t\t']'\n\t\t\t\t\t\t: 'undefined'\n\t\t\t\t},` +\n\t\t\t\t`sign:${\n\t\t\t\t\tcookieMeta.sign === true\n\t\t\t\t\t\t? true\n\t\t\t\t\t\t: cookieMeta.sign !== undefined\n\t\t\t\t\t\t\t? '[' +\n\t\t\t\t\t\t\t\tcookieMeta.sign.reduce(\n\t\t\t\t\t\t\t\t\t(a, b) => a + `'${b}',`,\n\t\t\t\t\t\t\t\t\t''\n\t\t\t\t\t\t\t\t) +\n\t\t\t\t\t\t\t\t']'\n\t\t\t\t\t\t\t: 'undefined'\n\t\t\t\t},` +\n\t\t\t\tget('domain') +\n\t\t\t\tget('expires') +\n\t\t\t\tget('httpOnly') +\n\t\t\t\tget('maxAge') +\n\t\t\t\tget('path', '/') +\n\t\t\t\tget('priority') +\n\t\t\t\tget('sameSite') +\n\t\t\t\tget('secure') +\n\t\t\t\t'}'\n\t\t\t: 'undefined'\n\n\t\tif (hasHeaders)\n\t\t\tfnLiteral += `\\nc.cookie=await parseCookie(c.set,c.headers.cookie,${options})\\n`\n\t\telse\n\t\t\tfnLiteral += `\\nc.cookie=await parseCookie(c.set,c.request.headers.get('cookie'),${options})\\n`\n\t}\n\n\tif (hasQuery) {\n\t\tconst destructured = <\n\t\t\t{\n\t\t\t\tkey: string\n\t\t\t\tisArray: boolean\n\t\t\t\tisNestedObjectArray: boolean\n\t\t\t\tisObject: boolean\n\t\t\t\tanyOf: boolean\n\t\t\t}[]\n\t\t>[]\n\n\t\t// @ts-ignore\n\t\tif (validator.query && validator.query.schema.type === 'object') {\n\t\t\t// @ts-expect-error private property\n\t\t\tconst properties = validator.query.schema.properties\n\n\t\t\tif (!hasAdditionalProperties(validator.query as any))\n\t\t\t\t// eslint-disable-next-line prefer-const\n\t\t\t\tfor (let [key, _value] of Object.entries(properties)) {\n\t\t\t\t\tlet value = _value as TAnySchema\n\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tif (\n\t\t\t\t\t\tvalue &&\n\t\t\t\t\t\tTypeBoxSymbol.optional in value &&\n\t\t\t\t\t\tvalue.type === 'array' &&\n\t\t\t\t\t\tvalue.items\n\t\t\t\t\t)\n\t\t\t\t\t\tvalue = value.items\n\n\t\t\t\t\t// @ts-ignore unknown\n\t\t\t\t\tconst { type, anyOf } = value\n\t\t\t\t\tconst isArray =\n\t\t\t\t\t\ttype === 'array' ||\n\t\t\t\t\t\tanyOf?.some(\n\t\t\t\t\t\t\t(v: TSchema) =>\n\t\t\t\t\t\t\t\tv.type === 'string' &&\n\t\t\t\t\t\t\t\tv.format === 'ArrayString'\n\t\t\t\t\t\t)\n\n\t\t\t\t\tdestructured.push({\n\t\t\t\t\t\tkey,\n\t\t\t\t\t\tisArray,\n\t\t\t\t\t\tisNestedObjectArray:\n\t\t\t\t\t\t\t(isArray && value.items?.type === 'object') ||\n\t\t\t\t\t\t\t!!value.items?.anyOf?.some(\n\t\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\t\t(x) => x.type === 'object' || x.type === 'array'\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\tisObject:\n\t\t\t\t\t\t\ttype === 'object' ||\n\t\t\t\t\t\t\tanyOf?.some(\n\t\t\t\t\t\t\t\t(v: TSchema) =>\n\t\t\t\t\t\t\t\t\tv.type === 'string' &&\n\t\t\t\t\t\t\t\t\tv.format === 'ArrayString'\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\tanyOf: !!anyOf\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t}\n\n\t\tif (!destructured.length) {\n\t\t\tfnLiteral +=\n\t\t\t\t'if(c.qi===-1){' +\n\t\t\t\t'c.query={}' +\n\t\t\t\t'}else{' +\n\t\t\t\t'c.query=parseQueryFromURL(c.url.slice(c.qi + 1))' +\n\t\t\t\t'}'\n\t\t} else {\n\t\t\tfnLiteral +=\n\t\t\t\t'if(c.qi!==-1){' +\n\t\t\t\t`let url = '&' + decodeURIComponent(c.url.slice(c.qi + 1))\\n`\n\n\t\t\tlet index = 0\n\t\t\tfor (const {\n\t\t\t\tkey,\n\t\t\t\tisArray,\n\t\t\t\tisObject,\n\t\t\t\tisNestedObjectArray,\n\t\t\t\tanyOf\n\t\t\t} of destructured) {\n\t\t\t\tconst init =\n\t\t\t\t\t(index === 0 ? 'let ' : '') +\n\t\t\t\t\t`memory=url.indexOf('&${key}=')` +\n\t\t\t\t\t`\\nlet a${index}\\n`\n\n\t\t\t\tif (isArray) {\n\t\t\t\t\tfnLiteral += init\n\n\t\t\t\t\tif (isNestedObjectArray)\n\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t`while(memory!==-1){` +\n\t\t\t\t\t\t\t`const start=memory+${key.length + 2}\\n` +\n\t\t\t\t\t\t\t`memory=url.indexOf('&',start)\\n` +\n\t\t\t\t\t\t\t`if(a${index}===undefined)\\n` +\n\t\t\t\t\t\t\t`a${index}=''\\n` +\n\t\t\t\t\t\t\t`else\\n` +\n\t\t\t\t\t\t\t`a${index}+=','\\n` +\n\t\t\t\t\t\t\t`let temp\\n` +\n\t\t\t\t\t\t\t`if(memory===-1)temp=decodeURIComponent(url.slice(start).replace(/\\\\+/g,' '))\\n` +\n\t\t\t\t\t\t\t`else temp=decodeURIComponent(url.slice(start, memory).replace(/\\\\+/g,' '))\\n` +\n\t\t\t\t\t\t\t`const charCode = temp.charCodeAt(0)\\n` +\n\t\t\t\t\t\t\t`if(charCode !== 91 && charCode !== 123)\\n` +\n\t\t\t\t\t\t\t`temp='\"'+temp+'\"'\\n` +\n\t\t\t\t\t\t\t`a${index} += temp\\n` +\n\t\t\t\t\t\t\t`if(memory === -1)break\\n` +\n\t\t\t\t\t\t\t`memory=url.indexOf('&${key}=',memory)\\n` +\n\t\t\t\t\t\t\t`if(memory === -1)break` +\n\t\t\t\t\t\t\t`}` +\n\t\t\t\t\t\t\t`try{` +\n\t\t\t\t\t\t\t`if(a${index}.charCodeAt(0) === 91)` +\n\t\t\t\t\t\t\t`a${index} = JSON.parse(a${index})\\n` +\n\t\t\t\t\t\t\t`else\\n` +\n\t\t\t\t\t\t\t`a${index}=JSON.parse('['+a${index}+']')` +\n\t\t\t\t\t\t\t`}catch{}\\n`\n\t\t\t\t\telse\n\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t`while(memory!==-1){` +\n\t\t\t\t\t\t\t`const start=memory+${key.length + 2}\\n` +\n\t\t\t\t\t\t\t`memory=url.indexOf('&',start)\\n` +\n\t\t\t\t\t\t\t`if(a${index}===undefined)` +\n\t\t\t\t\t\t\t`a${index}=[]\\n` +\n\t\t\t\t\t\t\t`if(memory===-1){` +\n\t\t\t\t\t\t\t`const temp=decodeURIComponent(url.slice(start)).replace(/\\\\+/g,' ')\\n` +\n\t\t\t\t\t\t\t`if(temp.includes(',')){a${index}=a${index}.concat(temp.split(','))}` +\n\t\t\t\t\t\t\t`else{a${index}.push(decodeURIComponent(url.slice(start)).replace(/\\\\+/g,' '))}\\n` +\n\t\t\t\t\t\t\t`break` +\n\t\t\t\t\t\t\t`}else{` +\n\t\t\t\t\t\t\t`const temp=decodeURIComponent(url.slice(start, memory)).replace(/\\\\+/g,' ')\\n` +\n\t\t\t\t\t\t\t`if(temp.includes(',')){a${index}=a${index}.concat(temp.split(','))}` +\n\t\t\t\t\t\t\t`else{a${index}.push(temp)}\\n` +\n\t\t\t\t\t\t\t`}` +\n\t\t\t\t\t\t\t`memory=url.indexOf('&${key}=',memory)\\n` +\n\t\t\t\t\t\t\t`if(memory===-1) break\\n` +\n\t\t\t\t\t\t\t`}`\n\t\t\t\t} else if (isObject)\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\tinit +\n\t\t\t\t\t\t`if(memory!==-1){` +\n\t\t\t\t\t\t`const start=memory+${key.length + 2}\\n` +\n\t\t\t\t\t\t`memory=url.indexOf('&',start)\\n` +\n\t\t\t\t\t\t`if(memory===-1)a${index}=decodeURIComponent(url.slice(start).replace(/\\\\+/g,' '))` +\n\t\t\t\t\t\t`else a${index}=decodeURIComponent(url.slice(start,memory).replace(/\\\\+/g,' '))` +\n\t\t\t\t\t\t`if(a${index}!==undefined)` +\n\t\t\t\t\t\t`try{` +\n\t\t\t\t\t\t`a${index}=JSON.parse(a${index})` +\n\t\t\t\t\t\t`}catch{}` +\n\t\t\t\t\t\t'}'\n\t\t\t\t// Might be union primitive and array\n\t\t\t\telse {\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\tinit +\n\t\t\t\t\t\t`if(memory!==-1){` +\n\t\t\t\t\t\t`const start=memory+${key.length + 2}\\n` +\n\t\t\t\t\t\t`memory=url.indexOf('&',start)\\n` +\n\t\t\t\t\t\t`if(memory===-1)a${index}=decodeURIComponent(url.slice(start).replace(/\\\\+/g,' '))\\n` +\n\t\t\t\t\t\t`else{` +\n\t\t\t\t\t\t`a${index}=decodeURIComponent(url.slice(start,memory).replace(/\\\\+/g,' '))`\n\n\t\t\t\t\tif (anyOf)\n\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t`\\nlet deepMemory=url.indexOf('&${key}=',memory)\\n` +\n\t\t\t\t\t\t\t`if(deepMemory!==-1){` +\n\t\t\t\t\t\t\t`a${index}=[a${index}]\\n` +\n\t\t\t\t\t\t\t`let first=true\\n` +\n\t\t\t\t\t\t\t`while(true){` +\n\t\t\t\t\t\t\t`const start=deepMemory+${key.length + 2}\\n` +\n\t\t\t\t\t\t\t`if(first)first=false\\n` +\n\t\t\t\t\t\t\t`else deepMemory = url.indexOf('&', start)\\n` +\n\t\t\t\t\t\t\t`let value\\n` +\n\t\t\t\t\t\t\t`if(deepMemory===-1)value=decodeURIComponent(url.slice(start).replace(/\\\\+/g,' '))\\n` +\n\t\t\t\t\t\t\t`else value=decodeURIComponent(url.slice(start, deepMemory).replace(/\\\\+/g,' '))\\n` +\n\t\t\t\t\t\t\t`const vStart=value.charCodeAt(0)\\n` +\n\t\t\t\t\t\t\t`const vEnd=value.charCodeAt(value.length - 1)\\n` +\n\t\t\t\t\t\t\t`if((vStart===91&&vEnd===93)||(vStart===123&&vEnd===125))\\n` +\n\t\t\t\t\t\t\t`try{` +\n\t\t\t\t\t\t\t`a${index}.push(JSON.parse(value))` +\n\t\t\t\t\t\t\t`}catch{` +\n\t\t\t\t\t\t\t`a${index}.push(value)` +\n\t\t\t\t\t\t\t`}` +\n\t\t\t\t\t\t\t`if(deepMemory===-1)break` +\n\t\t\t\t\t\t\t`}}`\n\n\t\t\t\t\tfnLiteral += '}}'\n\t\t\t\t}\n\n\t\t\t\tindex++\n\t\t\t\tfnLiteral += '\\n'\n\t\t\t}\n\n\t\t\tfnLiteral +=\n\t\t\t\t`c.query={` +\n\t\t\t\tdestructured\n\t\t\t\t\t.map(({ key }, index) => `'${key}':a${index}`)\n\t\t\t\t\t.join(',') +\n\t\t\t\t`}`\n\n\t\t\t// If there are no query parameters, set it to an empty object\n\t\t\tfnLiteral += `} else c.query = {}\\n`\n\t\t}\n\t}\n\n\tconst isAsyncHandler = typeof handler === 'function' && isAsync(handler)\n\n\tconst saveResponse =\n\t\thasTrace || hooks.afterResponse?.length ? 'c.response= ' : ''\n\n\tconst maybeAsync =\n\t\thasCookie ||\n\t\thasBody ||\n\t\tisAsyncHandler ||\n\t\t!!hooks.parse?.length ||\n\t\t!!hooks.afterHandle?.some(isAsync) ||\n\t\t!!hooks.beforeHandle?.some(isAsync) ||\n\t\t!!hooks.transform?.some(isAsync) ||\n\t\t!!hooks.mapResponse?.some(isAsync)\n\n\tconst maybeStream =\n\t\t(typeof handler === 'function' ? isGenerator(handler as any) : false) ||\n\t\t!!hooks.beforeHandle?.some(isGenerator) ||\n\t\t!!hooks.afterHandle?.some(isGenerator) ||\n\t\t!!hooks.transform?.some(isGenerator)\n\n\tconst hasSet =\n\t\tinference.cookie ||\n\t\tinference.set ||\n\t\thasHeaders ||\n\t\thasTrace ||\n\t\tvalidator.response ||\n\t\t(isHandleFn && hasDefaultHeaders) ||\n\t\tmaybeStream\n\n\tconst mapResponseContext = adapter.mapResponseContext\n\t\t? `,${adapter.mapResponseContext}`\n\t\t: ''\n\n\tif (inference.route) fnLiteral += `c.route=\\`${path}\\`\\n`\n\n\tconst parseReporter = report('parse', {\n\t\ttotal: hooks.parse?.length\n\t})\n\n\tif (hasBody) {\n\t\tconst isOptionalBody = isOptional(validator.body)\n\n\t\tconst hasBodyInference =\n\t\t\t!!hooks.parse?.length || inference.body || validator.body\n\n\t\tif (adapter.parser.declare) fnLiteral += adapter.parser.declare\n\n\t\tfnLiteral += '\\nisParsing=true\\n'\n\n\t\tconst parser =\n\t\t\ttypeof hooks.parse === 'string'\n\t\t\t\t? hooks.parse\n\t\t\t\t: Array.isArray(hooks.parse) && hooks.parse.length === 1\n\t\t\t\t\t? typeof hooks.parse[0] === 'string'\n\t\t\t\t\t\t? hooks.parse[0]\n\t\t\t\t\t\t: typeof hooks.parse[0].fn === 'string'\n\t\t\t\t\t\t\t? hooks.parse[0].fn\n\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t: undefined\n\n\t\tif (parser && defaultParsers.includes(parser)) {\n\t\t\tconst reporter = report('parse', {\n\t\t\t\ttotal: hooks.parse?.length\n\t\t\t})\n\n\t\t\tswitch (parser) {\n\t\t\t\tcase 'json':\n\t\t\t\tcase 'application/json':\n\t\t\t\t\tfnLiteral += adapter.parser.json(isOptionalBody)\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'text':\n\t\t\t\tcase 'text/plain':\n\t\t\t\t\tfnLiteral += adapter.parser.text(isOptionalBody)\n\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'urlencoded':\n\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\tfnLiteral += adapter.parser.urlencoded(isOptionalBody)\n\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'arrayBuffer':\n\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\tfnLiteral += adapter.parser.arrayBuffer(isOptionalBody)\n\n\t\t\t\t\tbreak\n\n\t\t\t\tcase 'formdata':\n\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\tfnLiteral += adapter.parser.formData(isOptionalBody)\n\t\t\t\t\tbreak\n\n\t\t\t\tdefault:\n\t\t\t\t\tif ((parser[0] as string) in app['~parser']) {\n\t\t\t\t\t\tfnLiteral += hasHeaders\n\t\t\t\t\t\t\t? `let contentType = c.headers['content-type']`\n\t\t\t\t\t\t\t: `let contentType = c.request.headers.get('content-type')`\n\n\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t`\\nif(contentType){` +\n\t\t\t\t\t\t\t`const index=contentType.indexOf(';')\\n` +\n\t\t\t\t\t\t\t`if(index!==-1)contentType=contentType.substring(0, index)}\\n` +\n\t\t\t\t\t\t\t`else{contentType=''}` +\n\t\t\t\t\t\t\t`c.contentType=contentType\\n`\n\n\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t`let result=parser['${parser}'](c, contentType)\\n` +\n\t\t\t\t\t\t\t`if(result instanceof Promise)result=await result\\n` +\n\t\t\t\t\t\t\t`if(result instanceof ElysiaCustomStatusResponse)throw result\\n` +\n\t\t\t\t\t\t\t`if(result!==undefined)c.body=result\\n` +\n\t\t\t\t\t\t\t'delete c.contentType\\n'\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak\n\t\t\t}\n\n\t\t\treporter.resolve()\n\t\t} else if (hasBodyInference) {\n\t\t\tfnLiteral += '\\n'\n\t\t\tfnLiteral += hasHeaders\n\t\t\t\t? `let contentType = c.headers['content-type']`\n\t\t\t\t: `let contentType = c.request.headers.get('content-type')`\n\n\t\t\tfnLiteral +=\n\t\t\t\t`\\nif(contentType){` +\n\t\t\t\t`const index=contentType.indexOf(';')\\n` +\n\t\t\t\t`if(index!==-1)contentType=contentType.substring(0, index)}\\n` +\n\t\t\t\t`else{contentType=''}` +\n\t\t\t\t`c.contentType=contentType\\n`\n\n\t\t\tif (hooks.parse?.length) fnLiteral += `let used=false\\n`\n\n\t\t\tconst reporter = report('parse', {\n\t\t\t\ttotal: hooks.parse?.length\n\t\t\t})\n\n\t\t\tlet hasDefaultParser = false\n\t\t\tif (hooks.parse)\n\t\t\t\tfor (let i = 0; i < hooks.parse.length; i++) {\n\t\t\t\t\tconst name = `bo${i}`\n\t\t\t\t\tif (i !== 0) fnLiteral += `\\nif(!used){`\n\n\t\t\t\t\tif (typeof hooks.parse[i].fn === 'string') {\n\t\t\t\t\t\tconst endUnit = reporter.resolveChild(\n\t\t\t\t\t\t\thooks.parse[i].fn as unknown as string\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tswitch (hooks.parse[i].fn as unknown as string) {\n\t\t\t\t\t\t\tcase 'json':\n\t\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\t\thasDefaultParser = true\n\t\t\t\t\t\t\t\tfnLiteral += adapter.parser.json(isOptionalBody)\n\n\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\tcase 'text':\n\t\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\t\thasDefaultParser = true\n\t\t\t\t\t\t\t\tfnLiteral += adapter.parser.text(isOptionalBody)\n\n\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\tcase 'urlencoded':\n\t\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\t\thasDefaultParser = true\n\t\t\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t\t\tadapter.parser.urlencoded(isOptionalBody)\n\n\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\tcase 'arrayBuffer':\n\t\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\t\thasDefaultParser = true\n\t\t\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t\t\tadapter.parser.arrayBuffer(isOptionalBody)\n\n\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\tcase 'formdata':\n\t\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\t\thasDefaultParser = true\n\t\t\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t\t\tadapter.parser.formData(isOptionalBody)\n\n\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t\t\t`${name}=parser['${hooks.parse[i].fn}'](c,contentType)\\n` +\n\t\t\t\t\t\t\t\t\t`if(${name} instanceof Promise)${name}=await ${name}\\n` +\n\t\t\t\t\t\t\t\t\t`if(${name}!==undefined){c.body=${name};used=true}\\n`\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tendUnit()\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst endUnit = reporter.resolveChild(\n\t\t\t\t\t\t\thooks.parse[i].fn.name\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t`let ${name}=e.parse[${i}]\\n` +\n\t\t\t\t\t\t\t`${name}=${name}(c,contentType)\\n` +\n\t\t\t\t\t\t\t`if(${name} instanceof Promise)${name}=await ${name}\\n` +\n\t\t\t\t\t\t\t`if(${name}!==undefined){c.body=${name};used=true}`\n\n\t\t\t\t\t\tendUnit()\n\t\t\t\t\t}\n\n\t\t\t\t\tif (i !== 0) fnLiteral += `}`\n\n\t\t\t\t\tif (hasDefaultParser) break\n\t\t\t\t}\n\n\t\t\treporter.resolve()\n\n\t\t\tif (!hasDefaultParser) {\n\t\t\t\tif (hooks.parse?.length)\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t`\\nif(!used){\\n` +\n\t\t\t\t\t\t`if(!contentType) throw new ParseError()\\n`\n\n\t\t\t\tfnLiteral += `switch(contentType){`\n\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`case 'application/json':\\n` +\n\t\t\t\t\tadapter.parser.json(isOptionalBody) +\n\t\t\t\t\t`break\\n` +\n\t\t\t\t\t`case 'text/plain':` +\n\t\t\t\t\tadapter.parser.text(isOptionalBody) +\n\t\t\t\t\t`break` +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t`case 'application/x-www-form-urlencoded':` +\n\t\t\t\t\tadapter.parser.urlencoded(isOptionalBody) +\n\t\t\t\t\t`break` +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t`case 'application/octet-stream':` +\n\t\t\t\t\tadapter.parser.arrayBuffer(isOptionalBody) +\n\t\t\t\t\t`break` +\n\t\t\t\t\t'\\n' +\n\t\t\t\t\t`case 'multipart/form-data':` +\n\t\t\t\t\tadapter.parser.formData(isOptionalBody) +\n\t\t\t\t\t`break` +\n\t\t\t\t\t'\\n'\n\n\t\t\t\tfor (const key of Object.keys(app['~parser']))\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t`case '${key}':` +\n\t\t\t\t\t\t`let bo${key}=parser['${key}'](c,contentType)\\n` +\n\t\t\t\t\t\t`if(bo${key} instanceof Promise)bo${key}=await bo${key}\\n` +\n\t\t\t\t\t\t`if(bo${key} instanceof ElysiaCustomStatusResponse)throw result\\n` +\n\t\t\t\t\t\t`if(bo${key}!==undefined)c.body=bo${key}\\n` +\n\t\t\t\t\t\t`break` +\n\t\t\t\t\t\t'\\n'\n\n\t\t\t\tif (hooks.parse?.length) fnLiteral += '}'\n\n\t\t\t\tfnLiteral += '}'\n\t\t\t}\n\n\t\t\t// fnLiteral += '}'\n\t\t}\n\n\t\tfnLiteral += '\\ndelete c.contentType'\n\t\tfnLiteral += '\\nisParsing=false\\n'\n\t}\n\n\tparseReporter.resolve()\n\n\tif (hooks?.transform) {\n\t\tconst reporter = report('transform', {\n\t\t\ttotal: hooks.transform.length\n\t\t})\n\n\t\tif (hooks.transform.length) fnLiteral += 'let transformed\\n'\n\n\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\tconst transform = hooks.transform[i]\n\n\t\t\tconst endUnit = reporter.resolveChild(transform.fn.name)\n\n\t\t\tfnLiteral += isAsync(transform)\n\t\t\t\t? `transformed=await e.transform[${i}](c)\\n`\n\t\t\t\t: `transformed=e.transform[${i}](c)\\n`\n\n\t\t\tif (transform.subType === 'mapDerive')\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`if(transformed instanceof ElysiaCustomStatusResponse)throw transformed\\n` +\n\t\t\t\t\t`else{` +\n\t\t\t\t\t`transformed.request=c.request\\n` +\n\t\t\t\t\t`transformed.store=c.store\\n` +\n\t\t\t\t\t`transformed.qi=c.qi\\n` +\n\t\t\t\t\t`transformed.path=c.path\\n` +\n\t\t\t\t\t`transformed.url=c.url\\n` +\n\t\t\t\t\t`transformed.redirect=c.redirect\\n` +\n\t\t\t\t\t`transformed.set=c.set\\n` +\n\t\t\t\t\t`transformed.error=c.error\\n` +\n\t\t\t\t\t`c=transformed` +\n\t\t\t\t\t'}'\n\t\t\telse\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`if(transformed instanceof ElysiaCustomStatusResponse)throw transformed\\n` +\n\t\t\t\t\t`else Object.assign(c,transformed)\\n`\n\n\t\t\tendUnit()\n\t\t}\n\n\t\treporter.resolve()\n\t}\n\n\tif (validator) {\n\t\tif (validator.headers) {\n\t\t\tif (\n\t\t\t\tnormalize &&\n\t\t\t\t'Clean' in validator.headers &&\n\t\t\t\t!hasAdditionalProperties(validator.headers as any)\n\t\t\t)\n\t\t\t\tfnLiteral += 'c.headers=validator.headers.Clean(c.headers);\\n'\n\n\t\t\tif (hasProperty('default', validator.headers))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.headers.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed =\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: typeof value === 'string'\n\t\t\t\t\t\t\t\t? `'${value}'`\n\t\t\t\t\t\t\t\t: value\n\n\t\t\t\t\tif (parsed !== undefined)\n\t\t\t\t\t\tfnLiteral += `c.headers['${key}']??=${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tif (isOptional(validator.headers))\n\t\t\t\tfnLiteral += `if(isNotEmpty(c.headers)){`\n\n\t\t\tfnLiteral +=\n\t\t\t\t`if(validator.headers.Check(c.headers) === false){` +\n\t\t\t\tcomposeValidation('headers') +\n\t\t\t\t'}'\n\n\t\t\t// @ts-expect-error private property\n\t\t\tif (hasTransform(validator.headers.schema))\n\t\t\t\tfnLiteral += `c.headers=validator.headers.Decode(c.headers)\\n`\n\n\t\t\tif (isOptional(validator.headers)) fnLiteral += '}'\n\t\t}\n\n\t\tif (validator.params) {\n\t\t\tif (hasProperty('default', validator.params))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.params.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed =\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: typeof value === 'string'\n\t\t\t\t\t\t\t\t? `'${value}'`\n\t\t\t\t\t\t\t\t: value\n\n\t\t\t\t\tif (parsed !== undefined)\n\t\t\t\t\t\tfnLiteral += `c.params['${key}']??=${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tfnLiteral +=\n\t\t\t\t`if(validator.params.Check(c.params)===false){` +\n\t\t\t\tcomposeValidation('params') +\n\t\t\t\t'}'\n\n\t\t\t// @ts-expect-error private property\n\t\t\tif (hasTransform(validator.params.schema))\n\t\t\t\tfnLiteral += `c.params=validator.params.Decode(c.params)\\n`\n\t\t}\n\n\t\tif (validator.query) {\n\t\t\tif (\n\t\t\t\tnormalize &&\n\t\t\t\t'Clean' in validator.query &&\n\t\t\t\t!hasAdditionalProperties(validator.query as any)\n\t\t\t)\n\t\t\t\tfnLiteral += 'c.query=validator.query.Clean(c.query)\\n'\n\n\t\t\tif (hasProperty('default', validator.query))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tvalidator.query.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tconst parsed =\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: typeof value === 'string'\n\t\t\t\t\t\t\t\t? `'${value}'`\n\t\t\t\t\t\t\t\t: value\n\n\t\t\t\t\tif (parsed !== undefined)\n\t\t\t\t\t\tfnLiteral += `if(c.query['${key}']===undefined)c.query['${key}']=${parsed}\\n`\n\t\t\t\t}\n\n\t\t\tif (isOptional(validator.query))\n\t\t\t\tfnLiteral += `if(isNotEmpty(c.query)){`\n\n\t\t\tfnLiteral +=\n\t\t\t\t`if(validator.query.Check(c.query)===false){` +\n\t\t\t\tcomposeValidation('query') +\n\t\t\t\t`}`\n\n\t\t\t// @ts-expect-error private property\n\t\t\tif (hasTransform(validator.query.schema))\n\t\t\t\tfnLiteral += `c.query=validator.query.Decode(Object.assign({},c.query))\\n`\n\n\t\t\tif (isOptional(validator.query)) fnLiteral += `}`\n\t\t}\n\n\t\tif (validator.body) {\n\t\t\tif (\n\t\t\t\tnormalize &&\n\t\t\t\t'Clean' in validator.body &&\n\t\t\t\t!hasAdditionalProperties(validator.body as any)\n\t\t\t)\n\t\t\t\tfnLiteral += 'c.body=validator.body.Clean(c.body)\\n'\n\n\t\t\t// @ts-expect-error private property\n\t\t\tconst doesHaveTransform = hasTransform(validator.body.schema)\n\n\t\t\tif (doesHaveTransform || isOptional(validator.body))\n\t\t\t\tfnLiteral += `const isNotEmptyObject=c.body&&(typeof c.body===\"object\"&&isNotEmpty(c.body))\\n`\n\n\t\t\tif (hasProperty('default', validator.body)) {\n\t\t\t\tconst value = Value.Default(\n\t\t\t\t\t// @ts-expect-error private property\n\t\t\t\t\tvalidator.body.schema,\n\t\t\t\t\t// @ts-expect-error private property\n\t\t\t\t\tvalidator.body.schema.type === 'object' ? {} : undefined\n\t\t\t\t)\n\n\t\t\t\tconst parsed =\n\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t: typeof value === 'string'\n\t\t\t\t\t\t\t? `'${value}'`\n\t\t\t\t\t\t\t: value\n\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`if(validator.body.Check(c.body)===false){` +\n\t\t\t\t\t`if(typeof c.body==='object')` +\n\t\t\t\t\t`c.body=Object.assign(${parsed},c.body)\\n` +\n\t\t\t\t\t`else c.body=${parsed}\\n`\n\n\t\t\t\tif (isOptional(validator.body))\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t`if(isNotEmptyObject&&validator.body.Check(c.body)===false){` +\n\t\t\t\t\t\tcomposeValidation('body') +\n\t\t\t\t\t\t'}'\n\t\t\t\telse\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t`if(validator.body.Check(c.body)===false){` +\n\t\t\t\t\t\tcomposeValidation('body') +\n\t\t\t\t\t\t`}`\n\n\t\t\t\tfnLiteral += '}'\n\t\t\t} else {\n\t\t\t\tif (isOptional(validator.body))\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t`if(isNotEmptyObject&&validator.body.Check(c.body)===false){` +\n\t\t\t\t\t\tcomposeValidation('body') +\n\t\t\t\t\t\t'}'\n\t\t\t\telse\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t`if(validator.body.Check(c.body)===false){` +\n\t\t\t\t\t\tcomposeValidation('body') +\n\t\t\t\t\t\t'}'\n\t\t\t}\n\n\t\t\tif (doesHaveTransform)\n\t\t\t\tfnLiteral += `if(isNotEmptyObject)c.body=validator.body.Decode(c.body)\\n`\n\t\t}\n\n\t\tif (\n\t\t\tcookieValidator &&\n\t\t\tisNotEmpty(\n\t\t\t\t// @ts-ignore\n\t\t\t\tcookieValidator?.schema?.properties ??\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tcookieValidator?.schema?.schema ??\n\t\t\t\t\t{}\n\t\t\t)\n\t\t) {\n\t\t\tfnLiteral +=\n\t\t\t\t`const cookieValue={}\\n` +\n\t\t\t\t`for(const [key,value] of Object.entries(c.cookie))` +\n\t\t\t\t`cookieValue[key]=value.value\\n`\n\n\t\t\tif (hasProperty('default', cookieValidator))\n\t\t\t\tfor (const [key, value] of Object.entries(\n\t\t\t\t\tValue.Default(\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tcookieValidator.schema,\n\t\t\t\t\t\t{}\n\t\t\t\t\t) as Object\n\t\t\t\t)) {\n\t\t\t\t\tfnLiteral += `cookieValue['${key}'] = ${\n\t\t\t\t\t\ttypeof value === 'object'\n\t\t\t\t\t\t\t? JSON.stringify(value)\n\t\t\t\t\t\t\t: value\n\t\t\t\t\t}\\n`\n\t\t\t\t}\n\n\t\t\tif (isOptional(validator.cookie))\n\t\t\t\tfnLiteral += `if(isNotEmpty(c.cookie)){`\n\n\t\t\tfnLiteral +=\n\t\t\t\t`if(validator.cookie.Check(cookieValue)===false){` +\n\t\t\t\tcomposeValidation('cookie', 'cookieValue') +\n\t\t\t\t'}'\n\n\t\t\t// @ts-expect-error private property\n\t\t\tif (hasTransform(validator.cookie.schema))\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`for(const [key,value] of Object.entries(validator.cookie.Decode(cookieValue)))` +\n\t\t\t\t\t`c.cookie[key].value=value\\n`\n\n\t\t\tif (isOptional(validator.cookie)) fnLiteral += `}`\n\t\t}\n\t}\n\n\tif (hooks?.beforeHandle) {\n\t\tconst reporter = report('beforeHandle', {\n\t\t\ttotal: hooks.beforeHandle.length\n\t\t})\n\n\t\tlet hasResolve = false\n\n\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\tconst beforeHandle = hooks.beforeHandle[i]\n\n\t\t\tconst endUnit = reporter.resolveChild(beforeHandle.fn.name)\n\n\t\t\tconst returning = hasReturn(beforeHandle)\n\t\t\tconst isResolver =\n\t\t\t\tbeforeHandle.subType === 'resolve' ||\n\t\t\t\tbeforeHandle.subType === 'mapResolve'\n\n\t\t\tif (isResolver) {\n\t\t\t\tif (!hasResolve) {\n\t\t\t\t\thasResolve = true\n\t\t\t\t\tfnLiteral += '\\nlet resolved\\n'\n\t\t\t\t}\n\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `resolved=await e.beforeHandle[${i}](c);\\n`\n\t\t\t\t\t: `resolved=e.beforeHandle[${i}](c);\\n`\n\n\t\t\t\tif (beforeHandle.subType === 'mapResolve')\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t`if(resolved instanceof ElysiaCustomStatusResponse)` +\n\t\t\t\t\t\t`throw resolved\\n` +\n\t\t\t\t\t\t`else{` +\n\t\t\t\t\t\t`resolved.request = c.request\\n` +\n\t\t\t\t\t\t`resolved.store = c.store\\n` +\n\t\t\t\t\t\t`resolved.qi = c.qi\\n` +\n\t\t\t\t\t\t`resolved.path = c.path\\n` +\n\t\t\t\t\t\t`resolved.url = c.url\\n` +\n\t\t\t\t\t\t`resolved.redirect = c.redirect\\n` +\n\t\t\t\t\t\t`resolved.set = c.set\\n` +\n\t\t\t\t\t\t`resolved.error = c.error\\n` +\n\t\t\t\t\t\t`c = resolved` +\n\t\t\t\t\t\t`}`\n\t\t\t\telse\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t`if(resolved instanceof ElysiaCustomStatusResponse)throw resolved\\n` +\n\t\t\t\t\t\t`else Object.assign(c, resolved)\\n`\n\t\t\t} else if (!returning) {\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `await e.beforeHandle[${i}](c)\\n`\n\t\t\t\t\t: `e.beforeHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit()\n\t\t\t} else {\n\t\t\t\tfnLiteral += isAsync(beforeHandle)\n\t\t\t\t\t? `be=await e.beforeHandle[${i}](c)\\n`\n\t\t\t\t\t: `be=e.beforeHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit('be')\n\n\t\t\t\tfnLiteral += `if(be!==undefined){`\n\t\t\t\treporter.resolve()\n\n\t\t\t\tif (hooks.afterHandle?.length) {\n\t\t\t\t\treport('handle', {\n\t\t\t\t\t\tname: isHandleFn\n\t\t\t\t\t\t\t? (handler as Function).name\n\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t}).resolve()\n\n\t\t\t\t\tconst reporter = report('afterHandle', {\n\t\t\t\t\t\ttotal: hooks.afterHandle.length\n\t\t\t\t\t})\n\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tconst hook = hooks.afterHandle[i]\n\t\t\t\t\t\tconst returning = hasReturn(hook)\n\t\t\t\t\t\tconst endUnit = reporter.resolveChild(hook.fn.name)\n\n\t\t\t\t\t\tfnLiteral += `c.response = be\\n`\n\n\t\t\t\t\t\tif (!returning) {\n\t\t\t\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t\t\t\t? `await e.afterHandle[${i}](c, be)\\n`\n\t\t\t\t\t\t\t\t: `e.afterHandle[${i}](c, be)\\n`\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t\t\t\t? `af = await e.afterHandle[${i}](c)\\n`\n\t\t\t\t\t\t\t\t: `af = e.afterHandle[${i}](c)\\n`\n\n\t\t\t\t\t\t\tfnLiteral += `if(af!==undefined) c.response=be=af\\n`\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tendUnit('af')\n\t\t\t\t\t}\n\t\t\t\t\treporter.resolve()\n\t\t\t\t}\n\n\t\t\t\tif (validator.response)\n\t\t\t\t\tfnLiteral += composeResponseValidation('be')\n\n\t\t\t\tconst mapResponseReporter = report('mapResponse', {\n\t\t\t\t\ttotal: hooks.mapResponse?.length\n\t\t\t\t})\n\n\t\t\t\tif (hooks.mapResponse?.length) {\n\t\t\t\t\tfnLiteral += `c.response=be\\n`\n\n\t\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\t\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\t\t\t\tmapResponse.fn.name\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t`if(mr===undefined){` +\n\t\t\t\t\t\t\t`mr=${isAsyncName(mapResponse) ? 'await ' : ''}e.mapResponse[${i}](c)\\n` +\n\t\t\t\t\t\t\t`if(mr!==undefined)be=c.response=mr` +\n\t\t\t\t\t\t\t'}'\n\n\t\t\t\t\t\tendUnit()\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmapResponseReporter.resolve()\n\n\t\t\t\tfnLiteral += encodeCookie\n\t\t\t\tfnLiteral += `return mapEarlyResponse(${saveResponse}be,c.set${\n\t\t\t\t\tmapResponseContext\n\t\t\t\t})}\\n`\n\t\t\t}\n\t\t}\n\n\t\treporter.resolve()\n\t}\n\n\tif (hooks.afterHandle?.length) {\n\t\tconst handleReporter = report('handle', {\n\t\t\tname: isHandleFn ? (handler as Function).name : undefined\n\t\t})\n\n\t\tif (hooks.afterHandle.length)\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r=c.response=await ${handle}\\n`\n\t\t\t\t: `let r=c.response=${handle}\\n`\n\t\telse\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r=await ${handle}\\n`\n\t\t\t\t: `let r=${handle}\\n`\n\n\t\thandleReporter.resolve()\n\n\t\tconst reporter = report('afterHandle', {\n\t\t\ttotal: hooks.afterHandle.length\n\t\t})\n\n\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\tconst hook = hooks.afterHandle[i]\n\t\t\tconst returning = hasReturn(hook)\n\t\t\tconst endUnit = reporter.resolveChild(hook.fn.name)\n\n\t\t\tif (!returning) {\n\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t? `await e.afterHandle[${i}](c)\\n`\n\t\t\t\t\t: `e.afterHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit()\n\t\t\t} else {\n\t\t\t\tfnLiteral += isAsync(hook.fn)\n\t\t\t\t\t? `af=await e.afterHandle[${i}](c)\\n`\n\t\t\t\t\t: `af=e.afterHandle[${i}](c)\\n`\n\n\t\t\t\tendUnit('af')\n\n\t\t\t\tif (validator.response) {\n\t\t\t\t\tfnLiteral += `if(af!==undefined){`\n\t\t\t\t\treporter.resolve()\n\n\t\t\t\t\tfnLiteral += composeResponseValidation('af')\n\n\t\t\t\t\tfnLiteral += `c.response=af}`\n\t\t\t\t} else {\n\t\t\t\t\tfnLiteral += `if(af!==undefined){`\n\t\t\t\t\treporter.resolve()\n\n\t\t\t\t\tfnLiteral += `c.response=af}`\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treporter.resolve()\n\n\t\tfnLiteral += `r=c.response\\n`\n\n\t\tif (validator.response) fnLiteral += composeResponseValidation()\n\n\t\tfnLiteral += encodeCookie\n\n\t\tconst mapResponseReporter = report('mapResponse', {\n\t\t\ttotal: hooks.mapResponse?.length\n\t\t})\n\t\tif (hooks.mapResponse?.length) {\n\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\t\tmapResponse.fn.name\n\t\t\t\t)\n\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`mr=${\n\t\t\t\t\t\tisAsyncName(mapResponse) ? 'await ' : ''\n\t\t\t\t\t}e.mapResponse[${i}](c)\\n` +\n\t\t\t\t\t`if(mr!==undefined)r=c.response=mr\\n`\n\n\t\t\t\tendUnit()\n\t\t\t}\n\t\t}\n\t\tmapResponseReporter.resolve()\n\n\t\tif (hasSet)\n\t\t\tfnLiteral += `return mapResponse(${saveResponse}r,c.set${\n\t\t\t\tmapResponseContext\n\t\t\t})\\n`\n\t\telse\n\t\t\tfnLiteral += `return mapCompactResponse(${saveResponse}r${\n\t\t\t\tmapResponseContext\n\t\t\t})\\n`\n\t} else {\n\t\tconst handleReporter = report('handle', {\n\t\t\tname: isHandleFn ? (handler as Function).name : undefined\n\t\t})\n\n\t\tif (validator.response || hooks.mapResponse?.length) {\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r=await ${handle}\\n`\n\t\t\t\t: `let r=${handle}\\n`\n\n\t\t\thandleReporter.resolve()\n\n\t\t\tif (validator.response) fnLiteral += composeResponseValidation()\n\n\t\t\treport('afterHandle').resolve()\n\n\t\t\tconst mapResponseReporter = report('mapResponse', {\n\t\t\t\ttotal: hooks.mapResponse?.length\n\t\t\t})\n\n\t\t\tif (hooks.mapResponse?.length) {\n\t\t\t\tfnLiteral += '\\nc.response=r\\n'\n\n\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\t\t\tmapResponse.fn.name\n\t\t\t\t\t)\n\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t`\\nif(mr===undefined){` +\n\t\t\t\t\t\t`mr=${isAsyncName(mapResponse) ? 'await ' : ''}e.mapResponse[${i}](c)\\n` +\n\t\t\t\t\t\t`if(mr!==undefined)r=c.response=mr` +\n\t\t\t\t\t\t`}\\n`\n\n\t\t\t\t\tendUnit()\n\t\t\t\t}\n\t\t\t}\n\t\t\tmapResponseReporter.resolve()\n\n\t\t\tfnLiteral += encodeCookie\n\n\t\t\tif (handler instanceof Response) {\n\t\t\t\tfnLiteral += inference.set\n\t\t\t\t\t? `if(` +\n\t\t\t\t\t\t`isNotEmpty(c.set.headers)||` +\n\t\t\t\t\t\t`c.set.status!==200||` +\n\t\t\t\t\t\t`c.set.redirect||` +\n\t\t\t\t\t\t`c.set.cookie)return mapResponse(${saveResponse}${handle}.clone(),c.set${\n\t\t\t\t\t\t\tmapResponseContext\n\t\t\t\t\t\t})` +\n\t\t\t\t\t\t`else return ${handle}.clone()`\n\t\t\t\t\t: `return ${handle}.clone()`\n\n\t\t\t\tfnLiteral += '\\n'\n\t\t\t} else if (hasSet)\n\t\t\t\tfnLiteral += `return mapResponse(${saveResponse}r,c.set${\n\t\t\t\t\tmapResponseContext\n\t\t\t\t})\\n`\n\t\t\telse\n\t\t\t\tfnLiteral += `return mapCompactResponse(${saveResponse}r${\n\t\t\t\t\tmapResponseContext\n\t\t\t\t})\\n`\n\t\t} else if (hasCookie || hasTrace) {\n\t\t\tfnLiteral += isAsyncHandler\n\t\t\t\t? `let r=await ${handle}\\n`\n\t\t\t\t: `let r=${handle}\\n`\n\n\t\t\thandleReporter.resolve()\n\n\t\t\treport('afterHandle').resolve()\n\n\t\t\tconst mapResponseReporter = report('mapResponse', {\n\t\t\t\ttotal: hooks.mapResponse?.length\n\t\t\t})\n\t\t\tif (hooks.mapResponse?.length) {\n\t\t\t\tfnLiteral += 'c.response= r\\n'\n\n\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\t\t\tmapResponse.fn.name\n\t\t\t\t\t)\n\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t`if(mr===undefined){` +\n\t\t\t\t\t\t`mr=${isAsyncName(mapResponse) ? 'await ' : ''}e.mapResponse[${i}](c)\\n` +\n\t\t\t\t\t\t`if(mr!==undefined)r=c.response=mr` +\n\t\t\t\t\t\t`}`\n\n\t\t\t\t\tendUnit()\n\t\t\t\t}\n\t\t\t}\n\t\t\tmapResponseReporter.resolve()\n\n\t\t\tfnLiteral += encodeCookie\n\n\t\t\tif (hasSet)\n\t\t\t\tfnLiteral += `return mapResponse(${saveResponse}r,c.set${\n\t\t\t\t\tmapResponseContext\n\t\t\t\t})\\n`\n\t\t\telse\n\t\t\t\tfnLiteral += `return mapCompactResponse(${saveResponse}r${\n\t\t\t\t\tmapResponseContext\n\t\t\t\t})\\n`\n\t\t} else {\n\t\t\thandleReporter.resolve()\n\n\t\t\tconst handled = isAsyncHandler ? `await ${handle}` : handle\n\n\t\t\treport('afterHandle').resolve()\n\n\t\t\tif (handler instanceof Response) {\n\t\t\t\tfnLiteral += inference.set\n\t\t\t\t\t? `if(isNotEmpty(c.set.headers)||` +\n\t\t\t\t\t\t`c.set.status!==200||` +\n\t\t\t\t\t\t`c.set.redirect||` +\n\t\t\t\t\t\t`c.set.cookie)` +\n\t\t\t\t\t\t`return mapResponse(${saveResponse}${handle}.clone(),c.set${\n\t\t\t\t\t\t\tmapResponseContext\n\t\t\t\t\t\t})\\n` +\n\t\t\t\t\t\t`else return ${handle}.clone()\\n`\n\t\t\t\t\t: `return ${handle}.clone()\\n`\n\t\t\t} else if (hasSet)\n\t\t\t\tfnLiteral += `return mapResponse(${saveResponse}${handled},c.set${\n\t\t\t\t\tmapResponseContext\n\t\t\t\t})\\n`\n\t\t\telse\n\t\t\t\tfnLiteral += `return mapCompactResponse(${saveResponse}${handled}${\n\t\t\t\t\tmapResponseContext\n\t\t\t\t})\\n`\n\t\t}\n\t}\n\n\tfnLiteral += `\\n}catch(error){`\n\n\tif (hasBody) fnLiteral += `if(isParsing)error=new ParseError()\\n`\n\n\tif (!maybeAsync) fnLiteral += `return(async()=>{`\n\tfnLiteral +=\n\t\t`const set=c.set\\n` +\n\t\t`if(!set.status||set.status<300)set.status=error?.status||500\\n`\n\n\tif (hasTrace && hooks.trace)\n\t\tfor (let i = 0; i < hooks.trace.length; i++)\n\t\t\t// There's a case where the error is thrown before any trace is called\n\t\t\tfnLiteral += `report${i}?.resolve(error);reportChild${i}?.(error)\\n`\n\n\tconst errorReporter = report('error', {\n\t\ttotal: hooks.error?.length\n\t})\n\n\tif (hooks.error?.length) {\n\t\tfnLiteral += `c.error=error\\n`\n\n\t\tif (hasValidation)\n\t\t\tfnLiteral +=\n\t\t\t\t`if(error instanceof TypeBoxError){` +\n\t\t\t\t'c.code=\"VALIDATION\"\\n' +\n\t\t\t\t'c.set.status=422' +\n\t\t\t\t'}else{' +\n\t\t\t\t`c.code=error.code??error[ERROR_CODE]??\"UNKNOWN\"}`\n\t\telse fnLiteral += `c.code=error.code??error[ERROR_CODE]??\"UNKNOWN\"\\n`\n\n\t\tfnLiteral += `let er\\n`\n\n\t\tfor (let i = 0; i < hooks.error.length; i++) {\n\t\t\tconst endUnit = errorReporter.resolveChild(hooks.error[i].fn.name)\n\n\t\t\tif (isAsync(hooks.error[i]))\n\t\t\t\tfnLiteral += `er=await e.error[${i}](c)\\n`\n\t\t\telse\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`er=e.error[${i}](c)\\n` +\n\t\t\t\t\t`if(er instanceof Promise)er=await er\\n`\n\n\t\t\tendUnit()\n\n\t\t\tconst mapResponseReporter = report('mapResponse', {\n\t\t\t\ttotal: hooks.mapResponse?.length\n\t\t\t})\n\n\t\t\tif (hooks.mapResponse?.length) {\n\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\t\t\tmapResponse.fn.name\n\t\t\t\t\t)\n\n\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t`c.response=er\\n` +\n\t\t\t\t\t\t`er=e.mapResponse[${i}](c)\\n` +\n\t\t\t\t\t\t`if(er instanceof Promise)er=await er\\n`\n\n\t\t\t\t\tendUnit()\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmapResponseReporter.resolve()\n\n\t\t\tfnLiteral += `er=mapEarlyResponse(er,set${mapResponseContext})\\n`\n\t\t\tfnLiteral += `if(er){`\n\n\t\t\tif (hasTrace && hooks.trace) {\n\t\t\t\tfor (let i = 0; i < hooks.trace.length; i++)\n\t\t\t\t\tfnLiteral += `report${i}.resolve()\\n`\n\n\t\t\t\terrorReporter.resolve()\n\t\t\t}\n\n\t\t\tfnLiteral += `return er}`\n\t\t}\n\t}\n\n\terrorReporter.resolve()\n\n\tfnLiteral += `return handleError(c,error,true)`\n\tif (!maybeAsync) fnLiteral += '})()'\n\tfnLiteral += '}'\n\n\tif (hasAfterResponse || hasTrace) {\n\t\tfnLiteral += `finally{ `\n\n\t\tif (!maybeAsync) fnLiteral += ';(async()=>{'\n\n\t\tconst reporter = report('afterResponse', {\n\t\t\ttotal: hooks.afterResponse?.length\n\t\t})\n\n\t\tif (hasAfterResponse && hooks.afterResponse) {\n\t\t\tfor (let i = 0; i < hooks.afterResponse.length; i++) {\n\t\t\t\tconst endUnit = reporter.resolveChild(\n\t\t\t\t\thooks.afterResponse[i].fn.name\n\t\t\t\t)\n\t\t\t\tfnLiteral += `\\nawait e.afterResponse[${i}](c)\\n`\n\t\t\t\tendUnit()\n\t\t\t}\n\t\t}\n\n\t\treporter.resolve()\n\n\t\tif (!maybeAsync) fnLiteral += '})()'\n\n\t\tfnLiteral += `}`\n\t}\n\n\tconst adapterVariables = adapter.inject\n\t\t? Object.keys(adapter.inject).join(',') + ','\n\t\t: ''\n\n\tlet init =\n\t\t`const {` +\n\t\t`handler,` +\n\t\t`handleError,` +\n\t\t`hooks:e, ` +\n\t\tallocateIf(`validator,`, hasValidation) +\n\t\t`mapResponse,` +\n\t\t`mapCompactResponse,` +\n\t\t`mapEarlyResponse,` +\n\t\t`isNotEmpty,` +\n\t\t`utils:{` +\n\t\tallocateIf(`parseQuery,`, hasBody) +\n\t\tallocateIf(`parseQueryFromURL,`, hasQuery) +\n\t\t`},` +\n\t\t`error:{` +\n\t\tallocateIf(`ValidationError,`, hasValidation) +\n\t\t`InternalServerError,` +\n\t\tallocateIf(`ParseError`, hasBody) +\n\t\t`},` +\n\t\t`schema,` +\n\t\t`definitions,` +\n\t\t`ERROR_CODE,` +\n\t\tallocateIf(`parseCookie,`, hasCookie) +\n\t\tallocateIf(`signCookie,`, hasCookie) +\n\t\tallocateIf(`decodeURIComponent,`, hasQuery) +\n\t\t`ElysiaCustomStatusResponse,` +\n\t\tallocateIf(`ELYSIA_TRACE,`, hasTrace) +\n\t\tallocateIf(`ELYSIA_REQUEST_ID,`, hasTrace) +\n\t\tallocateIf('parser,', hooks.parse?.length) +\n\t\tallocateIf(`getServer,`, inference.server) +\n\t\tadapterVariables +\n\t\tallocateIf('TypeBoxError', hasValidation) +\n\t\t`}=hooks\\n` +\n\t\t`const trace=e.trace?.map(x=>typeof x==='function'?x:x.fn)??[]\\n` +\n\t\t`return ${maybeAsync ? 'async ' : ''}function handle(c){`\n\n\tif (hooks.beforeHandle?.length) init += 'let be\\n'\n\tif (hooks.afterHandle?.length) init += 'let af\\n'\n\tif (hooks.mapResponse?.length) init += 'let mr\\n'\n\tif (allowMeta) init += 'c.schema = schema\\nc.defs = definitions\\n'\n\n\tinit += fnLiteral + '}'\n\n\ttry {\n\t\tif (asManifest) return Function('hooks', init) as any\n\n\t\treturn Function(\n\t\t\t'hooks',\n\t\t\tinit\n\t\t)({\n\t\t\thandler,\n\t\t\thooks: lifeCycleToFn(hooks),\n\t\t\tvalidator: hasValidation ? validator : undefined,\n\t\t\t// @ts-expect-error\n\t\t\thandleError: app.handleError,\n\t\t\tmapResponse: adapterHandler.mapResponse,\n\t\t\tmapCompactResponse: adapterHandler.mapCompactResponse,\n\t\t\tmapEarlyResponse: adapterHandler.mapEarlyResponse,\n\t\t\tisNotEmpty,\n\t\t\tutils: {\n\t\t\t\tparseQuery: hasBody ? parseQuery : undefined,\n\t\t\t\tparseQueryFromURL: hasQuery ? parseQueryFromURL : undefined\n\t\t\t},\n\t\t\terror: {\n\t\t\t\tValidationError: hasValidation ? ValidationError : undefined,\n\t\t\t\tInternalServerError,\n\t\t\t\tParseError: hasBody ? ParseError : undefined\n\t\t\t},\n\t\t\tschema: app.router.history,\n\t\t\t// @ts-expect-error\n\t\t\tdefinitions: app.definitions.type,\n\t\t\tERROR_CODE,\n\t\t\tparseCookie: hasCookie ? parseCookie : undefined,\n\t\t\tsignCookie: hasCookie ? signCookie : undefined,\n\t\t\tdecodeURIComponent: hasQuery ? decodeURIComponent : undefined,\n\t\t\tElysiaCustomStatusResponse,\n\t\t\tELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined,\n\t\t\tELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined,\n\t\t\t// @ts-expect-error private property\n\t\t\tgetServer: () => app.getServer(),\n\t\t\tTypeBoxError: hasValidation ? TypeBoxError : undefined,\n\t\t\tparser: app['~parser'],\n\t\t\t...adapter.inject\n\t\t})\n\t} catch (error) {\n\t\tconst debugHooks = lifeCycleToFn(hooks)\n\n\t\tconsole.log('[Composer] failed to generate optimized handler')\n\t\tconsole.log('---')\n\t\tconsole.log({\n\t\t\thandler:\n\t\t\t\ttypeof handler === 'function' ? handler.toString() : handler,\n\t\t\tinstruction: init,\n\t\t\thooks: {\n\t\t\t\t...debugHooks,\n\t\t\t\t// @ts-expect-error\n\t\t\t\ttransform: debugHooks?.transform?.map?.((x) => x.toString()),\n\t\t\t\t// @ts-expect-error\n\t\t\t\tresolve: debugHooks?.resolve?.map?.((x) => x.toString()),\n\t\t\t\t// @ts-expect-error\n\t\t\t\tbeforeHandle: debugHooks?.beforeHandle?.map?.((x) =>\n\t\t\t\t\tx.toString()\n\t\t\t\t),\n\t\t\t\t// @ts-expect-error\n\t\t\t\tafterHandle: debugHooks?.afterHandle?.map?.((x) =>\n\t\t\t\t\tx.toString()\n\t\t\t\t),\n\t\t\t\t// @ts-expect-error\n\t\t\t\tmapResponse: debugHooks?.mapResponse?.map?.((x) =>\n\t\t\t\t\tx.toString()\n\t\t\t\t),\n\t\t\t\t// @ts-expect-error\n\t\t\t\tparse: debugHooks?.parse?.map?.((x) => x.toString()),\n\t\t\t\t// @ts-expect-error\n\t\t\t\terror: debugHooks?.error?.map?.((x) => x.toString()),\n\t\t\t\t// @ts-expect-error\n\t\t\t\tafterResponse: debugHooks?.afterResponse?.map?.((x) =>\n\t\t\t\t\tx.toString()\n\t\t\t\t),\n\t\t\t\t// @ts-expect-error\n\t\t\t\tstop: debugHooks?.stop?.map?.((x) => x.toString())\n\t\t\t},\n\t\t\tvalidator,\n\t\t\t// @ts-expect-error\n\t\t\tdefinitions: app.definitions.type,\n\t\t\terror,\n\t\t\tfnLiteral\n\t\t})\n\t\tconsole.log('---')\n\n\t\tprocess.exit(1)\n\t}\n}\n\nexport interface ComposerGeneralHandlerOptions {\n\t/**\n\t * optimization for standard internet hostname\n\t * this will assume hostname is always use a standard internet hostname\n\t * assuming hostname is at minimum of 11 length of string (http://a.bc)\n\t *\n\t * setting this to true will skip the first 11 character of the hostname\n\t *\n\t * @default true\n\t */\n\tstandardHostname?: boolean\n}\n\nexport const composeGeneralHandler = (\n\tapp: AnyElysia,\n\t// eslint-disable-next-line @typescript-eslint/no-unused-vars\n\t{ asManifest = false }: { asManifest?: false } = {}\n) => {\n\tconst adapter = app['~adapter'].composeGeneralHandler\n\tapp.router.http.build()\n\tconst error404 = adapter.error404(\n\t\t!!app.event.request?.length,\n\t\t!!app.event.error?.length\n\t)\n\n\tconst hasTrace = app.event.trace?.length\n\n\tlet fnLiteral = ''\n\n\tconst router = app.router\n\n\tlet findDynamicRoute = `const route=router.find(r.method,p)`\n\tfindDynamicRoute += router.http.root.ALL ? '??router.find(\"ALL\",p)\\n' : '\\n'\n\n\tfindDynamicRoute += error404.code\n\n\tfindDynamicRoute +=\n\t\t`\\nc.params=route.params\\n` +\n\t\t`if(route.store.handler)return route.store.handler(c)\\n` +\n\t\t`return (route.store.handler=route.store.compile())(c)\\n`\n\n\tlet switchMap = ``\n\tfor (const [path, v] of Object.entries(router.static.http.map)) {\n\t\tswitchMap += `case'${path}':`\n\n\t\tif (app.config.strictPath !== true)\n\t\t\tswitchMap += `case'${getLoosePath(path)}':`\n\n\t\tconst encoded = encodePath(path)\n\t\tif (path !== encoded) switchMap += `case'${encoded}':`\n\n\t\tswitchMap +=\n\t\t\t`switch(r.method){${v.code}\\n` +\n\t\t\t(v.all ?? `default: break map`) +\n\t\t\t'}'\n\t}\n\n\tconst maybeAsync = !!app.event.request?.some(isAsync)\n\n\tconst adapterVariables = adapter.inject\n\t\t? Object.keys(adapter.inject).join(',') + ','\n\t\t: ''\n\n\tfnLiteral +=\n\t\t`\\nconst {` +\n\t\t`app,` +\n\t\t`mapEarlyResponse,` +\n\t\t`NotFoundError,` +\n\t\t`randomId,` +\n\t\t`handleError,` +\n\t\t`error,` +\n\t\t`redirect,` +\n\t\tallocateIf(`ELYSIA_TRACE,`, hasTrace) +\n\t\tallocateIf(`ELYSIA_REQUEST_ID,`, hasTrace) +\n\t\tadapterVariables +\n\t\t`}=data\\n` +\n\t\t`const store=app.singleton.store\\n` +\n\t\t`const decorator=app.singleton.decorator\\n` +\n\t\t`const staticRouter=app.router.static.http\\n` +\n\t\t`const ht=app.router.history\\n` +\n\t\t`const router=app.router.http\\n` +\n\t\t`const trace=app.event.trace?.map(x=>typeof x==='function'?x:x.fn)??[]\\n` +\n\t\t`const notFound=new NotFoundError()\\n` +\n\t\t`const hoc=app.extender.higherOrderFunctions.map(x=>x.fn)\\n`\n\n\tif (app.event.request?.length)\n\t\tfnLiteral += `const onRequest=app.event.request.map(x=>x.fn)\\n`\n\n\tfnLiteral += error404.declare\n\n\tif (app.event.trace?.length)\n\t\tfnLiteral +=\n\t\t\t`const ` +\n\t\t\tapp.event.trace\n\t\t\t\t.map((_, i) => `tr${i}=app.event.trace[${i}].fn`)\n\t\t\t\t.join(',') +\n\t\t\t'\\n'\n\n\tfnLiteral += `${maybeAsync ? 'async ' : ''}function map(${adapter.parameters}){`\n\n\tif (app.event.request?.length) fnLiteral += `let re\\n`\n\n\tfnLiteral += adapter.createContext(app)\n\n\tif (app.event.trace?.length)\n\t\tfnLiteral +=\n\t\t\t`c[ELYSIA_TRACE]=[` +\n\t\t\tapp.event.trace.map((_, i) => `tr${i}(c)`).join(',') +\n\t\t\t`]\\n`\n\n\tconst report = createReport({\n\t\ttrace: app.event.trace,\n\t\taddFn(word) {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tconst reporter = report('request', {\n\t\ttotal: app.event.request?.length\n\t})\n\n\tif (app.event.request?.length) {\n\t\tfnLiteral += `try{`\n\n\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\tconst hook = app.event.request[i]\n\t\t\tconst withReturn = hasReturn(hook)\n\t\t\tconst maybeAsync = isAsync(hook)\n\n\t\t\tconst endUnit = reporter.resolveChild(app.event.request[i].fn.name)\n\n\t\t\tif (withReturn) {\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`re=mapEarlyResponse(` +\n\t\t\t\t\t`${maybeAsync ? 'await ' : ''}onRequest[${i}](c),` +\n\t\t\t\t\t`c.set)\\n`\n\n\t\t\t\tendUnit('re')\n\t\t\t\tfnLiteral += `if(re!==undefined)return re\\n`\n\t\t\t} else {\n\t\t\t\tfnLiteral += `${maybeAsync ? 'await ' : ''}onRequest[${i}](c)\\n`\n\t\t\t\tendUnit()\n\t\t\t}\n\t\t}\n\n\t\tfnLiteral += `}catch(error){return app.handleError(c,error,false)}`\n\t}\n\n\treporter.resolve()\n\n\tfnLiteral += adapter.websocket(app)\n\n\tfnLiteral +=\n\t\t`\\nmap:switch(p){\\n` +\n\t\tswitchMap +\n\t\t`default:break}` +\n\t\tfindDynamicRoute +\n\t\t`}\\n`\n\n\t// @ts-expect-error private property\n\tif (app.extender.higherOrderFunctions.length) {\n\t\tlet handler = 'map'\n\t\t// @ts-expect-error private property\n\t\tfor (let i = 0; i < app.extender.higherOrderFunctions.length; i++)\n\t\t\thandler = `hoc[${i}](${handler},${adapter.parameters})`\n\n\t\tfnLiteral += `return function hocMap(${adapter.parameters}){return ${handler}(${adapter.parameters})}`\n\t} else fnLiteral += `return map`\n\n\tconst handleError = composeErrorHandler(app) as any\n\n\t// @ts-expect-error\n\tapp.handleError = handleError\n\n\treturn Function(\n\t\t'data',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapEarlyResponse: app['~adapter']['handler'].mapEarlyResponse,\n\t\tNotFoundError,\n\t\trandomId,\n\t\thandleError,\n\t\terror,\n\t\tredirect,\n\t\tELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined,\n\t\tELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined,\n\t\t...adapter.inject\n\t})\n}\n\nexport const composeErrorHandler = (app: AnyElysia) => {\n\tconst hooks = app.event\n\tlet fnLiteral = ''\n\n\tconst adapter = app['~adapter'].composeError\n\tconst adapterVariables = adapter.inject\n\t\t? Object.keys(adapter.inject).join(',') + ','\n\t\t: ''\n\n\tconst hasTrace = !!app.event.trace?.length\n\n\tfnLiteral +=\n\t\t`const {` +\n\t\t`app:{` +\n\t\t`event:{` +\n\t\t`error:onErrorContainer,` +\n\t\t`afterResponse:resContainer,` +\n\t\t`mapResponse:_onMapResponse,` +\n\t\t`trace:_trace` +\n\t\t`}` +\n\t\t`},` +\n\t\t`mapResponse,` +\n\t\t`ERROR_CODE,` +\n\t\t`ElysiaCustomStatusResponse,` +\n\t\tallocateIf(`ELYSIA_TRACE,`, hasTrace) +\n\t\tallocateIf(`ELYSIA_REQUEST_ID,`, hasTrace) +\n\t\tadapterVariables +\n\t\t`}=inject\\n`\n\n\tfnLiteral +=\n\t\t`const trace=_trace?.map(x=>typeof x==='function'?x:x.fn)??[]\\n` +\n\t\t`const onMapResponse=[]\\n` +\n\t\t`if(_onMapResponse)for(let i=0;i<_onMapResponse.length;i++)` +\n\t\t`onMapResponse.push(_onMapResponse[i].fn??_onMapResponse[i])\\n` +\n\t\t`delete _onMapResponse\\n` +\n\t\t`const onError=onErrorContainer?.map(x=>x.fn)??[]\\n` +\n\t\t`const res=resContainer?.map(x=>x.fn)??[]\\n` +\n\t\t`return ${\n\t\t\tapp.event.error?.find(isAsync) ||\n\t\t\tapp.event.mapResponse?.find(isAsync)\n\t\t\t\t? 'async '\n\t\t\t\t: ''\n\t\t}function(context,error,skipGlobal){`\n\n\tfnLiteral += ''\n\n\tif (hasTrace) fnLiteral += 'const id=context[ELYSIA_REQUEST_ID]\\n'\n\n\tconst report = createReport({\n\t\tcontext: 'context',\n\t\ttrace: hooks.trace,\n\t\taddFn: (word) => {\n\t\t\tfnLiteral += word\n\t\t}\n\t})\n\n\tfnLiteral +=\n\t\t`const set=context.set\\n` +\n\t\t`let _r\\n` +\n\t\t`if(!context.code)context.code=error.code??error[ERROR_CODE]\\n` +\n\t\t`if(!(context.error instanceof Error))context.error=error\\n` +\n\t\t`if(error instanceof ElysiaCustomStatusResponse){` +\n\t\t`set.status=error.status=error.code\\n` +\n\t\t`error.message=error.response` +\n\t\t`}`\n\n\tif (adapter.declare) fnLiteral += adapter.declare\n\n\tconst saveResponse =\n\t\thasTrace ||\n\t\t!!hooks.afterResponse?.length ||\n\t\t!!hooks.afterResponse?.length\n\t\t\t? 'context.response = '\n\t\t\t: ''\n\n\tif (app.event.error)\n\t\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\t\tconst handler = app.event.error[i]\n\n\t\t\tconst response = `${\n\t\t\t\tisAsync(handler) ? 'await ' : ''\n\t\t\t}onError[${i}](context)\\n`\n\n\t\t\tfnLiteral += 'if(skipGlobal!==true){'\n\n\t\t\tif (hasReturn(handler)) {\n\t\t\t\tfnLiteral +=\n\t\t\t\t\t`_r=${response}\\nif(_r!==undefined){` +\n\t\t\t\t\t`if(_r instanceof Response)return mapResponse(_r,set${adapter.mapResponseContext})\\n` +\n\t\t\t\t\t`if(_r instanceof ElysiaCustomStatusResponse){` +\n\t\t\t\t\t`error.status=error.code\\n` +\n\t\t\t\t\t`error.message = error.response` +\n\t\t\t\t\t`}` +\n\t\t\t\t\t`if(set.status===200||!set.status)set.status=error.status\\n`\n\n\t\t\t\tconst mapResponseReporter = report('mapResponse', {\n\t\t\t\t\ttotal: hooks.mapResponse?.length,\n\t\t\t\t\tname: 'context'\n\t\t\t\t})\n\n\t\t\t\tif (hooks.mapResponse?.length) {\n\t\t\t\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\t\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\t\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\t\t\t\tmapResponse.fn.name\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tfnLiteral +=\n\t\t\t\t\t\t\t`context.response=_r` +\n\t\t\t\t\t\t\t`_r=${isAsyncName(mapResponse) ? 'await ' : ''}onMapResponse[${i}](context)\\n`\n\n\t\t\t\t\t\tendUnit()\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmapResponseReporter.resolve()\n\n\t\t\t\tfnLiteral += `return mapResponse(${saveResponse}_r,set${adapter.mapResponseContext})}`\n\t\t\t} else fnLiteral += response\n\n\t\t\tfnLiteral += '}'\n\t\t}\n\n\tfnLiteral +=\n\t\t`if(error.constructor.name===\"ValidationError\"||error.constructor.name===\"TransformDecodeError\"){` +\n\t\t`if(error.error)error=error.error\\n` +\n\t\t`set.status=error.status??422\\n` +\n\t\tadapter.validationError +\n\t\t`}`\n\n\tfnLiteral += `if(error instanceof Error){` + adapter.unknownError + `}`\n\n\tconst mapResponseReporter = report('mapResponse', {\n\t\ttotal: hooks.mapResponse?.length,\n\t\tname: 'context'\n\t})\n\n\tfnLiteral +=\n\t\t'\\nif(!context.response)context.response=error.message??error\\n'\n\n\tif (hooks.mapResponse?.length) {\n\t\tfnLiteral += 'let mr\\n'\n\n\t\tfor (let i = 0; i < hooks.mapResponse.length; i++) {\n\t\t\tconst mapResponse = hooks.mapResponse[i]\n\n\t\t\tconst endUnit = mapResponseReporter.resolveChild(\n\t\t\t\tmapResponse.fn.name\n\t\t\t)\n\n\t\t\tfnLiteral +=\n\t\t\t\t`if(mr===undefined){` +\n\t\t\t\t`mr=${isAsyncName(mapResponse) ? 'await ' : ''}onMapResponse[${i}](context)\\n` +\n\t\t\t\t`if(mr!==undefined)error=context.response=mr` +\n\t\t\t\t'}'\n\n\t\t\tendUnit()\n\t\t}\n\t}\n\n\tmapResponseReporter.resolve()\n\n\tfnLiteral += `\\nreturn mapResponse(${saveResponse}error,set${adapter.mapResponseContext})}`\n\n\treturn Function(\n\t\t'inject',\n\t\tfnLiteral\n\t)({\n\t\tapp,\n\t\tmapResponse: app['~adapter'].handler.mapResponse,\n\t\tERROR_CODE,\n\t\tElysiaCustomStatusResponse,\n\t\tELYSIA_TRACE: hasTrace ? ELYSIA_TRACE : undefined,\n\t\tELYSIA_REQUEST_ID: hasTrace ? ELYSIA_REQUEST_ID : undefined,\n\t\t...adapter.inject\n\t})\n}\n",
    "/**\nFork of fast-querystring\n\noriginate\n@from https://github.com/anonrig/fast-querystring/tree/main\n\nmodified\n@from https://discord.com/channels/876711213126520882/1111136889743888455/1263902371801595979\n\nCopyright (c) 2022 Yagiz Nizipli\n\nPermission is hereby granted, free of charge, to any\nperson obtaining a copy of this software and associated\ndocumentation files (the \"Software\"), to deal in the\nSoftware without restriction, including without\nlimitation the rights to use, copy, modify, merge,\npublish, distribute, sublicense, and/or sell copies of\nthe Software, and to permit persons to whom the Software\nis furnished to do so, subject to the following\nconditions:\n\nThe above copyright notice and this permission notice\nshall be included in all copies or substantial portions\nof the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\nANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\nTO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\nSHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\nIN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.\n*/\n\nimport { decode as fastDecode } from './deuri'\n\nconst plusRegex = /\\+/g\n\n// Parse query without array\nexport function parseQueryFromURL(input: string) {\n\tconst result = <Record<string, string>>{}\n\n\tif (typeof input !== 'string') return result\n\n\tlet key = ''\n\tlet value = ''\n\tlet startingIndex = -1\n\tlet equalityIndex = -1\n\tlet flags = 0\n\n\tconst l = input.length\n\n\tfor (let i = 0; i < l; i++) {\n\t\tswitch (input.charCodeAt(i)) {\n\t\t\tcase 38: // '&'\n\t\t\t\tconst hasBothKeyValuePair = equalityIndex > startingIndex\n\t\t\t\tif (!hasBothKeyValuePair) equalityIndex = i\n\n\t\t\t\tkey = input.slice(startingIndex + 1, equalityIndex)\n\n\t\t\t\tif (hasBothKeyValuePair || key.length > 0) {\n\t\t\t\t\tif (flags & 0b0000_0001) key = key.replace(plusRegex, ' ')\n\t\t\t\t\tif (flags & 0b0000_0010) key = fastDecode(key) || key\n\n\t\t\t\t\tif (!result[key]) {\n\t\t\t\t\t\tif (hasBothKeyValuePair) {\n\t\t\t\t\t\t\tvalue = input.slice(equalityIndex + 1, i)\n\n\t\t\t\t\t\t\tif (flags & 0b0000_0100)\n\t\t\t\t\t\t\t\tvalue = value.replace(plusRegex, ' ')\n\t\t\t\t\t\t\tif (flags & 0b0000_1000)\n\t\t\t\t\t\t\t\tvalue = fastDecode(value) || value\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresult[key] = value\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tkey = ''\n\t\t\t\tvalue = ''\n\t\t\t\tstartingIndex = i\n\t\t\t\tequalityIndex = i\n\t\t\t\tflags = 0\n\t\t\t\tbreak\n\n\t\t\tcase 61: // '='\n\t\t\t\tif (equalityIndex <= startingIndex) equalityIndex = i\n\t\t\t\telse flags |= 0b0000_1000\n\t\t\t\tbreak\n\n\t\t\tcase 43: // '+'\n\t\t\t\tif (equalityIndex > startingIndex) flags |= 0b0000_0100\n\t\t\t\telse flags |= 0b0000_0001\n\t\t\t\tbreak\n\n\t\t\tcase 37: // '%'\n\t\t\t\tif (equalityIndex > startingIndex) flags |= 0b0000_1000\n\t\t\t\telse flags |= 0b0000_0010\n\t\t\t\tbreak\n\t\t}\n\t}\n\n\tif (startingIndex < l) {\n\t\tconst hasBothKeyValuePair = equalityIndex > startingIndex\n\t\tkey = input.slice(\n\t\t\tstartingIndex + 1,\n\t\t\thasBothKeyValuePair ? equalityIndex : l\n\t\t)\n\n\t\tif (hasBothKeyValuePair || key.length > 0) {\n\t\t\tif (flags & 0b0000_0001) key = key.replace(plusRegex, ' ')\n\t\t\tif (flags & 0b0000_0010) key = fastDecode(key) || key\n\n\t\t\tif (!result[key]) {\n\t\t\t\tif (hasBothKeyValuePair) {\n\t\t\t\t\tvalue = input.slice(equalityIndex + 1, l)\n\n\t\t\t\t\tif (flags & 0b0000_0100)\n\t\t\t\t\t\tvalue = value.replace(plusRegex, ' ')\n\t\t\t\t\tif (flags & 0b0000_1000) value = fastDecode(value) || value\n\t\t\t\t}\n\n\t\t\t\tresult[key] = value\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result\n}\n\n/**\n * @callback parse\n * @param {string} input\n */\nexport const parseQuery = (input: string) => {\n\tconst result: Record<string, string[]> = {}\n\n\tif (typeof input !== 'string') return result\n\n\tconst inputLength = input.length\n\tlet key = ''\n\tlet value = ''\n\tlet startingIndex = -1\n\tlet equalityIndex = -1\n\tlet shouldDecodeKey = false\n\tlet shouldDecodeValue = false\n\tlet keyHasPlus = false\n\tlet valueHasPlus = false\n\tlet hasBothKeyValuePair = false\n\tlet c = 0\n\n\t// Have a boundary of input.length + 1 to access last pair inside the loop.\n\tfor (let i = 0; i < inputLength + 1; i++) {\n\t\tif (i !== inputLength) c = input.charCodeAt(i)\n\t\telse c = 38\n\n\t\t// Handle '&' and end of line to pass the current values to result\n\t\tswitch (c) {\n\t\t\tcase 38: {\n\t\t\t\thasBothKeyValuePair = equalityIndex > startingIndex\n\n\t\t\t\t// Optimization: Reuse equality index to store the end of key\n\t\t\t\tif (!hasBothKeyValuePair) equalityIndex = i\n\n\t\t\t\tkey = input.slice(startingIndex + 1, equalityIndex)\n\n\t\t\t\t// Add key/value pair only if the range size is greater than 1; a.k.a. contains at least \"=\"\n\t\t\t\tif (hasBothKeyValuePair || key.length > 0) {\n\t\t\t\t\t// Optimization: Replace '+' with space\n\t\t\t\t\tif (keyHasPlus) key = key.replace(plusRegex, ' ')\n\n\t\t\t\t\t// Optimization: Do not decode if it's not necessary.\n\t\t\t\t\tif (shouldDecodeKey) key = fastDecode(key) || key\n\n\t\t\t\t\tif (hasBothKeyValuePair) {\n\t\t\t\t\t\tvalue = input.slice(equalityIndex + 1, i)\n\n\t\t\t\t\t\tif (valueHasPlus) value = value.replace(plusRegex, ' ')\n\n\t\t\t\t\t\tif (shouldDecodeValue)\n\t\t\t\t\t\t\tvalue = fastDecode(value) || value\n\t\t\t\t\t}\n\n\t\t\t\t\tconst currentValue = result[key]\n\n\t\t\t\t\tif (currentValue === undefined)\n\t\t\t\t\t\t// @ts-ignore - As current value is undefined, we can safely assign it\n\t\t\t\t\t\tresult[key] = value\n\t\t\t\t\telse {\n\t\t\t\t\t\t// @ts-ignore - Optimization: value.pop is faster than Array.isArray(value)\n\t\t\t\t\t\tif (currentValue.pop) currentValue.push(value)\n\t\t\t\t\t\t// @ts-ignore - As current value is a string, convert it to an array\n\t\t\t\t\t\telse result[key] = [currentValue, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Reset reading key value pairs\n\t\t\t\tvalue = ''\n\t\t\t\tstartingIndex = i\n\t\t\t\tequalityIndex = i\n\t\t\t\tshouldDecodeKey = false\n\t\t\t\tshouldDecodeValue = false\n\t\t\t\tkeyHasPlus = false\n\t\t\t\tvalueHasPlus = false\n\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t\t// Check '='\n\t\t\tcase 61:\n\t\t\t\tif (equalityIndex <= startingIndex) equalityIndex = i\n\t\t\t\t// If '=' character occurs again, we should decode the input.\n\t\t\t\telse shouldDecodeValue = true\n\n\t\t\t\tbreak\n\n\t\t\t// Check '+', and remember to replace it with empty space.\n\t\t\tcase 43:\n\t\t\t\tif (equalityIndex > startingIndex) valueHasPlus = true\n\t\t\t\telse keyHasPlus = true\n\n\t\t\t\tbreak\n\n\t\t\t// Check '%' character for encoding\n\t\t\tcase 37:\n\t\t\t\tif (equalityIndex > startingIndex) shouldDecodeValue = true\n\t\t\t\telse shouldDecodeKey = true\n\n\t\t\t\tbreak\n\t\t}\n\t}\n\n\treturn result\n}\n",
    "import { ELYSIA_REQUEST_ID } from './utils'\n\nimport type { Context } from './context'\nimport type { Prettify, RouteSchema, SingletonBase } from './types'\n\nexport type TraceEvent =\n\t| 'request'\n\t| 'parse'\n\t| 'transform'\n\t| 'beforeHandle'\n\t| 'handle'\n\t| 'afterHandle'\n\t| 'mapResponse'\n\t| 'afterResponse'\n\t| 'error'\n\nexport type TraceStream = {\n\tid: number\n\tevent: TraceEvent\n\ttype: 'begin' | 'end'\n\tbegin: number\n\tname?: string\n\ttotal?: number\n}\n\ntype TraceEndDetail = {\n\t/**\n\t * Timestamp of a function after it's executed since the server start\n\t */\n\tend: TraceProcess<'end'>\n\t/**\n\t * Error that was thrown in the lifecycle\n\t */\n\terror: Error | null\n\t/**\n\t * Elapsed time of the lifecycle\n\t */\n\telapsed: number\n}\n\nexport type TraceProcess<\n\tType extends 'begin' | 'end' = 'begin' | 'end',\n\tWithChildren extends boolean = true\n> = Type extends 'begin'\n\t? Prettify<\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * Function name\n\t\t\t\t */\n\t\t\t\tname: string\n\t\t\t\t/**\n\t\t\t\t * Timestamp of a function is called since the server start\n\t\t\t\t */\n\t\t\t\tbegin: number\n\t\t\t\t/**\n\t\t\t\t * Timestamp of a function after it's executed since the server start\n\t\t\t\t */\n\t\t\t\tend: Promise<number>\n\t\t\t\t/**\n\t\t\t\t * Error that was thrown in the lifecycle\n\t\t\t\t */\n\t\t\t\terror: Promise<Error | null>\n\t\t\t\t/**\n\t\t\t\t * Listener to intercept the end of the lifecycle\n\t\t\t\t *\n\t\t\t\t * If you want to mutate the context, you must do it in this function\n\t\t\t\t * as there's a lock mechanism to ensure the context is mutate successfully\n\t\t\t\t */\n\t\t\t\tonStop(\n\t\t\t\t\t/**\n\t\t\t\t\t * A callback function that will be called when the function ends\n\t\t\t\t\t *\n\t\t\t\t\t * If you want to mutate the context, you must do it in this function\n\t\t\t\t\t * as there's a lock mechanism to ensure the context is mutate successfully\n\t\t\t\t\t */\n\t\t\t\t\tcallback?: (detail: TraceEndDetail) => unknown\n\t\t\t\t): Promise<void>\n\t\t\t} & (WithChildren extends true\n\t\t\t\t? {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * total number of lifecycle's children and\n\t\t\t\t\t\t * total number of `onEvent` will be called\n\t\t\t\t\t\t * if there were no early exists or error thrown\n\t\t\t\t\t\t */\n\t\t\t\t\t\ttotal: number\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Listener to intercept each child lifecycle\n\t\t\t\t\t\t */\n\t\t\t\t\t\tonEvent(\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * Callback function that will be called for when each child start\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tcallback?: (\n\t\t\t\t\t\t\t\tprocess: TraceProcess<'begin', false>\n\t\t\t\t\t\t\t) => unknown\n\t\t\t\t\t\t): Promise<void>\n\t\t\t\t\t}\n\t\t\t\t: {\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * Index of the child event\n\t\t\t\t\t\t */\n\t\t\t\t\t\tindex: number\n\t\t\t\t\t})\n\t\t>\n\t: number\n\nexport type TraceListener = (\n\tcallback?: (process: TraceProcess<'begin'>) => unknown\n) => Promise<TraceProcess<'begin'>>\n\nexport type TraceHandler<\n\tin out Route extends RouteSchema = {},\n\tin out Singleton extends SingletonBase = {\n\t\tdecorator: {}\n\t\tstore: {}\n\t\tderive: {}\n\t\tresolve: {}\n\t}\n> = {\n\t(\n\t\tlifecycle: Prettify<\n\t\t\t{\n\t\t\t\tid: number\n\t\t\t\tcontext: Context<Route, Singleton>\n\t\t\t\tset: Context['set']\n\t\t\t\ttime: number\n\t\t\t\tstore: Singleton['store']\n\t\t\t} & {\n\t\t\t\t[x in `on${Capitalize<TraceEvent>}`]: TraceListener\n\t\t\t}\n\t\t>\n\t): unknown\n}\n\nexport const ELYSIA_TRACE = Symbol('ElysiaTrace')\n\nconst createProcess = () => {\n\tconst { promise, resolve } = Promise.withResolvers<TraceProcess>()\n\tconst { promise: end, resolve: resolveEnd } =\n\t\tPromise.withResolvers<number>()\n\tconst { promise: error, resolve: resolveError } =\n\t\tPromise.withResolvers<Error | null>()\n\n\tconst callbacks = <Function[]>[]\n\tconst callbacksEnd = <Function[]>[]\n\n\treturn [\n\t\t(callback?: Function) => {\n\t\t\tif (callback) callbacks.push(callback)\n\n\t\t\treturn promise\n\t\t},\n\t\t(process: TraceStream) => {\n\t\t\tconst processes = <((callback?: Function) => Promise<void>)[]>[]\n\t\t\tconst resolvers = <((process: TraceStream) => () => void)[]>[]\n\n\t\t\t// When error is return but not thrown\n\t\t\tlet groupError: Error | null = null\n\n\t\t\tfor (let i = 0; i < (process.total ?? 0); i++) {\n\t\t\t\tconst { promise, resolve } = Promise.withResolvers<void>()\n\t\t\t\tconst { promise: end, resolve: resolveEnd } =\n\t\t\t\t\tPromise.withResolvers<number>()\n\t\t\t\tconst { promise: error, resolve: resolveError } =\n\t\t\t\t\tPromise.withResolvers<Error | null>()\n\n\t\t\t\tconst callbacks = <Function[]>[]\n\t\t\t\tconst callbacksEnd = <Function[]>[]\n\n\t\t\t\tprocesses.push((callback?: Function) => {\n\t\t\t\t\tif (callback) callbacks.push(callback)\n\n\t\t\t\t\treturn promise\n\t\t\t\t})\n\n\t\t\t\tresolvers.push((process: TraceStream) => {\n\t\t\t\t\tconst result = {\n\t\t\t\t\t\t...process,\n\t\t\t\t\t\tend,\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tindex: i,\n\t\t\t\t\t\tonStop(callback?: Function) {\n\t\t\t\t\t\t\tif (callback) callbacksEnd.push(callback)\n\n\t\t\t\t\t\t\treturn end\n\t\t\t\t\t\t}\n\t\t\t\t\t} as any\n\n\t\t\t\t\tresolve(result)\n\t\t\t\t\tfor (let i = 0; i < callbacks.length; i++)\n\t\t\t\t\t\tcallbacks[i](result)\n\n\t\t\t\t\treturn (error: Error | null = null) => {\n\t\t\t\t\t\tconst end = performance.now()\n\n\t\t\t\t\t\t// Catch return error\n\t\t\t\t\t\tif (error) groupError = error\n\n\t\t\t\t\t\tconst detail = {\n\t\t\t\t\t\t\tend,\n\t\t\t\t\t\t\terror,\n\t\t\t\t\t\t\tget elapsed() {\n\t\t\t\t\t\t\t\treturn end - process.begin\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (let i = 0; i < callbacksEnd.length; i++)\n\t\t\t\t\t\t\tcallbacksEnd[i](detail)\n\n\t\t\t\t\t\tresolveEnd(end)\n\t\t\t\t\t\tresolveError(error)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tconst result = {\n\t\t\t\t...process,\n\t\t\t\tend,\n\t\t\t\terror,\n\t\t\t\tonEvent(callback?: Function) {\n\t\t\t\t\tfor (let i = 0; i < processes.length; i++)\n\t\t\t\t\t\tprocesses[i](callback)\n\t\t\t\t},\n\t\t\t\tonStop(callback?: Function) {\n\t\t\t\t\tif (callback) callbacksEnd.push(callback)\n\n\t\t\t\t\treturn end\n\t\t\t\t}\n\t\t\t} as any\n\n\t\t\tresolve(result)\n\t\t\tfor (let i = 0; i < callbacks.length; i++) callbacks[i](result)\n\n\t\t\treturn {\n\t\t\t\tresolveChild: resolvers,\n\t\t\t\tresolve(error: Error | null = null) {\n\t\t\t\t\tconst end = performance.now()\n\n\t\t\t\t\t// If error is return, parent group will not catch an error\n\t\t\t\t\t// but the child group will catch the error\n\t\t\t\t\tif (!error && groupError) error = groupError\n\n\t\t\t\t\tconst detail = {\n\t\t\t\t\t\tend,\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tget elapsed() {\n\t\t\t\t\t\t\treturn end - process.begin\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (let i = 0; i < callbacksEnd.length; i++)\n\t\t\t\t\t\tcallbacksEnd[i](detail)\n\n\t\t\t\t\tresolveEnd(end)\n\t\t\t\t\tresolveError(error)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t] as const\n}\n\nexport const createTracer = (traceListener: TraceHandler) => {\n\treturn (context: Context) => {\n\t\tconst [onRequest, resolveRequest] = createProcess()\n\t\tconst [onParse, resolveParse] = createProcess()\n\t\tconst [onTransform, resolveTransform] = createProcess()\n\t\tconst [onBeforeHandle, resolveBeforeHandle] = createProcess()\n\t\tconst [onHandle, resolveHandle] = createProcess()\n\t\tconst [onAfterHandle, resolveAfterHandle] = createProcess()\n\t\tconst [onError, resolveError] = createProcess()\n\t\tconst [onMapResponse, resolveMapResponse] = createProcess()\n\t\tconst [onAfterResponse, resolveAfterResponse] = createProcess()\n\n\t\ttraceListener({\n\t\t\t// @ts-ignore\n\t\t\tid: context[ELYSIA_REQUEST_ID],\n\t\t\tcontext,\n\t\t\tset: context.set,\n\t\t\t// @ts-ignore\n\t\t\tonRequest,\n\t\t\t// @ts-ignore\n\t\t\tonParse,\n\t\t\t// @ts-ignore\n\t\t\tonTransform,\n\t\t\t// @ts-ignore\n\t\t\tonBeforeHandle,\n\t\t\t// @ts-ignore\n\t\t\tonHandle,\n\t\t\t// @ts-ignore\n\t\t\tonAfterHandle,\n\t\t\t// @ts-ignore\n\t\t\tonMapResponse,\n\t\t\t// @ts-ignore\n\t\t\tonAfterResponse,\n\t\t\t// @ts-ignore\n\t\t\tonError\n\t\t})\n\n\t\t// ? This is pass to compiler\n\t\treturn {\n\t\t\trequest: resolveRequest,\n\t\t\tparse: resolveParse,\n\t\t\ttransform: resolveTransform,\n\t\t\tbeforeHandle: resolveBeforeHandle,\n\t\t\thandle: resolveHandle,\n\t\t\tafterHandle: resolveAfterHandle,\n\t\t\terror: resolveError,\n\t\t\tmapResponse: resolveMapResponse,\n\t\t\tafterResponse: resolveAfterResponse\n\t\t}\n\t}\n}\n",
    "import type { AnyElysia } from '.'\n\nimport {\n\tElysiaCustomStatusResponse,\n\tElysiaErrors,\n\terror,\n\tNotFoundError,\n\tValidationError\n} from './error'\n\nimport type { Context } from './context'\n\nimport { parseQuery } from './fast-querystring'\n\nimport { redirect, signCookie, StatusMap } from './utils'\nimport { parseCookie } from './cookies'\n\nimport type { Handler, LifeCycleStore, SchemaValidator } from './types'\nimport { TransformDecodeError } from '@sinclair/typebox/value'\nimport { TypeCheck } from './type-system'\n\n// JIT Handler\nexport type DynamicHandler = {\n\thandle: unknown | Handler<any, any>\n\tcontent?: string\n\thooks: Partial<LifeCycleStore>\n\tvalidator?: SchemaValidator\n\troute: string\n}\n\nconst injectDefaultValues = (\n\ttypeChecker: TypeCheck<any>,\n\tobj: Record<string, any>\n) => {\n\tfor (const [key, keySchema] of Object.entries(\n\t\t// @ts-expect-error private\n\t\ttypeChecker.schema.properties\n\t)) {\n\t\t// @ts-expect-error private\n\t\tobj[key] ??= keySchema.default\n\t}\n}\n\nexport const createDynamicHandler = (app: AnyElysia) => {\n\tconst { mapResponse, mapEarlyResponse } = app['~adapter'].handler\n\n\treturn async (request: Request): Promise<Response> => {\n\t\tconst url = request.url,\n\t\t\ts = url.indexOf('/', 11),\n\t\t\tqi = url.indexOf('?', s + 1),\n\t\t\tpath = qi === -1 ? url.substring(s) : url.substring(s, qi)\n\n\t\tconst set: Context['set'] = {\n\t\t\tcookie: {},\n\t\t\tstatus: 200,\n\t\t\theaders: {}\n\t\t}\n\n\t\tconst context = Object.assign(\n\t\t\t{},\n\t\t\t// @ts-expect-error\n\t\t\tapp.singleton.decorator,\n\t\t\t{\n\t\t\t\tset,\n\t\t\t\t// @ts-expect-error\n\t\t\t\tstore: app.singleton.store,\n\t\t\t\trequest,\n\t\t\t\tpath,\n\t\t\t\tqi,\n\t\t\t\terror,\n\t\t\t\tredirect\n\t\t\t}\n\t\t) as unknown as Context & {\n\t\t\tresponse: unknown\n\t\t}\n\n\t\ttry {\n\t\t\tif (app.event.request)\n\t\t\t\tfor (let i = 0; i < app.event.request.length; i++) {\n\t\t\t\t\tconst onRequest = app.event.request[i].fn\n\t\t\t\t\tlet response = onRequest(context as any)\n\t\t\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\t\t\tresponse = mapEarlyResponse(response, set)\n\t\t\t\t\tif (response) return (context.response = response)\n\t\t\t\t}\n\n\t\t\tconst handler =\n\t\t\t\tapp.router.dynamic.find(request.method, path) ??\n\t\t\t\tapp.router.dynamic.find('ALL', path)\n\n\t\t\tif (!handler) throw new NotFoundError()\n\n\t\t\tconst { handle, hooks, validator, content, route } = handler.store\n\n\t\t\tlet body: string | Record<string, any> | undefined\n\t\t\tif (request.method !== 'GET' && request.method !== 'HEAD') {\n\t\t\t\tif (content) {\n\t\t\t\t\tswitch (content) {\n\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\tbody = (await request.json()) as any\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\tbody = await request.text()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\tbody = parseQuery(await request.text())\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\tbody = await request.arrayBuffer()\n\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\tbody = {}\n\n\t\t\t\t\t\t\tconst form = await request.formData()\n\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\tif (body[key]) continue\n\n\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\tif (value.length === 1) body[key] = value[0]\n\t\t\t\t\t\t\t\telse body[key] = value\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet contentType = request.headers.get('content-type')\n\n\t\t\t\t\tif (contentType) {\n\t\t\t\t\t\tconst index = contentType.indexOf(';')\n\t\t\t\t\t\tif (index !== -1)\n\t\t\t\t\t\t\tcontentType = contentType.slice(0, index)\n\n\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\tcontext.contentType = contentType\n\n\t\t\t\t\t\tif (hooks.parse)\n\t\t\t\t\t\t\tfor (let i = 0; i < hooks.parse.length; i++) {\n\t\t\t\t\t\t\t\tconst hook = hooks.parse[i].fn\n\t\t\t\t\t\t\t\tlet temp = hook(context as any, contentType)\n\t\t\t\t\t\t\t\tif (temp instanceof Promise) temp = await temp\n\n\t\t\t\t\t\t\t\tif (temp) {\n\t\t\t\t\t\t\t\t\tbody = temp\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\tdelete context.contentType\n\n\t\t\t\t\t\t// body might be empty string thus can't use !body\n\t\t\t\t\t\tif (body === undefined) {\n\t\t\t\t\t\t\tswitch (contentType) {\n\t\t\t\t\t\t\t\tcase 'application/json':\n\t\t\t\t\t\t\t\t\tbody = (await request.json()) as any\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'text/plain':\n\t\t\t\t\t\t\t\t\tbody = await request.text()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'application/x-www-form-urlencoded':\n\t\t\t\t\t\t\t\t\tbody = parseQuery(await request.text())\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'application/octet-stream':\n\t\t\t\t\t\t\t\t\tbody = await request.arrayBuffer()\n\t\t\t\t\t\t\t\t\tbreak\n\n\t\t\t\t\t\t\t\tcase 'multipart/form-data':\n\t\t\t\t\t\t\t\t\tbody = {}\n\n\t\t\t\t\t\t\t\t\tconst form = await request.formData()\n\t\t\t\t\t\t\t\t\tfor (const key of form.keys()) {\n\t\t\t\t\t\t\t\t\t\tif (body[key]) continue\n\n\t\t\t\t\t\t\t\t\t\tconst value = form.getAll(key)\n\t\t\t\t\t\t\t\t\t\tif (value.length === 1)\n\t\t\t\t\t\t\t\t\t\t\tbody[key] = value[0]\n\t\t\t\t\t\t\t\t\t\telse body[key] = value\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontext.route = route\n\t\t\tcontext.body = body\n\t\t\tcontext.params = handler?.params || undefined\n\n\t\t\t// @ts-ignore\n\t\t\tcontext.query = qi === -1 ? {} : parseQuery(url.substring(qi + 1))\n\n\t\t\tcontext.headers = {}\n\t\t\tfor (const [key, value] of request.headers.entries())\n\t\t\t\tcontext.headers[key] = value\n\n\t\t\tconst cookieMeta = Object.assign(\n\t\t\t\t{},\n\t\t\t\tapp.config?.cookie,\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvalidator?.cookie?.config\n\t\t\t) as {\n\t\t\t\tsecrets?: string | string[]\n\t\t\t\tsign: string[] | true\n\t\t\t\tproperties: { [x: string]: Object }\n\t\t\t}\n\n\t\t\tconst cookieHeaderValue = request.headers.get('cookie')\n\n\t\t\tcontext.cookie = (await parseCookie(\n\t\t\t\tcontext.set,\n\t\t\t\tcookieHeaderValue,\n\t\t\t\tcookieMeta\n\t\t\t\t\t? {\n\t\t\t\t\t\t\tsecrets:\n\t\t\t\t\t\t\t\tcookieMeta.secrets !== undefined\n\t\t\t\t\t\t\t\t\t? typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t\t\t\t\t? cookieMeta.secrets\n\t\t\t\t\t\t\t\t\t\t: cookieMeta.secrets.join(',')\n\t\t\t\t\t\t\t\t\t: undefined,\n\t\t\t\t\t\t\tsign:\n\t\t\t\t\t\t\t\tcookieMeta.sign === true\n\t\t\t\t\t\t\t\t\t? true\n\t\t\t\t\t\t\t\t\t: cookieMeta.sign !== undefined\n\t\t\t\t\t\t\t\t\t\t? typeof cookieMeta.sign === 'string'\n\t\t\t\t\t\t\t\t\t\t\t? cookieMeta.sign\n\t\t\t\t\t\t\t\t\t\t\t: cookieMeta.sign.join(',')\n\t\t\t\t\t\t\t\t\t\t: undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t: undefined\n\t\t\t)) as any\n\n\t\t\tconst headerValidator = validator?.createHeaders?.()\n\t\t\tif (headerValidator)\n\t\t\t\tinjectDefaultValues(headerValidator, context.headers)\n\n\t\t\tconst paramsValidator = validator?.createParams?.()\n\t\t\tif (paramsValidator)\n\t\t\t\tinjectDefaultValues(paramsValidator, context.params)\n\n\t\t\tconst queryValidator = validator?.createQuery?.()\n\t\t\tif (queryValidator)\n\t\t\t\tinjectDefaultValues(queryValidator, context.query)\n\n\t\t\tif (hooks.transform)\n\t\t\t\tfor (let i = 0; i < hooks.transform.length; i++) {\n\t\t\t\t\tconst hook = hooks.transform[i]\n\t\t\t\t\tconst operation = hook.fn(context)\n\n\t\t\t\t\tif (hook.subType === 'derive') {\n\t\t\t\t\t\tif (operation instanceof Promise)\n\t\t\t\t\t\t\tObject.assign(context, await operation)\n\t\t\t\t\t\telse Object.assign(context, operation)\n\t\t\t\t\t} else if (operation instanceof Promise) await operation\n\t\t\t\t}\n\n\t\t\tif (validator) {\n\t\t\t\tif (headerValidator) {\n\t\t\t\t\tconst _header = structuredClone(context.headers)\n\t\t\t\t\tfor (const [key, value] of request.headers)\n\t\t\t\t\t\t_header[key] = value\n\n\t\t\t\t\tif (validator.headers!.Check(_header) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'header',\n\t\t\t\t\t\t\tvalidator.headers!,\n\t\t\t\t\t\t\t_header\n\t\t\t\t\t\t)\n\t\t\t\t} else if (validator.headers?.Decode)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tcontext.headers = validator.headers.Decode(context.headers)\n\n\t\t\t\tif (paramsValidator?.Check(context.params) === false) {\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'params',\n\t\t\t\t\t\tvalidator.params!,\n\t\t\t\t\t\tcontext.params\n\t\t\t\t\t)\n\t\t\t\t} else if (validator.params?.Decode)\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tcontext.params = validator.params.Decode(context.params)\n\n\t\t\t\tif (queryValidator?.Check(context.query) === false)\n\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t'query',\n\t\t\t\t\t\tvalidator.query!,\n\t\t\t\t\t\tcontext.query\n\t\t\t\t\t)\n\t\t\t\telse if (validator.query?.Decode)\n\t\t\t\t\tcontext.query = validator.query.Decode(context.query) as any\n\n\t\t\t\tif (validator.createCookie?.()) {\n\t\t\t\t\tlet cookieValue: Record<string, unknown> = {}\n\t\t\t\t\tfor (const [key, value] of Object.entries(context.cookie))\n\t\t\t\t\t\tcookieValue[key] = value.value\n\n\t\t\t\t\tif (validator.cookie!.Check(cookieValue) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'cookie',\n\t\t\t\t\t\t\tvalidator.cookie!,\n\t\t\t\t\t\t\tcookieValue\n\t\t\t\t\t\t)\n\t\t\t\t\telse if (validator.cookie?.Decode)\n\t\t\t\t\t\tcookieValue = validator.cookie.Decode(\n\t\t\t\t\t\t\tcookieValue\n\t\t\t\t\t\t) as any\n\t\t\t\t}\n\n\t\t\t\tif (validator.createBody?.()?.Check(body) === false)\n\t\t\t\t\tthrow new ValidationError('body', validator.body!, body)\n\t\t\t\telse if (validator.body?.Decode)\n\t\t\t\t\tcontext.body = validator.body.Decode(body) as any\n\t\t\t}\n\n\t\t\tif (hooks.beforeHandle)\n\t\t\t\tfor (let i = 0; i < hooks.beforeHandle.length; i++) {\n\t\t\t\t\tconst hook = hooks.beforeHandle[i]\n\t\t\t\t\tlet response = hook.fn(context)\n\n\t\t\t\t\tif (hook.subType === 'resolve') {\n\t\t\t\t\t\tif (response instanceof ElysiaCustomStatusResponse) {\n\t\t\t\t\t\t\tconst result = mapEarlyResponse(\n\t\t\t\t\t\t\t\tresponse,\n\t\t\t\t\t\t\t\tcontext.set\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\tif (result)\n\t\t\t\t\t\t\t\treturn (context.response = result) as Response\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (response instanceof Promise)\n\t\t\t\t\t\t\tObject.assign(context, await response)\n\t\t\t\t\t\telse Object.assign(context, response)\n\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t} else if (response instanceof Promise)\n\t\t\t\t\t\tresponse = await response\n\n\t\t\t\t\t// `false` is a falsey value, check for undefined instead\n\t\t\t\t\tif (response !== undefined) {\n\t\t\t\t\t\t;(\n\t\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t).response = response\n\n\t\t\t\t\t\tif (hooks.afterHandle)\n\t\t\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\t\t\tlet newResponse = hooks.afterHandle[i].fn(\n\t\t\t\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\tif (newResponse instanceof Promise)\n\t\t\t\t\t\t\t\t\tnewResponse = await newResponse\n\n\t\t\t\t\t\t\t\tif (newResponse) response = newResponse\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst result = mapEarlyResponse(response, context.set)\n\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\tif (result) return (context.response = result)\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tlet response =\n\t\t\t\ttypeof handle === 'function' ? handle(context) : handle\n\t\t\tif (response instanceof Promise) response = await response\n\n\t\t\tif (hooks.afterHandle)\n\t\t\t\tif (!hooks.afterHandle.length) {\n\t\t\t\t\tconst status =\n\t\t\t\t\t\tresponse instanceof ElysiaCustomStatusResponse\n\t\t\t\t\t\t\t? response.code\n\t\t\t\t\t\t\t: set.status\n\t\t\t\t\t\t\t\t? typeof set.status === 'string'\n\t\t\t\t\t\t\t\t\t? StatusMap[set.status]\n\t\t\t\t\t\t\t\t\t: set.status\n\t\t\t\t\t\t\t\t: 200\n\n\t\t\t\t\tconst responseValidator =\n\t\t\t\t\t\tvalidator?.createResponse?.()?.[status]\n\n\t\t\t\t\tif (responseValidator?.Check(response) === false)\n\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t'response',\n\t\t\t\t\t\t\tresponseValidator,\n\t\t\t\t\t\t\tresponse\n\t\t\t\t\t\t)\n\t\t\t\t\telse if (responseValidator?.Decode)\n\t\t\t\t\t\tresponse = responseValidator.Decode(response)\n\t\t\t\t} else {\n\t\t\t\t\t;(\n\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t}\n\t\t\t\t\t).response = response\n\n\t\t\t\t\tfor (let i = 0; i < hooks.afterHandle.length; i++) {\n\t\t\t\t\t\tlet newResponse = hooks.afterHandle[i].fn(\n\t\t\t\t\t\t\tcontext as Context & {\n\t\t\t\t\t\t\t\tresponse: unknown\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t)\n\t\t\t\t\t\tif (newResponse instanceof Promise)\n\t\t\t\t\t\t\tnewResponse = await newResponse\n\n\t\t\t\t\t\tconst result = mapEarlyResponse(\n\t\t\t\t\t\t\tnewResponse,\n\t\t\t\t\t\t\tcontext.set\n\t\t\t\t\t\t)\n\t\t\t\t\t\tif (result !== undefined) {\n\t\t\t\t\t\t\tconst responseValidator =\n\t\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\t\tvalidator?.response?.[result.status]\n\n\t\t\t\t\t\t\tif (responseValidator?.Check(result) === false)\n\t\t\t\t\t\t\t\tthrow new ValidationError(\n\t\t\t\t\t\t\t\t\t'response',\n\t\t\t\t\t\t\t\t\tresponseValidator,\n\t\t\t\t\t\t\t\t\tresult\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\telse if (responseValidator?.Decode)\n\t\t\t\t\t\t\t\tresponse = responseValidator.Decode(response)\n\n\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\treturn (context.response = result)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tif (context.set.cookie && cookieMeta?.sign) {\n\t\t\t\tconst secret = !cookieMeta.secrets\n\t\t\t\t\t? undefined\n\t\t\t\t\t: typeof cookieMeta.secrets === 'string'\n\t\t\t\t\t\t? cookieMeta.secrets\n\t\t\t\t\t\t: cookieMeta.secrets[0]\n\n\t\t\t\tif (cookieMeta.sign === true)\n\t\t\t\t\tfor (const [key, cookie] of Object.entries(\n\t\t\t\t\t\tcontext.set.cookie\n\t\t\t\t\t))\n\t\t\t\t\t\tcontext.set.cookie[key].value = await signCookie(\n\t\t\t\t\t\t\tcookie.value as any,\n\t\t\t\t\t\t\t'${secret}'\n\t\t\t\t\t\t)\n\t\t\t\telse {\n\t\t\t\t\t// @ts-expect-error private\n\t\t\t\t\tconst properties = validator?.cookie?.schema?.properties\n\n\t\t\t\t\tfor (const name of cookieMeta.sign) {\n\t\t\t\t\t\tif (!(name in properties)) continue\n\n\t\t\t\t\t\tif (context.set.cookie[name]?.value) {\n\t\t\t\t\t\t\tcontext.set.cookie[name].value = await signCookie(\n\t\t\t\t\t\t\t\tcontext.set.cookie[name].value as any,\n\t\t\t\t\t\t\t\tsecret as any\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// @ts-expect-error\n\t\t\treturn mapResponse((context.response = response), context.set)\n\t\t} catch (error) {\n\t\t\tconst reportedError =\n\t\t\t\terror instanceof TransformDecodeError && error.error\n\t\t\t\t\t? error.error\n\t\t\t\t\t: error\n\n\t\t\t// ? Since error is reconciled in mergeResponseWithHeaders, this is not needed (if I'm not drunk)\n\t\t\t// if ((reportedError as ElysiaErrors).status)\n\t\t\t// \tset.status = (reportedError as ElysiaErrors).status\n\n\t\t\t// @ts-expect-error private\n\t\t\treturn app.handleError(context, reportedError)\n\t\t} finally {\n\t\t\tif (app.event.afterResponse)\n\t\t\t\tfor (const afterResponse of app.event.afterResponse)\n\t\t\t\t\tawait afterResponse.fn(context as any)\n\t\t}\n\t}\n}\n\nexport const createDynamicErrorHandler = (app: AnyElysia) => {\n\tconst { mapResponse } = app['~adapter'].handler\n\n\treturn async (\n\t\tcontext: Context & {\n\t\t\tresponse: unknown\n\t\t},\n\t\terror: ElysiaErrors\n\t) => {\n\t\tconst errorContext = Object.assign(context, { error, code: error.code })\n\t\terrorContext.set = context.set\n\n\t\tif (app.event.error)\n\t\t\tfor (let i = 0; i < app.event.error.length; i++) {\n\t\t\t\tconst hook = app.event.error[i]\n\t\t\t\tlet response = hook.fn(errorContext as any)\n\t\t\t\tif (response instanceof Promise) response = await response\n\t\t\t\tif (response !== undefined && response !== null)\n\t\t\t\t\treturn (context.response = mapResponse(\n\t\t\t\t\t\tresponse,\n\t\t\t\t\t\tcontext.set\n\t\t\t\t\t))\n\t\t\t}\n\n\t\treturn new Response(\n\t\t\ttypeof error.cause === 'string' ? error.cause : error.message,\n\t\t\t{\n\t\t\t\theaders: context.set.headers as any,\n\t\t\t\tstatus: error.status ?? 500\n\t\t\t}\n\t\t)\n\t}\n}\n",
    "/* eslint-disable sonarjs/no-duplicate-string */\nimport { type createReadStream as CreateReadStream } from 'fs'\nimport { type stat as Stat } from 'fs/promises'\n\nimport { isBun } from './utils'\nimport type { BunFile } from 'bun'\nimport type { MaybePromise } from '../types'\n\nexport const mime = {\n\taac: 'audio/aac',\n\tabw: 'application/x-abiword',\n\tai: 'application/postscript',\n\tarc: 'application/octet-stream',\n\tavi: 'video/x-msvideo',\n\tazw: 'application/vnd.amazon.ebook',\n\tbin: 'application/octet-stream',\n\tbz: 'application/x-bzip',\n\tbz2: 'application/x-bzip2',\n\tcsh: 'application/x-csh',\n\tcss: 'text/css',\n\tcsv: 'text/csv',\n\tdoc: 'application/msword',\n\tdll: 'application/octet-stream',\n\teot: 'application/vnd.ms-fontobject',\n\tepub: 'application/epub+zip',\n\tgif: 'image/gif',\n\thtm: 'text/html',\n\thtml: 'text/html',\n\tico: 'image/x-icon',\n\tics: 'text/calendar',\n\tjar: 'application/java-archive',\n\tjpeg: 'image/jpeg',\n\tjpg: 'image/jpeg',\n\tjs: 'application/javascript',\n\tjson: 'application/json',\n\tmid: 'audio/midi',\n\tmidi: 'audio/midi',\n\tmp2: 'audio/mpeg',\n\tmp3: 'audio/mpeg',\n\tmp4: 'video/mp4',\n\tmpa: 'video/mpeg',\n\tmpe: 'video/mpeg',\n\tmpeg: 'video/mpeg',\n\tmpkg: 'application/vnd.apple.installer+xml',\n\todp: 'application/vnd.oasis.opendocument.presentation',\n\tods: 'application/vnd.oasis.opendocument.spreadsheet',\n\todt: 'application/vnd.oasis.opendocument.text',\n\toga: 'audio/ogg',\n\togv: 'video/ogg',\n\togx: 'application/ogg',\n\totf: 'font/otf',\n\tpng: 'image/png',\n\tpdf: 'application/pdf',\n\tppt: 'application/vnd.ms-powerpoint',\n\trar: 'application/x-rar-compressed',\n\trtf: 'application/rtf',\n\tsh: 'application/x-sh',\n\tsvg: 'image/svg+xml',\n\tswf: 'application/x-shockwave-flash',\n\ttar: 'application/x-tar',\n\ttif: 'image/tiff',\n\ttiff: 'image/tiff',\n\tts: 'application/typescript',\n\tttf: 'font/ttf',\n\ttxt: 'text/plain',\n\tvsd: 'application/vnd.visio',\n\twav: 'audio/x-wav',\n\tweba: 'audio/webm',\n\twebm: 'video/webm',\n\twebp: 'image/webp',\n\twoff: 'font/woff',\n\twoff2: 'font/woff2',\n\txhtml: 'application/xhtml+xml',\n\txls: 'application/vnd.ms-excel',\n\txlsx: 'application/vnd.ms-excel',\n\txlsx_OLD:\n\t\t'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n\txml: 'application/xml',\n\txul: 'application/vnd.mozilla.xul+xml',\n\tzip: 'application/zip',\n\t'3gp': 'video/3gpp',\n\t'3gp_DOES_NOT_CONTAIN_VIDEO': 'audio/3gpp',\n\t'3gp2': 'video/3gpp2',\n\t'3gp2_DOES_NOT_CONTAIN_VIDEO': 'audio/3gpp2',\n\t'7z': 'application/x-7z-compressed'\n} as const\n\nexport const getFileExtension = (path: string) => {\n\tconst index = path.lastIndexOf('.')\n\tif (index === -1) return ''\n\n\treturn path.slice(index + 1)\n}\n\nexport const file = (path: string) => new ElysiaFile(path)\n\nlet createReadStream: typeof CreateReadStream\nlet stat: typeof Stat\n\nexport class ElysiaFile {\n\treadonly value: MaybePromise<unknown>\n\treadonly stats: ReturnType<typeof Stat> | undefined\n\n\tconstructor(public path: string) {\n\t\tif (isBun) this.value = Bun.file(path)\n\t\telse {\n\t\t\t// Browser\n\t\t\t// @ts-ignore\n\t\t\tif (typeof window !== 'undefined') {\n\t\t\t\tconsole.warn('Browser environment does not support file')\n\t\t\t} else {\n\t\t\t\tif (!createReadStream || !stat) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tthis.value = import('fs').then((fs) => {\n\t\t\t\t\t\t\tcreateReadStream = fs.createReadStream\n\n\t\t\t\t\t\t\treturn fs.createReadStream(path)\n\t\t\t\t\t\t})\n\t\t\t\t\t\tthis.stats = import('fs/promises').then((fs) => {\n\t\t\t\t\t\t\tstat = fs.stat\n\n\t\t\t\t\t\t\treturn fs.stat(path)\n\t\t\t\t\t\t})\n\t\t\t\t\t} catch {\n\t\t\t\t\t\t// not empty\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.value = createReadStream(path)\n\t\t\t\t\tthis.stats = stat(path)!\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget type() {\n\t\treturn (\n\t\t\t// @ts-ignore\n\t\t\tmime[getFileExtension(this.path)] || 'application/octet-stream'\n\t\t)\n\t}\n\n\tget length() {\n\t\tif (isBun) return (this.value as BunFile).size\n\n\t\treturn this.stats?.then((x) => x.size) ?? 0\n\t}\n}\n"
  ],
  "mappings": "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",
  "debugId": "4A9A2FF22C06371364756E2164756E21",
  "names": []
}